; SUBROM.MAC
;
; MSX SUBROM
;
; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
;
; Source edited by Arjen Zeilemaker
;
; version 1.0 17-11-2005 

	.Z80
	ASEG
	ORG	0000H


	INCLUDE	MSX.INC


RDSLT	EQU	000CH
WRSLT	EQU	0014H
OUTDO	EQU	0018H
CALSLT	EQU	001CH
KEYINT	EQU	0038H
NMI	EQU	0066H
GICINI	EQU	0090H
CHGET	EQU	009FH
CKCNTC	EQU	00BDH
FNKSB	EQU	00C9H
SNSMAT	EQU	0141H
EOL	EQU	0168H
RDRES	EQU	017AH
WRRES	EQU	017DH

M.2F92	EQU	2F92H	; convert float (SGN or DBL) to integer
M.3058	EQU	3058H	; check if string
M.3236	EQU	3236H	; convert to SGN in DAC
M.3412	EQU	3412H	; print number
M.3FD7	EQU	3FD7H	; Ok message
M.4055	EQU	4055H	; syntax error
M.406A	EQU	406AH	; missing operand
M.406D	EQU	406DH	; type mismatch
M.406F	EQU	406FH	; error
M.46E6	EQU	46E6H	; basictext for constant handling
M.475A	EQU	475AH	; illegal function call
FRMEVL	EQU	4C64H	; evaluate expression
M.4FCF	EQU	4FCFH	; byte to DAC
M.51D7	EQU	51D7H	; helper routine ramdisk for transfers page 0
M.520F	EQU	520FH	; evaluate integer operand
GETBYT	EQU	521CH	; evaluate byte operand
FRMQNT	EQU	542FH	; evaluate adres operand
M.5439	EQU	5439H	; convert DAC to adres operand
M.579C	EQU	579CH	; evaluate graphic coordinatepair
M.57AB	EQU	57ABH	; evaluate 2nd graphic coordinatepair
M.5EA4	EQU	5EA4H	; locate variable
M.6275	EQU	6275H	; out of memory
M.6627	EQU	6627H	; allocate stringspace
M.6678	EQU	6678H	; print text (HL)
M.67D0	EQU	67D0H	; free (temp) string
M.6A0E	EQU	6A0EH	; parse filespec
M.6B24	EQU	6B24H	; close io buffer
M.6E6B	EQU	6E6BH	; bad filename
M.6E6E	EQU	6E6EH	; file already open
M.6E74	EQU	6E74H	; file not found
M.6E86	EQU	6E86H	; sequential io only
M.7323	EQU	7323H	; CR,LF if not at start of line
M.7328	EQU	7328H	; CR,LF to OUTDO
M.7EE4	EQU	7EE4H	; basic version text
M.7EF2	EQU	7EF2H	; MSX Basic text
M.7FFA	EQU	7FFAH	; EXTBIO entry in mainrom
M.7FFD	EQU	7FFDH	; BDOS entry in mainrom
D$C010	EQU	0C010H	; unknown

D$F33B	EQU	0F33BH	; adres pathnamebuffer, dos kernel 2.x
RDPRIM	EQU	0F380H
WRPRIM	EQU	0F385H
CLPRIM	EQU	0F38CH
CLPRM1	EQU	0F398H
LINL40	EQU	0F3AEH
LINL32	EQU	0F3AFH
LINLEN	EQU	0F3B0H
CRTCNT	EQU	0F3B1H
CLMLST	EQU	0F3B2H
TXTNAM	EQU	0F3B3H
TXTCOL	EQU	0F3B5H
TXTCGP	EQU	0F3B7H
T32NAM	EQU	0F3BDH
T32COL	EQU	0F3BFH
T32CGP	EQU	0F3C1H
T32ATR	EQU	0F3C3H
T32PAT	EQU	0F3C5H
GRPNAM	EQU	0F3C7H
GRPCOL	EQU	0F3C9H
GRPCGP	EQU	0F3CBH
GRPATR	EQU	0F3CDH
GRPPAT	EQU	0F3CFH
MLTNAM	EQU	0F3D1H
MLTCGP	EQU	0F3D5H
MLTATR	EQU	0F3D7H
MLTPAT	EQU	0F3D9H
CLIKSW	EQU	0F3DBH
CSRY	EQU	0F3DCH
CNSDFG	EQU	0F3DEH
RG0SAV	EQU	0F3DFH
RG1SAV	EQU	0F3E0H
RG2SAV	EQU	0F3E1H
RG3SAV	EQU	0F3E2H
RG4SAV	EQU	0F3E3H
RG5SAV	EQU	0F3E4H
RG6SAV	EQU	0F3E5H
RG7SAV	EQU	0F3E6H
FORCLR	EQU	0F3E9H
BAKCLR	EQU	0F3EAH
BDRCLR	EQU	0F3EBH
ATRBYT	EQU	0F3F2H
PUTPNT	EQU	0F3F8H
GETPNT	EQU	0F3FAH
CS1200	EQU	0F3FCH
CS2400	EQU	0F401H
LOW	EQU	0F406H
ASPCT1	EQU	0F40BH
ASPCT2	EQU	0F40DH
NTMSXP	EQU	0F417H
BUF	EQU	0F55EH
TTYPOS	EQU	0F661H
VALTYP	EQU	0F663H
CONTXT	EQU	0F666H
CONSAV	EQU	0F668H
CONTYP	EQU	0F669H
CONLO	EQU	0F66AH
DSCTMP	EQU	0F698H
SUBFLG	EQU	0F6A5H
STREND	EQU	0F6C6H
DAC	EQU	0F7F6H
NULBUF	EQU	0F862H
PTRFIL	EQU	0F864H
FILNAM	EQU	0F866H
NLONLY	EQU	0F87CH
FNKSTR	EQU	0F87FH
CGPNT	EQU	0F91FH
NAMBAS	EQU	0F922H
CGPBAS	EQU	0F924H
PATBAS	EQU	0F926H
ATRBAS	EQU	0F928H
CLOC	EQU	0F92AH
CMASK	EQU	0F92CH
CSAVEA	EQU	0F942H
CSAVEM	EQU	0F944H
LOHMSK	EQU	0F949H
LOHDIR	EQU	0F94AH
LOHADR	EQU	0F94BH
LOHCNT	EQU	0F94DH
SKPCNT	EQU	0F94FH
MOVCNT	EQU	0F951H
PDIREC	EQU	0F953H
LFPROG	EQU	0F954H
RTPROG	EQU	0F955H
DPPAGE	EQU	0FAF5H
ACPAGE	EQU	0FAF6H
AVCSAV	EQU	0FAF7H
EXBRSA	EQU	0FAF8H
CHRCNT	EQU	0FAF9H
ROMA	EQU	0FAFAH
MODE	EQU	0FAFCH	; b0	= SHIFT KANA mode
			; b1-b2	= VRAM Size
			; b3	= use fast vdp transfer in MSX1 screens
			; b4	= 212/256 lines
			; b5	= screen 11
			; b6	= JIS2 rom
			; b7	= upcase status SHIFT KANA mode
XSAVE	EQU	0FAFEH
YSAVE	EQU	0FB00H
LOGOPR	EQU	0FB02H
HOKVLD	EQU	0FB20H
LINTTB	EQU	0FBB2H
FSTPOS	EQU	0FBCAH
FNKSWI	EQU	0FBCDH
CLIKFL	EQU	0FBD9H
NEWKEY	EQU	0FBE5H
KEYBUF	EQU	0FBF0H
LINWRK	EQU	0FC18H
PATWRK	EQU	0FC40H
INTFLG	EQU	0FC9BH
GRPHED	EQU	0FCA6H
KANAST	EQU	0FCACH
KANAMD	EQU	0FCADH
SCRMOD	EQU	0FCAFH
OLDSCR	EQU	0FCB0H
BDRATR	EQU	0FCB2H
GXPOS	EQU	0FCB3H
GYPOS	EQU	0FCB5H
GRPACX	EQU	0FCB7H
GRPACY	EQU	0FCB9H
EXPTBL	EQU	0FCC1H
SLTTBL	EQU	0FCC5H
SLTWRK	EQU	0FD09H
PROCNM	EQU	0FD89H
H.INIP	EQU	0FDC7H
H.NMI	EQU	0FDD6H
H.ERRP	EQU	0FEFDH
H.CHRG	EQU	0FF48H
H.PHYD	EQU	0FFA7H
EXTBIO	EQU	0FFCAH
RG8SAV	EQU	0FFE7H
RG9SAV	EQU	0FFE8H
RG10SA	EQU	0FFE9H
RG11SA	EQU	0FFEAH
RG18SA	EQU	0FFF1H
RG23SA	EQU	0FFF6H
D.FFF7	EQU	0FFF7H	; slotid of mainrom
RG24SA	EQU	0FFF9H
RG25SA	EQU	0FFFAH
RG26SA	EQU	0FFFBH

D.FFFF	EQU	0FFFFH	; secundary slotreg


	.Z80
	ASEG
	ORG	00000H

	DEFB	"CD"
	DEFW	I035A
	DEFW	I1736
	DEFW	I36B4

S.SYNCHR:
	JP	J1CB7

	DEFS	000CH-$,0

S.RDSLT:
	JP	C01FD

	DEFS	0010H-$,0

S.CHRGTR:
	JP	J1CBF

	DEFS	0014H-$,0

S.WRSLT:
	JP	C0218

	DEFS	0018H-$,0

S.OUTDO:
	JP	J2787

	DEFS	001CH-$,0

S.CALM01:
	JP	C0262

	DEFS	0020H-$,0

S.DCOMPR:
	LD	A,H
	SUB	D
	RET	NZ
	LD	A,L
	SUB	E
	RET	

	DEFS	0028H-$,0

S.GETBYT:
	JP	C2824

	DEFS	0030H-$,0

S.CALM0F:
	JP	J0246

	DEFS	0038H-$,0

S.KEYINT:
	EX	AF,AF'
	EXX	
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	EX	AF,AF'
	EXX	
	PUSH	IX
	PUSH	IY
	LD	IX,KEYINT
	LD	IY,(EXPTBL+0-1)
	CALL	C279D			; call KEYINT in mainbios
	POP	IY
	POP	IX
	EX	AF,AF'
	EXX	
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	EX	AF,AF'
	EXX	
	EI	
	RETI

	DEFS	0066H-$,0

S.NMI:
	JP	H.NMI

S.PAINT:
	EI	
	JP	J264F

S.PSET:
	EI	
	JP	J2833

S.ATRSCN:
	EI	
	JP	C284C

S.GLINE:
	EI	
	JP	J28E4

S.DOBOXF:
	EI	
	JP	J2907

S.DOLINE:
	EI	
	JP	J291C

S.BOXLIN:
	EI	
	JP	J2925

S.DOGRPH:
	EI	
	JP	C299B

S.GRPPRT:
	EI	
	JP	J11C1

S.SCALXY:
	EI	
	JP	C137B

S.MAPXYC:
	EI
	JP	C1401

S.READC:
	EI	
	JP	C1443

S.SETATR:
	EI	
	JP	C146C

S.SETC:
	EI	
	JP	C1474

S.TRIGHT:
	EI	
	JP	C14F0

S.RIGHTC:
	EI	
	JP	J1503

S.TLEFTC:
	EI	
	JP	C14A6

S.LEFTC:
	EI	
	JP	J1515

S.TDOWNC:
	EI	
	JP	C14BB

S.DOWNC:
	EI	
	JP	J1556

S.TUPC:
	EI	
	JP	C14DE

S.UPC:
	EI	
	JP	J1562

S.SCANR:
	EI	
	JP	C15A5

S.SCANL:
	EI	
	JP	C1657

S.NVBXLN:
	EI	
	JP	C295F

S.NVBXFL:
	EI	
	JP	C2A75

S.CHGMOD:
	EI	
	JP	J0A50

S.INITXT:
	EI	
	JP	C0A72

S.INIT32:
	EI	
	JP	C0AA7

S.INIGRP:
	EI	
	JP	C0AD5

S.INIMLT:
	EI	
	JP	C0B25

S.SETTXT:
	EI	
	JP	C0BE3

S.SETT32:
	EI	
	JP	C0C3D

S.SETGRP:
	EI	
	JP	C0C73

S.SETMLT:
	EI	
	JP	C0CC3

S.CLRSPR:
	EI	
	JP	C076A

S.CALPAT:
	EI	
	JP	J07CE

S.CALATR:
	EI	
	JP	C07E3

S.GSPSIZ:
	EI	
	JP	C07F8

S.GETPAT:
	EI	
	JP	C0852

S.WRTVRM:
	EI	
	JP	C0959

S.RDVRM:
	EI	
	JP	C0964

S.CHGCLR:
	EI	
	JP	C09E1

S.CLS:
	EI	
	JP	C0877

S.CLRTXT:
	EI	
	JP	C08F2

S.DSPFNK:
	EI	
	JP	J0DF1

S.DELLNO:
	EI	
	JP	J0EB6

S.INSLNO:
	EI	
	JP	J0F04

S.PUTVRM:
	EI	
	JP	J0FBD

S.WRTVDP:
	EI	
	JP	C0685

S.VDPSTA:
	EI	
	JP	C2BEF

S.KYKLOK:
	EI	
	JP	J3E95

S.PUTCHR:
	EI	
	JP	J3C5A

S.SETPAG:
	EI	
	JP	C0711

S.INIPLT:
	EI	
	JP	C1046

S.RSTPLT:
	EI	
	JP	J1025

S.GETPLT:
	EI	
	JP	C1011

S.SETPLT:
	EI	
	JP	C107A

S.PUTSPR:
	EI	
	JP	J20D8

S.COLOR:
	EI	
	JP	J1D7B

S.SCREEN:
	EI	
	JP	J1E89

S.WIDTHS:
	EI	
	JP	J2028

S.VDP:
	EI	
	JP	J220F

S.VDPF:
	EI	
	JP	J2235

S.BASE:
	EI	
	JP	J2279

S.BASEF:
	EI	
	JP	J22F0

S.VPOKE:
	EI	
	JP	J235C

S.VPEEK:
	EI	
	JP	J236F

S.SETS:
	EI	
	JP	J1920

S.BEEP:
	EI	
	JP	J1B58

S.PROMPT:
	EI	
	JP	J1C3D

S.SDFSCR:
	EI	
	JP	J04F8

S.SETSCR:
	EI	
	JP	J04D2

S.SCOPY:
	EI	
	JP	J23AA

S.BLTVV:
	EI	
	JP	J2E2C

S.BLTVM:
	EI	
	JP	J2EB5

S.BLTMV:
	EI	
	JP	J2E52

S.BLTVD:
	EI	
	JP	J301B

S.BLTDV:
	EI	
	JP	J3127

S.BLTMD:
	EI	
	JP	J2FE2

S.BLTDM:
	EI	
	JP	J2FEF

S.NEWPAD:
	EI	
	JP	J349D

S.GETPUT:
	EI	
	JP	J1770

S.CHGMDP:
	EI	
	JP	C0A4C

S.RESVI:
	EI	
	JP	0

S.KNJPRT:
	EI	
	JP	J10F0

;	 Subroutine calslt mainrom on page 0, when subrom is also in a subslot of slot 0
;	    Inputs  ________________________
;	    Outputs ________________________
;           Remark  The working of this code depends on the fact that the mainrom contains code
;	            at 01D0H indentical to this code.
;	            NOT USED, BECAUSE TURBO-R has a predefined SUBROM slotid, which is not in slot 0!.
;	            Also, Turbo-R does not have the code required in mainrom anymore.


J01C1:	LD	A,B
	AND	3FH
	OUT	(0A8H),A
	LD	A,(D.FFFF)
	CPL	
	LD	C,A
	AND	D
	LD	E,A
	LD	(D.FFFF),A
					; from this point code continues to execute in mainrom

;
;	This code is executed from mainrom when calling the subrom when it was a subslot of slot 0
;

	LD	A,B
	AND	D
	OUT	(0A8H),A
	LD	A,E
	LD	(SLTTBL+0),A
	PUSH	BC
	EXX	
	EX	AF,AF'
	CALL	CLPRM1
	DI	
	EX	AF,AF'
	EXX	
	POP	BC
	LD	A,B
	AND	3FH
	OUT	(0A8H),A
	LD	A,C
	LD	(D.FFFF),A
					; from this point code returns executing from the mainrom

;
;	This code is executed when mainrom was called from the subrom when the subrom was in a subslot of slot 0
;

	LD	A,B
	OUT	(0A8H),A
	LD	A,C
	LD	(SLTTBL+0),A
	EX	AF,AF'
	EXX	
	RET	

S.REDCLK:
	EI	
	JP	J1C94

S.WRTCLK:
	EI	
	JP	J1C9C

;	 Subroutine S.RDSLT
;	    Inputs  ________________________
;	    Outputs ________________________
;           Remark  crashes when S.RDSLT is used for a slotid in the same primary slot as the subrom,
;	            but only on page 0
;	            NOT USED ANYWHERE IN SUBROM

C01FD:	CALL	C02DD			; calculate masks
	JP	M,J020D			; handle expanded slot
	IN	A,(0A8H)
	LD	D,A
	AND	C
	OR	B
	CALL	RDPRIM
	LD	A,E
	RET	

J020D:	PUSH	HL
	CALL	C0302			; adjust secundairy slotregister
	EX	(SP),HL
	PUSH	BC
	CALL	C01FD			; do S.RDSLT on only the primary slot
	JR	J0233

;	 Subroutine S.WRSLT
;	    Inputs  ________________________
;	    Outputs ________________________
;           Remark  crashes when S.WRSLT is used for a slotid in the same primary slot as the subrom,
;	            but only on page 0
;	            NOT USED ANYWHERE IN SUBROM

C0218:	PUSH	DE
	CALL	C02DD			; calculate masks
	JP	M,J0228			; handle expanded slot
	POP	DE
	IN	A,(0A8H)
	LD	D,A
	AND	C
	OR	B
	JP	WRPRIM

J0228:	EX	(SP),HL
	PUSH	HL
	CALL	C0302			; adjust secundairy slotregister
	POP	DE
	EX	(SP),HL
	PUSH	BC
	CALL	C0218			; do S.WRSLT on only the primary slot
J0233:	POP	BC
	EX	(SP),HL
	PUSH	AF
	LD	A,B
	AND	3FH
	OR	C
	OUT	(0A8H),A
	LD	A,L
	LD	(D.FFFF),A
	LD	A,B
	OUT	(0A8H),A
	POP	AF
	POP	HL
	RET	

;	 Subroutine callfar biosrom (page 0)
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  only usable for page 0 adresses

J0246:	EX	(SP),HL
	PUSH	AF
	PUSH	DE
	LD	A,(HL)
	PUSH	AF
	POP	IY
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	PUSH	DE
	POP	IX
	POP	DE
	POP	AF
	EX	(SP),HL

;	 Subroutine call biosrom (page 0)
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  only usable for page 0 adresses

J0258:	EXX	
	LD	D,0FCH
	JR	J0265

;	 Subroutine call basicrom (page 1)
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  only usable for page 1 adresses
;	            NOT USED ANYWHERE IN SUBROM

?.025D:	EXX	
	LD	D,0F3H
	JR	J0265

;	 Subroutine call mainrom (page 0 and page 1)
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  only usable for page 0 or 1 adresses

C0262:	EXX	
	LD	D,0F0H
J0265:	EX	AF,AF'
	DI	
	LD	A,(EXPTBL+0)
	AND	A
	IN	A,(0A8H)
	JP	M,J0276			; slot 0 is expanded, handle
	PUSH	AF
	AND	D
	EXX	
	JP	CLPRIM

J0276:	LD	B,A
	LD	A,(EXBRSA)
	AND	03H
	JR	NZ,J0284		; subrom is not in slot 0, use normal methode
	LD	A,D
	CP	0F3H			; mainrom only on page 1, use normal methode
	JP	NZ,J01C1		; use trick to avoid crash
J0284:	LD	A,B
	AND	3FH
	OUT	(0A8H),A
	LD	A,(D.FFFF)
	CPL	
	LD	C,A
	AND	D
	LD	(D.FFFF),A
	LD	E,A
	LD	A,B
	OUT	(0A8H),A
	LD	A,E
	LD	(SLTTBL+0),A
	LD	A,B
	PUSH	BC
	LD	HL,I02A6
	PUSH	HL
	PUSH	AF
	AND	D
	EXX	
	JP	CLPRIM

I02A6:	DI	
	EXX	
	EX	AF,AF'
	POP	BC
	LD	A,B
	AND	3FH
	OUT	(0A8H),A
	LD	A,C
	LD	(D.FFFF),A
	LD	A,B
	OUT	(0A8H),A
	LD	A,C
	LD	(SLTTBL+0),A
	EX	AF,AF'
	EXX	
	RET	

;	 Subroutine ´S.ENASLT´
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  crashes when adres is in page 0

C02BD:	CALL	C02DD			; calculate masks
	JP	M,J02CA			; handle expanded slot
	IN	A,(0A8H)
	AND	C
	OR	B
	OUT	(0A8H),A
	RET	

J02CA:	PUSH	HL
	CALL	C0302			; adjust secundairy slotregister
	LD	C,A
	LD	B,00H
	LD	A,L
	AND	H
	OR	D
	LD	HL,SLTTBL
	ADD	HL,BC
	LD	(HL),A
	POP	HL
	LD	A,C
	JR	C02BD			; do S.ENASLT on only the primary slot


;	 Subroutine caculate masks
;	    Inputs  ________________________
;	    Outputs ________________________

C02DD:	DI	
	PUSH	AF
	LD	A,H
	RLCA	
	RLCA	
	AND	03H
	LD	E,A
	LD	A,0C0H
J02E7:	RLCA	
	RLCA	
	DEC	E
	JP	P,J02E7
	LD	E,A
	CPL	
	LD	C,A
	POP	AF
	PUSH	AF
	AND	03H
	INC	A
	LD	B,A
	LD	A,0ABH
J02F8:	ADD	A,55H
	DJNZ	J02F8
	LD	D,A
	AND	E
	LD	B,A
	POP	AF
	AND	A
	RET	

;	 Subroutine adjust secundairy slotregister
;	    Inputs  ________________________
;	    Outputs ________________________

C0302:	PUSH	AF
	LD	A,D
	AND	0C0H
	LD	C,A
	POP	AF
	PUSH	AF
	LD	D,A
	IN	A,(0A8H)
	LD	B,A
	AND	3FH
	OR	C
	OUT	(0A8H),A
	LD	A,D
	RRCA	
	RRCA	
	AND	03H
	LD	D,A
	LD	A,0ABH
J031A:	ADD	A,55H
	DEC	D
	JP	P,J031A
	AND	E
	LD	D,A
	LD	A,E
	CPL	
	LD	H,A
	LD	A,(D.FFFF)
	CPL	
	LD	L,A
	AND	H
	OR	D
	LD	(D.FFFF),A
	LD	A,B
	OUT	(0A8H),A
	POP	AF
	AND	03H
	RET	

;
; Looks like a copyrightmessage. Not used anywhere
;

?.0336:	DEFM	'Copyright 1988 by ASCII corporation',00H

;	 Subroutine subrom init routine
;	    Inputs  ________________________
;	    Outputs ________________________

I035A:	LD	HL,I2C5A
	LD	DE,RG0SAV
	LD	BC,8
	LDIR	
	LD	DE,RG8SAV
	LD	C,16
	LDIR	
	LD	DE,RG24SA
	LD	C,4
	LDIR	
	XOR	A
	LD	(DPPAGE),A		; display page 0
	LD	(ACPAGE),A		; active page 0
	CALL	C058B
	LD	(EXBRSA),A		; slotid of subrom
	LD	H,A
	LD	L,0F7H
	LD	(H.ERRP+0),HL		; RST CALLF	DB SUBSID
	LD	HL,I3BA2
	LD	(H.ERRP+2),HL		; DW I3BA2
	LD	A,(EXPTBL+0)
	LD	(D.FFF7),A
	LD	HL,MODE
	RES	1,(HL)
	SET	2,(HL)			; 128 Kb VRAM
	LD	A,(HOKVLD)
	BIT	0,A
	JR	NZ,J03B2		; EXTBIO already initialized,
	OR	01H
	LD	(HOKVLD),A
	LD	HL,EXTBIO
	LD	DE,EXTBIO+1
	LD	BC,3*5-1
	LD	(HL),0C9H
	LDIR				; initialize EXTBIO,DISINT and ENAINT hooks
J03B2:	LD	A,0D3H
	OUT	(0F7H),A
	LD	(AVCSAV),A
	XOR	A
	OUT	(0F5H),A		; disable all internal devices
	LD	C,0FFH			; flag all internal devices enabled
	OUT	(0D8H),A
	LD	A,02H
	OUT	(0D9H),A
	LD	HL,I0583
	LD	B,8
J03C9:	IN	A,(0D9H)
	CP	(HL)
	JR	NZ,J03D3		; no JIS1 rom
	INC	HL
	DJNZ	J03C9
	RES	0,C			; external JIS1 rom, flag disable internal JIS1 rom
J03D3:	CALL	C04E2			; check for JIS2 rom
	JR	NZ,J03DA
	RES	1,C			; external JIS2 rom, flag disable internal JIS2 rom
J03DA:	IN	A,(0C0H)
	CP	0FFH
	JR	Z,J03E2
	RES	2,C			; external MSX-AUDIO, flag disable internal MSX-AUDIO
J03E2:	IN	A,(0F7H)
	AND	77H
	CP	77H
	JR	Z,J03EC
	RES	3,C			; external superimpose, flag disable internal superimpose
J03EC:	IN	A,(0C8H)
	CP	0FFH
	JR	Z,J03F4
	RES	4,C			; external MSX interface, disable internal MSX interface
J03F4:	XOR	A
	OUT	(81H),A
	PUSH	AF
	POP	AF
	OUT	(81H),A
	PUSH	AF
	POP	AF
	OUT	(81H),A
	PUSH	AF
	POP	AF
	LD	A,40H
	OUT	(81H),A
	EX	(SP),HL
	EX	(SP),HL
	IN	A,(81H)
	AND	3FH
	CP	05H
	JR	NZ,J0411
	RES	5,C			; external MSX-serial, disable internal MSX-serial
J0411:	IN	A,(0BBH)
	CP	0FFH
	JR	Z,J0419
	RES	6,C			; external lightpen, disable internal lightpen
J0419:	LD	A,C
	OUT	(0F5H),A		; enable internal devices
	CALL	C04E2			; check for JIS2 rom
	JR	NZ,J0426		; nope,
	LD	HL,MODE
	SET	6,(HL)			; flag JIS2 rom
J0426:	CALL	C1C83			; select bank 2 clockchip
	LD	B,00H			; pos 0
	CALL	C1C5E			; read nibble from clockchip
	CP	0AH
	JR	Z,J0435
J0432:	CALL	C0493			; initialize bank 2 and 3 clockchip
J0435:	CALL	C1C83			; select bank 2 clockchip
	LD	B,3			; pos 3
	CALL	C1C5E			; read nibble from clockchip
	AND	01H			; screen mode
	PUSH	AF
	CALL	C1C67			; read byte from clockchip
	POP	BC
	CP	80+1
	JP	NC,J0432		; width >80, init
	OR	A
	JP	Z,J0432			; width 0, init
	DEC	B
	JR	NZ,J0455		; screen 0, done
	CP	32+1
	JP	NC,J0432		; width >32, init
J0455:	CALL	C1C83			; select bank 2 clockchip
	LD	B,1			; pos 1
	CALL	C1C5E			; read nibble from clockchip
	LD	D,A
	CALL	C1C5E			; read nibble from clockchip
	LD	E,A
	CALL	C18E5			; vdp(18)=
	CALL	C2769			; RDRES
	RLCA	
	JR	C,J0476			; b7 set, skip memorycount and startupscreen
	CALL	C05DE			; count memorymapper ram
	PUSH	HL
	CALL	C05A7			; clear RAM
	POP	HL
	CALL	C2C76			; startup screen
J0476:	CALL	C3F1C			; copy roms for R800 ROM mode
	LD	A,80H
	CALL	C276F			; WRRES (b7 set, next soft reset skips startup)

	IF	MSXMID EQ 1
;
; Panasonic FS-A1GT has PCM sampler init here
;
	CALL	C3F5B			; initialize PCM sampler

	ENDIF

	CALL	C067A			; disable vdp display output
	XOR	A
	LD	L,A
	LD	H,A
	LD	BC,4000H
	CALL	C0A05			; fill first 16 Kb VRAM with zero's
	CALL	C1046			; S.INIPLT (initialize palette)
	JP	C0AA7			; S.INIT32 and quit

;	 Subroutine initialize bank 2 and 3 clockchip
;	    Inputs  ________________________
;	    Outputs ________________________

C0493:	LD	HL,I0578
	LD	C,2			; bank 2
J0498:	LD	B,13			; pos 13
	LD	A,04H
	SUB	C			; select bank, no alarm, pause clock
	CALL	C1B4F			; write nibble to clockchip
	LD	B,13
J04A2:	LD	A,13
	SUB	B
	OUT	(0B4H),A		; select pos
	LD	A,(HL)
	INC	HL
	CP	0FFH
	JR	NZ,J04AF
	DEC	HL
	XOR	A
J04AF:	OUT	(0B5H),A
	DJNZ	J04A2
	DEC	C
	JR	NZ,J0498
	LD	B,13			; pos 13
	LD	A,08H			; alarm off, clock running
	CALL	C1B4F			; write nibble to clockchip
	XOR	A			; no test mode
	CALL	C1B4F			; write nibble to clockchip
	LD	A,0DH			; 1 Hz off, 16 Hz off, no reset dividers, reset alarm regs
	CALL	C1B4F			; write nibble to clockchip
	LD	A,1			; bank 1
	CALL	C1C85			; select bank clockchip
	LD	B,10			; pos 10
	LD	A,01H			; 24 hour system
	JP	C1B4F			; write nibble to clockchip

;	 Subroutine S.SETSCR (setup screen for basicstart)
;	    Inputs  ________________________
;	    Outputs ________________________

J04D2:	SCF				; flag use normal functionkey setting
	CALL	C04F9			; initialize settings stored in clockchip
	LD	HL,M.7EF2
	CALL	C280C			; print msx basic
	LD	HL,M.7EE4
	JP	C280C			; print version

;	 Subroutine check for JIS2 rom
;	    Inputs  none
;	    Outputs Zx set if JIS2 rom found

C04E2:	PUSH	BC
	LD	A,3EH
	OUT	(0DAH),A
	LD	A,35H
	OUT	(0DBH),A
	LD	BC,0800H
J04EE:	IN	A,(0DBH)
	ADD	A,C
	LD	C,A
	DJNZ	J04EE
	CP	95H
	POP	BC
	RET	

;	 Subroutine S.SDFSCR (setup screen with functionkeys display disabled)
;	    Inputs  ________________________
;	    Outputs ________________________

J04F8:	XOR	A			; flag disable display of functionkeys

;	 Subroutine initialize settings stored in clockchip
;	    Inputs  Cx set for normal functionkeys display, Cx reset for disabled functionkey display
;	    Outputs _______________________

C04F9:	PUSH	AF
	CALL	C1C83			; select bank 2 clockchip
	LD	B,3			; pos 3
	CALL	C1C5E			; read nibble from clockchip
	LD	C,A
	AND	01H			; screenmode
	POP	DE
	PUSH	AF
	PUSH	DE
	PUSH	BC
	LD	A,C
	RLCA	
	RLCA	
	AND	08H			; interlace
	LD	C,A
	LD	A,(RG9SAV)
	AND	0F7H
	OR	C
	LD	B,A
	LD	C,09H
	CALL	C0685			; Write VDP register 9 (setup interlace mode)
	POP	BC
	CALL	C1C67			; read byte from clockchip
	LD	E,A			; screenwidth
	POP	AF
	PUSH	DE
	PUSH	AF
	CALL	C1C5E			; read nibble from clockchip
	LD	(FORCLR),A
	LD	(ATRBYT),A		; forgroundcolor
	CALL	C1C5E			; read nibble from clockchip
	LD	(BAKCLR),A		; backgroundcolor
	CALL	C1C5E			; read nibble from clockchip
	LD	(BDRCLR),A		; bordercolor
	CALL	C1C5E			; read nibble from clockchip
	LD	C,A
	RRC	C			; Cx has display of functionkeys setting
	SBC	A,A			; Cx reset -> 00H, Cx set -> 0FFH
	LD	B,A
	POP	AF
	JR	NC,J0544		; flag set to disable display of functionkeys, do this
	LD	A,B
J0544:	LD	(CNSDFG),A		; display functionkeys setting
	RRC	C			; Cx has keyclick
	SBC	A,A
	LD	(CLIKSW),A		; keyclick setting
	BIT	1,C
	PUSH	BC
	LD	BC,5
	LD	HL,CS1200
	JR	Z,J055B			; 1200 bps cassette speed
	LD	HL,CS2400		; 2400 bps cassette speed
J055B:	LD	DE,LOW
	LDIR	
	POP	BC
	RRC	C			; Cx has MSX printermode
	SBC	A,A
	LD	(NTMSXP),A
	POP	DE
	POP	AF
	LD	(OLDSCR),A
	LD	(SCRMOD),A
	PUSH	DE
	CALL	C0A4C			; setup screenmode with paletteinit
	POP	DE
	JP	J2048			; setup screenwidth


;	leftover from patch ?
;	NOT USED ANYWHERE

	IF	OPTM EQ 0

?.0577:	RET	

	ENDIF


I0578:	DEFB	00AH
	DEFB	000H,000H

	IF BASVER EQ 0
	DEFB	001H
	ELSE
	DEFB	000H
	ENDIF

	IF BASVER EQ 0
	DEFB	00DH,001H
	ELSE
	DEFB	005H,002H
	ENDIF

	DEFB	00FH,004H

	IF BASVER EQ 0
	DEFB	007H
	ELSE
	DEFB	004H
	ENDIF

	DEFB	003H

	IF CNTRY NE 0
	DEFB	001H
	DEFB	000H
	DEFB	CNTRY
	ENDIF

	DEFB	0FFH


; JIS1 test pattern

I0583:	DEFB	000H,040H,020H,010H,008H,004H,002H,001H

;	 Subroutine get slotid of myself
;	    Inputs  ________________________
;	    Outputs ________________________

C058B:	PUSH	BC
	PUSH	HL
	IN	A,(0A8H)
	AND	03H
	LD	C,A
	LD	B,00H
	LD	HL,EXPTBL
	ADD	HL,BC
	OR	(HL)
	LD	C,A
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	AND	03H
	RLCA	
	RLCA	
	OR	C
	POP	HL
	POP	BC
	RET	

;	 Subroutine clear RAM
;	    Inputs  ________________________
;	    Outputs ________________________

C05A7:	LD	HL,EXPTBL
	LD	B,0
J05AC:	LD	C,(HL)
J05AD:	LD	A,C
	OR	B
	CALL	C05CA			; clear 04000H and 08000H (no expansion roms in RAM)
	BIT	7,C
	JR	Z,J05BE			; slot is not expanded, next primary slot
	LD	A,C
	ADD	A,4
	LD	C,A
	BIT	4,C
	JR	Z,J05AD			; next secundairy slot
J05BE:	INC	HL
	INC	B
	LD	A,B
	CP	4
	JR	C,J05AC			; next primary slot
	XOR	A
	LD	(D$C010),A
	RET	

;	 Subroutine clear RAM from expansionmarker
;	    Inputs  A = slotid
;	    Outputs ________________________

C05CA:	PUSH	BC
	PUSH	HL
	LD	HL,4000H
	LD	E,L			; 0
	PUSH	AF
	CALL	C2793			; write to slot
	POP	AF
	LD	H,80H
	LD	E,L			; 0
	CALL	C2793			; write to slot
	POP	HL
	POP	BC
	RET	

;	 Subroutine count all memorymapper pages
;	    Inputs  ________________________
;	    Outputs HL = memorymapper pages

C05DE:	LD	HL,0			; memorymapper pages found
	LD	DE,EXPTBL
	LD	B,0
J05E6:	LD	A,(DE)
	LD	C,A
J05E8:	LD	A,C
	OR	B
	CALL	C060B			; test slot for memorymapper pages
	BIT	7,C
	JR	Z,J05F9			; slot not expanded, next primary slot
	LD	A,C
	ADD	A,04H
	LD	C,A
	BIT	4,C
	JR	Z,J05E8			; next secundairy slot
J05F9:	INC	DE
	INC	B
	LD	A,B
	CP	04H
	JR	C,J05E6			; next primary slot
	PUSH	HL
	LD	H,40H
	LD	A,(EXPTBL+0)
	CALL	C02BD			; S.ENASLT (enable BASIC ROM on page 1)
	POP	HL
	RET	

;	 Subroutine count memorymapper pages in slot
;	    Inputs  A = slotid, HL = memorymapper pages so far
;	    Outputs HL= memorymapper pages updated

C060B:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	H,40H
	CALL	C02BD			; enable slot on page 1
	CALL	C0624			; test memorymapper
	POP	HL
	JR	C,J0621			; no mapper, quit
	LD	C,A
	LD	B,0
	AND	A
	JR	NZ,J0620
	INC	B			; zero means 256 pages
J0620:	ADD	HL,BC			; adjust memorymapper pages found
J0621:	POP	DE
	POP	BC
	RET	

;	 Subroutine test memorymapper
;	    Inputs  ________________________
;	    Outputs Cx set if no memorymapper, A = number of memorymapper pages

C0624:	LD	HL,4000H
	XOR	A
	OUT	(0FDH),A
	LD	(HL),0AAH
	INC	A
	OUT	(0FDH),A
	LD	(HL),55H
	DEC	A
	OUT	(0FDH),A
	LD	A,(HL)
	CP	0AAH
	SCF	
	JR	NZ,J0655
	LD	B,00H
J063C:	LD	A,B
	OUT	(0FDH),A
	LD	(HL),0AAH
	INC	B
	JR	NZ,J063C
J0644:	LD	A,B
	OUT	(0FDH),A
	INC	B
	LD	A,(HL)
	CP	0AAH
	JR	NZ,J0653
	LD	A,55H
	LD	(HL),A
	CP	(HL)
	JR	Z,J0644
J0653:	DEC	B
	AND	A
J0655:	LD	A,2
	OUT	(0FDH),A
	LD	A,B
	RET	

;	 Subroutine change functionkey displaystatus and check if in textmode
;	    Inputs  ________________________
;	    Outputs Cx set when in textmode

C065B:	LD	(CNSDFG),A

;	 Subroutine check if in screenmode 2
;	    Inputs  ________________________
;	    Outputs ________________________

C065E:	LD	A,(SCRMOD)
	CP	2
	RET	

;	 Subroutine check if in screenmode 4
;	    Inputs  ________________________
;	    Outputs ________________________

C0664:	LD	A,(SCRMOD)
	CP	4
	RET	

;	 Subroutine check if new style MSX2 screen
;	    Inputs  ________________________
;	    Outputs ________________________

C066A:	LD	A,(SCRMOD)
	CP	5
	RET

;	 Subroutine enable vdp displayoutput
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  Beats me why the IE0 bit is explicitly set

J0670:	CALL	C10DB			; wait for start of Vertikal Retrace
	LD	A,(RG1SAV)
	OR	60H			; IE0=1,BL=1 (enable screen and VR interrupts)
	JR	J0682

;	 Subroutine disable vdp display output
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  Beats me why the b7 bit is explicitly reset

C067A:	CALL	C10DB			; wait for start of Vertikal Retrace
	LD	A,(RG1SAV)
	AND	3FH			; BL=0, b7 (unsed bit)=0 (disable screen)
J0682:	LD	C,1

;	 Subroutine write vdp register
;	    Inputs  C = VDP register, A = data
;	    Outputs ________________________

C0684:	LD	B,A

;	 Subroutine S.WRTVDP
;	    Inputs  C = VDP register, B = data
;	    Outputs ________________________

C0685:	LD	A,I
	PUSH	AF			; save interrupt state
	PUSH	HL
	LD	A,C
	AND	A
	JR	NZ,J06BE		; not vdp register 0, skip digitize check
	LD	A,B
	LD	HL,RG0SAV
	XOR	(HL)
	AND	01H
	JR	Z,J06BE			; External VDP bit unchanged, continue
	LD	HL,RG9SAV
	LD	A,(HL)
	AND	0CFH
	LD	(HL),A			; reset SYM1 and SYM0 bits
	LD	A,B
	AND	01H
	RRCA
	RRCA
	RRCA
	RRCA
	OR	(HL)			; External VDP bit in SYM0 bit
	PUSH	BC
	LD	B,A
	LD	C,9
	LD	HL,AVCSAV
	LD	A,(HL)
	AND	3FH
	LD	(HL),A
	LD	A,B
	RLCA	
	RLCA	
	CPL	
	AND	0C0H
	OR	(HL)
	OUT	(0F7H),A
	LD	(HL),A			; setup digitizer hardware
	CALL	C0685			; update vdp register 9
	POP	BC
J06BE:	LD	A,B
	DI	
	OUT	(99H),A
	LD	A,C
	OR	80H
	OUT	(99H),A
	PUSH	BC
	PUSH	DE
	LD	D,B
	LD	A,C
	LD	B,00H
	CP	7+1
	LD	HL,RG0SAV
	JR	C,J06E4
	CP	23+1
	LD	HL,RG8SAV-8
	JR	C,J06E4
	JR	Z,J06E6			; register 24 has no readback variable
	CP	28
	JR	NC,J06E6		; register 28 and above have no readback variables
	LD	HL,RG25SA-25
J06E4:	ADD	HL,BC
	LD	(HL),D
J06E6:	CALL	C06F0			; setup digitizer
	POP	DE
	POP	BC
	POP	HL
	POP	AF
	RET	PO
	EI				; restore interrupt state
	RET

;	 Subroutine setup digitzer
;	    Inputs  ________________________
;	    Outputs ________________________

C06F0:	LD	A,(RG0SAV)
	AND	0EH
	RRCA
	LD	C,A
	LD	A,(RG1SAV)
	AND	18H
	OR	C
	LD	C,A
	LD	A,(RG8SAV)
	AND	20H
	OR	C
	LD	C,A
	LD	A,(RG25SA)
	AND	18H
	RLCA
	RLCA
	RLCA
	OR	C
	OUT	(0F3H),A
	RET	

;	 Subroutine S.SETPAG (setup display and active page)
;	    Inputs  ________________________
;	    Outputs ________________________

C0711:	LD	A,(SCRMOD)
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL			; save regs
	DI	
	LD	HL,I0721		; setpage jumptable
	CALL	C0A56			; call screenmode specific routine
	JR	J0765			; restore regs and quit

I0721:	DEFW	C0BE3			; SETPAGE for screenmode 0 is S.SETTXT
	DEFW	C0C3D			; SETPAGE for screenmode 1 is S.SETT32
	DEFW	C0C73			; SETPAGE for screenmode 2 is S.SETGRP
	DEFW	C0CC3			; SETPAGE for screenmode 3 is S.SETMLT
	DEFW	C0C7A			; setup vdp for screenmode 4
	DEFW	C0CF7			; setup vdp for screenmode 5
	DEFW	C0D21			; setup vdp for screenmode 6
	DEFW	C0D38			; setup vdp for screenmode 7
	DEFW	C0D68			; setup vdp for screenmode 8

;	 Subroutine setup VDP registers and digitizehardware
;	    Inputs  ________________________
;	    Outputs ________________________

J0733:	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	DI	
	XOR	A
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; VDP controlregister = register 0, auto update
	CALL	C10DB			; wait for start of Vertikal Retrace
	LD	C,9BH
	LD	HL,RG0SAV
	LD	B,8
	OTIR				; write vdp register 0-7
	LD	HL,RG8SAV
	LD	B,16
	OTIR				; write vdp register 8-23
	LD	A,25
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; VDP controlregister = register 25, auto update
	LD	HL,RG25SA
	LD	B,3
	OTIR				; write vdp registers 25-27
	EI	
	CALL	C06F0			; setup digitizehardware
J0765:	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET	

;	 Subroutine S.CLRSPR
;	    Inputs  ________________________
;	    Outputs ________________________

C076A:	CALL	C0776			; clear spritepatterntable, initialize planes and colortable
	PUSH	HL
	LD	HL,0
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	POP	HL
	RET	

;	 Subroutine clear spritepatterntable, initialize planes and colortable
;	    Inputs  ________________________
;	    Outputs ________________________

C0776:	LD	A,(RG1SAV)
	LD	C,1
	CALL	C0684			; write vdp register 1
	LD	A,(SCRMOD)
	AND	A
	RET	Z			; screenmode 0 has no sprites, quit
	LD	HL,(PATBAS)
	LD	BC,256*8
	XOR	A
	CALL	C0A05			; clear spritepatterntable

;	 Subroutine initialize spriteplanes and spritecolortable
;	    Inputs  ________________________
;	    Outputs ________________________

	IF	OPTM EQ 0

C078D:	LD	A,(FORCLR)
	LD	E,A
	LD	HL,(ATRBAS)
	LD	BC,32*256+0		; 32 spriteplanes, begin with pattern 0
J0797:	CALL	C0664			; check if in MSX1 screenmode (spritemode 1)
	LD	A,208+1			; 208 is special disable value in spritemode 1, maybe that is why 209 is chosen ?
	JR	C,J07A0			; yes, use off screen value spritemode 1
	LD	A,216+1			; 216 is special disable value in spritemode 2, maybe that is why 217 is chosen ?
J07A0:	CALL	C0959			; WTRVRM (y-coordinate)
	INC	HL
	INC	HL
	LD	A,C
	CALL	C0959			; WTRVRM (patternnumber)
	INC	HL
	INC	C
	LD	A,(RG1SAV)
	RRCA	
	RRCA	
	JR	NC,J07B5
	INC	C
	INC	C
	INC	C			; 16x16 mode, increase patternnumber by 4
J07B5:	LD	A,E
	CALL	C0959			; WTRVRM (color, no EC). not used in spritemode 2
	INC	HL
	DJNZ	J0797			; next spriteplane
	CALL	C0664			; check if in MSX1 screenmode
	RET	C			; yep, quit
	LD	HL,(ATRBAS)
	LD	BC,0200H
	SBC	HL,BC
	LD	A,(FORCLR)
	JP	C0A05			; clear spritecolor table

	ELSE

C078D:	LD	A,(FORCLR)
	LD	E,A
	LD	HL,(ATRBAS)
	LD	BC,32*256+0		; 32 spriteplanes, begin with pattern 0
J0797:	CALL	C0664			; check if in MSX1 screenmode (spritemode 1)
	LD	A,208+1			; 208 is special disable value in spritemode 1, maybe that is why 209 is chosen ?
	JR	C,J07A0			; yes, use off screen value spritemode 1
	LD	A,216+1			; 216 is special disable value in spritemode 2, maybe that is why 217 is chosen ?
J07A0:	CALL	C0959			; WTRVRM (y-coordinate)
	INC	HL
	INC	HL
	LD	A,C
	CALL	C0959			; WTRVRM (patternnumber)
	INC	HL
	INC	C
	CALL	C07F8			; S.GSPSIZ
	JR	NC,J07B5
	INC	C
	INC	C
	INC	C			; 16x16 mode, increase patternnumber by 4
J07B5:	LD	A,E
	CALL	C0959			; WTRVRM (color, no EC). not used in spritemode 2
	INC	HL
	DJNZ	J0797			; next spriteplane
	CALL	C0664			; check if in MSX1 screenmode
	RET	C			; yep, quit
	LD	HL,(ATRBAS)
	LD	BC,0FE00H
	ADD	HL,BC
	LD	A,(FORCLR)
	JP	C0A05			; clear spritecolor table

	ENDIF

;	 Subroutine S.CALPAT
;	    Inputs  A=patternnumber
;	    Outputs HL=adres of pattern

	IF	OPTM EQ 0

J07CE:	LD	L,A
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; 8x8 sprites have 8 bytes per pattern
	CALL	C07F8			; get spritesize
	CP	8
	JR	Z,J07DD
	ADD	HL,HL
	ADD	HL,HL			; 16x16 sprites have 32 bytes per pattern
J07DD:	EX	DE,HL
	LD	HL,(PATBAS)
	ADD	HL,DE			; adres of pattern
	RET

	ELSE

J07CE:	LD	L,A
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; 8x8 sprites have 8 bytes per pattern
	CALL	C07F8			; get spritesize
	JR	NC,J07DD
	ADD	HL,HL
	ADD	HL,HL			; 16x16 sprites have 32 bytes per pattern
J07DD:	EX	DE,HL
	LD	HL,(PATBAS)
	ADD	HL,DE			; adres of pattern
	RET

	ENDIF

;	 Subroutine S.CALATR
;	    Inputs  A=planenumber
;	    Outputs HL=adres of plane

C07E3:	LD	L,A
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	EX	DE,HL
	LD	HL,(ATRBAS)
	ADD	HL,DE
	RET	

;	 Subroutine get plane colorentry
;	    Inputs  A=planenumber
;	    Outputs ________________________

C07EE:	ADD	A,A
	ADD	A,A
	CALL	C07E3
	LD	DE,0FE00H
	ADD	HL,DE			; spritecolor table is in front of the sprite attribute table
	RET	

;	 Subroutine S.GSPSIZ
;	    Inputs  ________________________
;	    Outputs ________________________

C07F8:	LD	A,(RG1SAV)
	RRCA	
	RRCA	
	LD	A,8
	RET	NC
	LD	A,32
	RET	

;	 Subroutine initialize patterngenerator with msx characterset
;	    Inputs  ________________________
;	    Outputs ________________________

C0803:	CALL	H.INIP
	LD	HL,(CGPBAS)
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	LD	A,(CGPNT+0)
	LD	HL,(CGPNT+1)
	LD	BC,0800H
	PUSH	AF
J0816:	POP	AF
	PUSH	AF
	PUSH	BC
	DI	
	CALL	C278D			; RDSLT
	EI	
	POP	BC
	OUT	(98H),A
	INC	HL
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J0816
	POP	AF
	RET	

;	 Subroutine transfer from VRAM to RAM
;	    Inputs  HL=VRAM base adres, DE=RAM adres, BC=size
;	    Outputs ________________________

C0829:	CALL	C097F			; setup vdp adresregister for active screenpage (read)
	LD	A,C
	OR	A			; test if transfersize dividable by 256
	LD	A,B
	LD	B,C
	LD	C,98H
	EX	DE,HL
	JR	Z,J0836
	INC	A			; extra INIR loop if not dividable by 256
J0836:	INIR	
	DEC	A
	JR	NZ,J0836
	EX	DE,HL
	RET	

	IF	OPTM EQ 0

;	 Subroutine transfer from RAM to VRAM
;	    Inputs  HL=RAM adres, DE=VRAM base adres, BC=size
;	    Outputs ________________________
; 	    Remark  UNUSED CODE

?.083D:	EX	DE,HL
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	EX	DE,HL
	LD	A,C
	OR	A
	LD	A,B
	LD	B,C
	LD	C,98H
	JR	Z,J084B
	INC	A
J084B:	OTIR	
	DEC	A
	JR	NZ,J084B
	EX	DE,HL
	RET	

	ENDIF


;	 Subroutine S.GETPAT (copy characterpattern to PATWRK)
;	    Inputs  A=charcode
;	    Outputs ________________________

C0852:	LD	H,0
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *8
	EX	DE,HL
	LD	HL,(CGPNT+1)
	ADD	HL,DE
	LD	DE,PATWRK
	LD	B,8
	LD	A,(CGPNT+0)
J0865:	PUSH	AF
	PUSH	HL
	PUSH	DE
	PUSH	BC
	CALL	C278D			; RDSLT
	EI	
	POP	BC
	POP	DE
	POP	HL
	LD	(DE),A
	INC	DE
	INC	HL
	POP	AF
	DJNZ	J0865
	RET	

;	 Subroutine S.CLS
;	    Inputs  ________________________
;	    Outputs ________________________

C0877:	CALL	C0664			; check if in MSX1 screenmode
	JP	Z,C0923			; in screenmode 4, clear screen for screenmode 2 and 4
	JR	NC,C088A		; new style MSX2 screenmode,
	CALL	C065E			; check if in screenmode 2
	JP	Z,C0923			; in screenmode 2, clear screen for screenmode 2 and 4
	JP	NC,C093B		; clear screen for screenmode 3
	JR	C08F2			; text screenmode, clear screen for textscreenmodes

;	 Subroutine clear screen for new style MSX2 screenmodes
;	    Inputs  ________________________
;	    Outputs ________________________

C088A:	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C2BE4			; wait until VDP command is done
	LD	A,(BAKCLR)
	CALL	C08CC			; calculate colorbyte
	CALL	C2C4F			; setup color
	XOR	A			; dy=0
	LD	H,A
	LD	L,A			; dx=0
	CALL	C2C09			; setup dx,dy
	XOR	A
	CALL	C2C3F			; setup argument
	LD	A,(SCRMOD)
	AND	02H
	LD	DE,256			; nx=256
	JR	Z,J08AF
	INC	D			; screenmode 6 and 7, nx=512
J08AF:	LD	A,(MODE)
	AND	10H
	LD	HL,212			; ny=212
	JR	Z,J08BC
	LD	HL,256			; ny=256
J08BC:	CALL	C2C28			; setup nx,ny
	LD	A,0C0H
	CALL	C2C47			; execute vdp command highspeed move vdp to vram
	CALL	C2BE4			; wait until VDP command is done
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET	

;	 Subroutine calculate colorbyte
;	    Inputs  A=color
;	    Outputs A=colorbyte

C08CC:	LD	B,A
	CALL	C2A0F			; check if screen 10
	JR	NZ,J08DA		; nope,
	LD	A,B
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A			; color in paletselector
	OR	08H			; and flag use palet
	RET	

J08DA:	LD	A,(SCRMOD)
	CP	8
	LD	A,B
	RET	Z			; screen 8,11 and 12 have 8 bits per pixel, quit
	RLCA	
	RLCA	
	RLCA	
	RLCA	
	OR	B
	LD	B,A			; screen 5 and 7 have 2 pixels per byte, setup both pixels
	LD	A,(SCRMOD)
	CP	6
	LD	A,B
	RET	NZ
	RRCA	
	RRCA	
	OR	B			; screen 6 has 4 pixels per byte, setup all 4 pixels
	RET	

;	 Subroutine S.CLRTXT (clear screen for textscreenmodes)
;	    Inputs  ________________________
;	    Outputs ________________________

C08F2:	LD	A,(SCRMOD)
	AND	A
	LD	HL,(NAMBAS)
	JR	NZ,J090C
	LD	A,(LINLEN)
	CP	40+1
	JR	NC,J0907
	LD	BC,40*24
	JR	J090F

J0907:	LD	BC,80*24
	JR	J090F

J090C:	LD	BC,32*24
J090F:	LD	A," "
	CALL	C0A05			; clear patternname table
	CALL	C094F			; cursor home
	LD	HL,LINTTB
	LD	B,24
J091C:	LD	(HL),B
	INC	HL
	DJNZ	J091C			; clear LINTTB
	JP	J2781			; display functionkeys when enabled

;	 Subroutine clear screen for screenmode 2 and 4
;	    Inputs  ________________________
;	    Outputs ________________________

C0923:	CALL	C0A2A			; setup bordercolor
	LD	BC,1800H
	PUSH	BC
	LD	HL,(GRPCOL)
	LD	A,(BAKCLR)
	CALL	C0A05			; clear color table
	LD	HL,(GRPCGP)
	POP	BC
	XOR	A			; clear pattern table
J0938:	JP	C0A05

;	 Subroutine clear screen for screenmode 3
;	    Inputs  ________________________
;	    Outputs ________________________

C093B:	CALL	C0A2A			; setup bordercolor
	LD	HL,BAKCLR
	LD	A,(HL)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	(HL)			; 2 pixels per byte
	LD	HL,(MLTCGP)
	LD	BC,0600H
	JR	J0938

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C094F:	LD	HL,0101H
	LD	(CSRY),HL
	RET	

; unused code ??

?.0956:	CALL	C096A

;	 Subroutine S.WRTVRM
;	    Inputs  HL=VRAM base adres
;	    Outputs ________________________

C0959:	PUSH	AF
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	POP	AF
	OUT	(98H),A
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C0961:	CALL	C096A

;	 Subroutine S.RDVRM
;	    Inputs  HL=VRAM base adres
;	    Outputs ________________________

C0964:	CALL	C097F			; setup vdp adresregister for active screenpage (read)
	IN	A,(98H)
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C096A:	PUSH	AF
	LD	A,H
	AND	3FH
	LD	H,A
	POP	AF
	RET	

;	 Subroutine setup vdp adresregister for active screenpage (write)
;	    Inputs  ________________________
;	    Outputs ________________________

C0971:	PUSH	BC
	PUSH	DE
	PUSH	HL
	EX	DE,HL
	CALL	C09A2			; convert page base adres to VRAM adres
	LD	A,H
	AND	3FH
	OR	40H
	JR	J0989

;	 Subroutine setup vdp adresregister for active screenpage (read)
;	    Inputs  ________________________
;	    Outputs ________________________

C097F:	PUSH	BC
	PUSH	DE
	PUSH	HL
	EX	DE,HL
	CALL	C09A2			; convert page base adres to VRAM adres
	LD	A,H
	AND	3FH
J0989:	PUSH	AF
	LD	A,H
	AND	0C0H
	OR	D
	RLCA	
	RLCA	
	DI	
	OUT	(99H),A
	LD	A,8EH
	OUT	(99H),A
	LD	A,L
	OUT	(99H),A
	POP	AF
	OUT	(99H),A
	EI	
	POP	HL
	POP	DE
	POP	BC
	RET	

;	 Subroutine convert page base adres to VRAM adres
;	    Inputs  DE=base adres
;	    Outputs DHL=VRAM adres

C09A2:	LD	A,(SCRMOD)
	LD	C,A
	LD	A,(ACPAGE)
	AND	A			; active screenpage <> 0 ?
	LD	HL,I09B3		; jumptable
	JP	NZ,J0A57		; yep, jump to screenspecific routine
	EX	DE,HL
	LD	D,A			; VRAM adres=base adres
	RET	

I09B3:	DEFW	J09C5			; screenmode 0, special action required
	DEFW	J09D3			; screenmode 1, pageoffset 4000H
	DEFW	J09D3			; screenmode 2, pageoffset 4000H
	DEFW	J09D3			; screenmode 3, pageoffset 4000H
	DEFW	J09D3			; screenmode 4, pageoffset 4000H
	DEFW	J09D2			; screenmode 5, pageoffset 8000H
	DEFW	J09D2			; screenmode 6, pageoffset 8000H
	DEFW	J09D1			; screenmode 7, pageoffset 10000H
	DEFW	J09D1			; screenmode 8, pageoffset 10000H

J09C5:	LD	A,(LINLEN)
	CP	40+1
	LD	A,(ACPAGE)
	JR	C,J09D5			; text40, pageoffset 1000H
	JR	J09D4			; text80, pageoffset 2000H

J09D1:	ADD	A,A
J09D2:	ADD	A,A
J09D3:	ADD	A,A
J09D4:	ADD	A,A
J09D5:	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	H,A
	LD	A,0
	LD	L,A
	ADC	A,A
	ADD	HL,DE
	LD	D,A
	RET	

;	 Subroutine S.CHGCLR
;	    Inputs  ________________________
;	    Outputs ________________________

	IF	OPTM EQ 0

C09E1:	CALL	C066A			; check if new style MSX2 screen
	JP	NC,J0A25		; yep,
	CALL	C0A32			; FORCLR and BAKCLR to 4 bit colorvalues
	DEC	A
	JP	M,J0A18			; screen 0,
	PUSH	AF
	CALL	C0A2A			; setup bordercolor
	POP	AF
	RET	NZ			; screenmode 2,3 or 4, quit
	LD	HL,BAKCLR
	LD	A,(FORCLR)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	(HL)
	LD	HL,(T32COL)
	LD	BC,0020H		; fill colortable of screenmode 1

;	 Subroutine fill VRAM
;	    Inputs  HL=VRAM base adres, BC=size, A=fillbyte
;	    Outputs ________________________

C0A05:	PUSH	AF
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	LD	A,C
	OR	A
	JR	Z,J0A0E
	INC	B			; size is not dividable by 256, need extra loop
J0A0E:	POP	AF
J0A0F:	OUT	(98H),A
	DEC	C
	JP	NZ,J0A0F
	DJNZ	J0A0F
	RET	

J0A18:	LD	HL,BAKCLR
	LD	A,(FORCLR)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A			; forground color in b7-b4
	OR	(HL)			; background color in b3-b0 (also bordercolor)
	JR	J0A2D			; write vdp register 7

J0A25:	CP	08H
	CALL	NZ,C0A32		; not screenmode 8, FORCLR and BAKCLR to 4 bit colorvalues

;	 Subroutine setup bordercolor
;	    Inputs  ________________________
;	    Outputs ________________________

C0A2A:	LD	A,(BDRCLR)
J0A2D:	LD	C,7
	JP	C0684			; write vdp register 7

;	 Subroutine update FORCLR and BAKCLR to 4 bit colorvalues
;	    Inputs  ________________________
;	    Outputs ________________________

C0A32:	PUSH	AF
	LD	A,(BAKCLR)
	AND	0FH
	LD	(BAKCLR),A
	LD	A,(FORCLR)
	AND	0FH
	LD	(FORCLR),A
	POP	AF
	RET	

	ELSE

C09E1:	LD	A,(SCRMOD)
	OR	A
	JR	Z,J0A18			; screen 0, special
	CP	8			; screen 8,10,11 or 12 ?
	CALL	NZ,C0A32		; nope, FORCLR and BAKCLR to 4 bit colorvalues
	CALL	C0A2A			; setup bordercolor
	LD	A,(SCRMOD)
	DEC	A			; screen 1 ?
	RET	NZ			; nope, quit
	LD	HL,BAKCLR
	LD	A,(FORCLR)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	(HL)
	LD	HL,(T32COL)
	LD	BC,0020H		; fill colortable of screenmode 1

;	 Subroutine fill VRAM
;	    Inputs  HL=VRAM adres, BC=size, A=fillbyte
;	    Outputs ________________________

C0A05:	PUSH	AF
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	LD	A,C
	OR	A
	JR	Z,J0A0E
	INC	B			; size is not dividable by 256, need extra loop
J0A0E:	POP	AF
J0A0F:	OUT	(98H),A
	DEC	C
	JP	NZ,J0A0F
	DJNZ	J0A0F
	RET

J0A18:	LD	HL,BAKCLR
	LD	A,(FORCLR)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A			; forground color in b7-b4
	OR	(HL)			; background color in b3-b0 (also bordercolor)
	JR	J0A2D			; write vdp register 7

;	 Subroutine setup bordercolor
;	    Inputs  ________________________
;	    Outputs ________________________

C0A2A:	LD	A,(BDRCLR)
J0A2D:	LD	C,7
	JP	C0684			; write vdp register 7

;	 Subroutine update FORCLR and BAKCLR to 4 bit colorvalues
;	    Inputs  ________________________
;	    Outputs ________________________

C0A32:	LD	A,(BAKCLR)
	AND	0FH
	LD	(BAKCLR),A
	LD	A,(FORCLR)
	AND	0FH
	LD	(FORCLR),A
	RET	

	ENDIF




;	 Subroutine CLS statement
;	    Inputs  ________________________
;	    Outputs ________________________
; 	    Remark  UNUSED CODE

	IF	OPTM EQ 0

?.0A45:	RET	NZ			; not end of statement, quit. Basic interpreter generates syntax error
	PUSH	HL
	CALL	C0877			; S.CLS
	POP	HL
	RET

	ENDIF

;	 Subroutine S.CHGMDP (setup screenmode with paletteinit)
;	    Inputs  ________________________
;	    Outputs ________________________

C0A4C:	LD	HL,C1046
	PUSH	HL			; S.INIPLT (initialize palette) after CHGMOD

;	 Subroutine S.CHGMOD
;	    Inputs  ________________________
;	    Outputs ________________________

J0A50:	CP	8+1			; screenmode 0-8 ?
	RET	NC			; nope, illegal screenmode, quit
	LD	HL,I0A60

;	 Subroutine call screenmode specific routine
;	    Inputs  HL=jumptable
;	    Outputs A=screenmode

C0A56:	LD	C,A
J0A57:	LD	B,0
	ADD	HL,BC
	ADD	HL,BC
	LD	C,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,C
	JP	(HL)

I0A60:	DEFW	C0A72			; screenmode 0
	DEFW	C0AA7			; screenmode 1
	DEFW	C0AD5			; screenmode 2
	DEFW	C0B25			; screenmode 3
	DEFW	C0AFE
	DEFW	C0B63
	DEFW	C0B70
	DEFW	C0B7D
	DEFW	C0B8A

;	 Subroutine S.INITXT (screenmode 0)
;	    Inputs  ________________________
;	    Outputs ________________________

C0A72:	XOR	A
	LD	(OLDSCR),A
	CALL	C0BAF			; disable display, scroll and MSX2+ colormodes
	LD	A,(LINL40)
	LD	(LINLEN),A
	LD	HL,0800H
	LD	(TXTCOL),HL
	LD	HL,(TXTNAM)
	LD	(NAMBAS),HL
	LD	HL,(TXTCGP)
	CP	40+1
	JR	C,J0A95
	LD	HL,1000H
J0A95:	LD	(CGPBAS),HL
	CALL	C0BE3			; S.SETTXT
J0A9B:	CALL	C09E1			; S.CHGCLR
	CALL	C08F2			; clear screen for textscreenmodes
	CALL	C0803			; initialize patterngenerator with msx characterset
	JP	J0670			; enable vdp displayoutput

;	 Subroutine S.INIT32 (screenmode 1)
;	    Inputs  ________________________
;	    Outputs ________________________

C0AA7:	LD	A,1
	LD	(OLDSCR),A
	CALL	C0BAF			; disable display, scroll and MSX2+ colormodes
	LD	A,(LINL32)
	LD	(LINLEN),A
	LD	HL,(T32NAM)
	LD	(NAMBAS),HL
	LD	HL,(T32CGP)
	LD	(CGPBAS),HL
	LD	HL,(T32PAT)
	LD	(PATBAS),HL
	LD	HL,(T32ATR)
	LD	(ATRBAS),HL
	CALL	C0C3D			; S.SETT32
	CALL	C078D			; initialize spriteplanes and spritecolortable
	JR	J0A9B

;	 Subroutine S.INIGRP (screenmode 2)
;	    Inputs  ________________________
;	    Outputs ________________________

C0AD5:	LD	A,2
	CALL	C0BAF			; disable display, scroll and MSX2+ colormodes
	LD	HL,(GRPATR)
	CALL	C0B0F			; setup ATRBAS,PATBAS,CGPBAS and NAMBAS
	PUSH	HL
	CALL	C0C73			; S.SETGRP
J0AE4:	POP	HL
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	XOR	A
	LD	B,3
J0AEB:	OUT	(98H),A
	INC	A
	JR	NZ,J0AEB
	DJNZ	J0AEB			; initialize patternnametable
	CALL	C0923			; clear screen for screenmode 2 and 4
J0AF5:	CALL	C09E1			; S.CHGCLR
	CALL	C078D			; initialize spriteplanes and spritecolortable
	JP	J0670			; enable vdp displayoutput

;	 Subroutine screenmode 4
;	    Inputs  ________________________
;	    Outputs ________________________

C0AFE:	LD	A,4
	CALL	C0BAF			; disable display, scroll and MSX2+ colormodes
	LD	HL,1E00H
	CALL	C0B0F			; setup ATRBAS,PATBAS,CGPBAS and NAMBAS
	PUSH	HL
	CALL	C0C7A			; setup vdp for screenmode 4
	JR	J0AE4

;	 Subroutine setup ATRBAS,PATBAS,CGPBAS and NAMBAS
;	    Inputs  ________________________
;	    Outputs ________________________

C0B0F:	LD	(ATRBAS),HL
	LD	HL,(GRPPAT)
	LD	(PATBAS),HL
	LD	HL,(GRPCGP)
	LD	(CGPBAS),HL
	LD	HL,(GRPNAM)
	LD	(NAMBAS),HL
	RET	

;	 Subroutine S.INIMLT (screenmode 3)
;	    Inputs  ________________________
;	    Outputs ________________________

C0B25:	LD	A,3
	CALL	C0BAF			; disable display, scroll and MSX2+ colormodes
	LD	HL,(MLTPAT)
	LD	(PATBAS),HL
	LD	HL,(MLTATR)
	LD	(ATRBAS),HL
	LD	HL,(MLTCGP)
	LD	(CGPBAS),HL
	LD	HL,(MLTNAM)
	LD	(NAMBAS),HL		; setup PATBAS,ATRBAS,CGPBAS and NAMBAS
	PUSH	HL
	CALL	C0CC3			; S.SETMLT
	POP	HL
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	LD	DE,0*256+6
J0B4D:	LD	C,4
J0B4F:	LD	A,D
	LD	B,32
J0B52:	OUT	(98H),A
	INC	A
	DJNZ	J0B52
	DEC	C
	JR	NZ,J0B4F
	LD	D,A
	DEC	E
	JR	NZ,J0B4D		; initialize patternnametable
	CALL	C093B			; clear screen for screenmode 3
	JR	J0AF5

;	 Subroutine screenmode 5
;	    Inputs  ________________________
;	    Outputs ________________________

C0B63:	LD	A,5
	LD	DE,07876H		; sprite patterngenerator at 7800H, sprite attributetable at 7600H
	CALL	C0BA1			; setup PATBAS,ATRBAS and NAMBAS, disable display, scroll and MSX2+ colormodes
	CALL	C0CF7			; setup vdp for screenmode 5
	JR	J0B95

;	 Subroutine screenmode 6
;	    Inputs  ________________________
;	    Outputs ________________________

C0B70:	LD	A,6
	LD	DE,07876H		; sprite patterngenerator at 7800H, sprite attributetable at 7600H
	CALL	C0BA1			; setup PATBAS,ATRBAS and NAMBAS, disable display, scroll and MSX2+ colormodes
	CALL	C0D21			; setup vdp for screenmode 6
	JR	J0B95

;	 Subroutine screenmode 7
;	    Inputs  ________________________
;	    Outputs ________________________

C0B7D:	LD	A,7
	LD	DE,0F0FAH		; sprite patterngenerator at F000H, sprite attributetable at FA00H
	CALL	C0BA1			; setup PATBAS,ATRBAS and NAMBAS, disable display, scroll and MSX2+ colormodes
	CALL	C0D38			; setup vdp for screenmode 7
	JR	J0B95

;	 Subroutine screenmode 8
;	    Inputs  ________________________
;	    Outputs ________________________

C0B8A:	LD	A,8
	LD	DE,0F0FAH		; sprite patterngenerator at F000H, sprite attributetable at FA00H
	CALL	C0BA1			; setup PATBAS,ATRBAS and NAMBAS, disable display, scroll and MSX2+ colormodes
	CALL	C0D68			; setup vdp for screenmode 8

J0B95:	CALL	C09E1			; S.CHGCLR
	CALL	C088A			; new style MSX2 screenmode cls
	CALL	C078D			; initialize spriteplanes and spritecolortable
	JP	J0670			; enable vdp displayoutput

;	 Subroutine setup PATBAS,ATRBAS and NAMBAS, disable display, scroll and MSX2+ colormodes
;	    Inputs  E = highbyte ATRBAS, D = highbyte PATBAS
;	    Outputs ________________________

C0BA1:	LD	L,0
	LD	H,D
	LD	(PATBAS),HL
	LD	H,E
	LD	(ATRBAS),HL
	LD	H,L
	LD	(NAMBAS),HL		; NAMBAS = 0

;	 Subroutine disable display, scroll and MSX2+ colormodes
;	    Inputs  ________________________
;	    Outputs ________________________

C0BAF:	LD	(SCRMOD),A		; set current screenmode
	XOR	A
	LD	(DPPAGE),A		; display screenpage 0
	LD	(ACPAGE),A		; active screenpage 0
	LD	HL,256
	LD	(ASPCT1),HL
	LD	(ASPCT2),HL		; 1:1 circle aspectratio
	CALL	C2BE4			; wait until VDP command is done
	CALL	C067A			; disable vdp display output
	LD	B,0
	LD	C,17H
	CALL	C0685			; vertikal scroll 0
	LD	C,1AH
	CALL	C0685
	LD	C,1BH
	CALL	C0685			; horizontal scroll 0
	LD	A,(RG25SA)
	AND	0E4H			; YAE=0,YJK=0,MSK=0,SP2=0
	LD	C,25
	JP	C0684			; write vdp register 25

;	 Subroutine S.SETTXT
;	    Inputs  ________________________
;	    Outputs ________________________

C0BE3:	CALL	C0DCE			; set VDP in 192 lines mode
	LD	A,(LINLEN)
	CP	40+1
	LD	B,00H			; M5=0,M4=0,M3=0 for TEXT40 mode
	JR	C,J0BF1
	LD	B,04H			; M5=0,M4=1,M3=0 for TEXT80 mode
J0BF1:	LD	C,10H			; M2=1, M1=0 for both modes
	CALL	C0DDE			; set VDP mode bits
	LD	A,(LINLEN)
	CP	40+1
	LD	A,(DPPAGE)
	JR	NC,J0C13
	ADD	A,A
	LD	HL,(TXTCGP)
	LD	B,00H
	CALL	C0D87			; setup VDP patterngenerator adres
	ADD	A,A
	LD	HL,(TXTNAM)
	CALL	C0D7B			; setup VDP patternnametable adres
	JP	J0733			; setup VDP registers and digitizehardware

J0C13:	LD	A,(DPPAGE)
	PUSH	AF
	ADD	A,A
	ADD	A,A
	LD	B,00H
	LD	HL,(CGPBAS)
	CALL	C0D87			; setup VDP patterngenerator adres
	ADD	A,A
	LD	B,03H
	LD	HL,(TXTNAM)
	CALL	C0D7B			; setup VDP patternnametable adres
	POP	AF
	LD	HL,(TXTCOL)
	LD	E,00H
	SRL	A
	RR	E
	LD	D,A
	LD	B,07H
	CALL	C0D95			; setup VDP colortable adres
	JP	J0733			; setup VDP registers and digitizehardware

;	 Subroutine S.SETT32
;	    Inputs  ________________________
;	    Outputs ________________________

C0C3D:	CALL	C0DCE			; set VDP in 192 lines mode
	LD	BC,0000H		; M5=0,M4=0,M3=0,M2=0,M1=0
	CALL	C0DDE			; set VDP mode bits
	LD	A,(DPPAGE)
	LD	C,A
	LD	B,00H
	LD	HL,(T32CGP)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	CALL	C0D87			; setup VDP patterngenerator adres
	LD	HL,(T32PAT)
	CALL	C0DC1			; setup VDP spritepattern adres
	LD	HL,(T32NAM)
	ADD	A,A
	CALL	C0D7B			; setup VDP patternnametable adres
	LD	E,B
	LD	D,C
	LD	HL,(T32COL)
	CALL	C0D95			; setup VDP colortable adres
	SRL	D
	RR	E
	LD	HL,(T32ATR)
	JR	J0CBD

;	 Subroutine S.SETGRP
;	    Inputs  ________________________
;	    Outputs ________________________

C0C73:	XOR	A
	PUSH	AF
	LD	BC,0200H		; M5=0,M4=0,M3=1,M2=0,M1=0
	JR	J0C81

;	 Subroutine setup vdp for screenmode 4
;	    Inputs  ________________________
;	    Outputs ________________________

C0C7A:	LD	A,3
	OR	A
	PUSH	AF
	LD	BC,0400H		; M5=0,M4=1,M3=0,M2=0,M1=0
J0C81:	CALL	C0DDE			; set VDP mode bits
	CALL	C0DCE			; set VDP in 192 lines mode
	LD	A,(DPPAGE)
	LD	C,A
	LD	B,03H	; 3 
	LD	HL,(GRPCGP)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	CALL	C0D87			; setup VDP patterngenerator adres
	LD	HL,(GRPPAT)
	CALL	C0DC1			; setup VDP spritepattern adres
	LD	HL,(GRPNAM)
	ADD	A,A
	LD	B,00H
	CALL	C0D7B			; setup VDP patternnametable adres
	LD	E,B
	LD	D,C
	LD	B,7FH
	LD	HL,(GRPCOL)
	CALL	C0D95			; setup VDP colortable adres
	SRL	D
	RR	E
	POP	AF
	LD	B,A
	LD	HL,(GRPATR)
	JR	Z,J0CBD			; screenmode 2,
	LD	HL,(ATRBAS)
J0CBD:	CALL	C0DAC			; setup VDP spriteattribute adres
	JP	J0733			; setup VDP registers and digitizehardware

;	 Subroutine S.SETMLT
;	    Inputs  ________________________
;	    Outputs ________________________

C0CC3:	CALL	C0DCE			; set VDP in 192 lines mode
	LD	BC,0008H		; M5=0,M4=0,M3=0,M2=0,M1=1
	CALL	C0DDE			; set VDP mode bits
	LD	A,(DPPAGE)
	LD	C,A
	LD	B,00H
	LD	HL,(MLTCGP)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	CALL	C0D87			; setup VDP patterngenerator adres
	LD	HL,(MLTPAT)
	CALL	C0DC1			; setup VDP spritepattern adres
	LD	HL,(MLTNAM)
	ADD	A,A
	LD	B,00H
	CALL	C0D7B			; setup VDP patternnametable adres
	LD	E,B
	LD	D,C
	SRL	D
	RR	E
	LD	B,00H
	LD	HL,(MLTATR)
	JR	J0CBD

;	 Subroutine setup vdp for screenmode 5
;	    Inputs  ________________________
;	    Outputs ________________________

C0CF7:	CALL	C0DD5			; set VDP in 212 lines mode
	LD	BC,0600H		; M5=0,M4=1,M3=1,M2=0,M1=0
	CALL	C0DDE			; set VDP mode bits
J0D00:	LD	A,(DPPAGE)
	LD	C,A
	LD	B,00H
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	CALL	C0DBE			; setup VDP spritepattern adres with PATBAS
	LD	HL,(NAMBAS)
	ADD	A,A
	LD	B,1FH
	CALL	C0D7B			; setup VDP patternnametable adres
	LD	D,C
J0D17:	LD	E,00H
	LD	B,03H
	CALL	C0DA9			; setup VDP spriteattribute adres with ATRBAS
	JP	J0733			; setup VDP registers and digitizehardware

;	 Subroutine setup vdp for screenmode 6
;	    Inputs  ________________________
;	    Outputs ________________________

C0D21:	CALL	C0DD5			; set VDP in 212 lines mode
	LD	BC,0800H		; M5=1,M4=0,M3=0,M2=0,M1=0
	CALL	C0DDE			; set VDP mode bits
	LD	HL,512
	LD	(ASPCT1),HL
	LD	HL,128
	LD	(ASPCT2),HL		; circle aspectratio 2:1
	JR	J0D00

;	 Subroutine setup vdp for screenmode 7
;	    Inputs  ________________________
;	    Outputs ________________________

C0D38:	CALL	C0DD5			; set VDP in 212 lines mode
	LD	BC,0A00H		; M5=1,M4=0,M3=1,M2=0,M1=0
	CALL	C0DDE			; set VDP mode bits
	LD	HL,512
	LD	(ASPCT1),HL
	LD	HL,128
	LD	(ASPCT2),HL		; circle aspectratio 2:1
J0D4D:	LD	A,(DPPAGE)
	LD	C,A
	LD	B,00H
	RRCA	
	RRCA	
	RRCA	
	AND	0E0H
	CALL	C0DBE			; setup VDP spritepattern adres with PATBAS
	LD	HL,(NAMBAS)
	LD	B,1FH
	CALL	C0D7B			; setup VDP patternnametable adres
	LD	A,C
	ADD	A,A
	LD	D,A
	JR	J0D17

;	 Subroutine setup vdp for screenmode 8
;	    Inputs  ________________________
;	    Outputs ________________________

C0D68:	CALL	C0DD5			; set VDP in 212 lines mode
	LD	BC,0E00H		; M5=1,M4=1,M3=1,M2=0,M1=0
	CALL	C0DDE			; set VDP mode bits
	LD	A,(RG2SAV)
	SRL	A
	LD	(RG2SAV),A
	JR	J0D4D

;	 Subroutine setup vdp patternnametable adres
;	    Inputs  ________________________
;	    Outputs ________________________

C0D7B:	LD	L,A
	SRL	H
	SRL	H
	ADD	A,H
	OR	B
	LD	(RG2SAV),A
	LD	A,L
	RET	

;	 Subroutine setup vdp patterngenerator adres
;	    Inputs  ________________________
;	    Outputs ________________________

C0D87:	LD	L,A
	SRL	H
	SRL	H
	SRL	H
	ADD	A,H
	OR	B
	LD	(RG4SAV),A
	LD	A,L
	RET	

;	 Subroutine setup vdp colortable adres
;	    Inputs  ________________________
;	    Outputs ________________________

C0D95:	PUSH	AF
	XOR	A
	ADD	HL,HL
	ADC	A,A
	ADD	HL,HL
	ADC	A,A
	LD	L,H
	LD	H,A
	ADD	HL,DE
	LD	A,L
	OR	B
	LD	(RG3SAV),A
	LD	A,H
	LD	(RG10SA),A
	POP	AF
	RET	

;	 Subroutine setup vdp spriteattribute adres with ATRBAS
;	    Inputs  ________________________
;	    Outputs ________________________

C0DA9:	LD	HL,(ATRBAS)

;	 Subroutine setup vdp spriteattribute adres
;	    Inputs  ________________________
;	    Outputs ________________________

C0DAC:	PUSH	AF
	XOR	A
	ADD	HL,HL
	ADC	A,A
	LD	L,H
	LD	H,A
	ADD	HL,DE
	LD	A,L
	OR	B
	LD	(RG5SAV),A
	LD	A,H
	LD	(RG11SA),A
	POP	AF
	RET	

;	 Subroutine setup vdp spritepattern adres with PATBAS
;	    Inputs  ________________________
;	    Outputs ________________________

C0DBE:	LD	HL,(PATBAS)

;	 Subroutine setup vdp spritepattern adres
;	    Inputs  A = ?, HL = adres
;	    Outputs ________________________

C0DC1:	LD	L,A
	SRL	H
	SRL	H
	SRL	H
	ADD	A,H
	LD	(RG6SAV),A
	LD	A,L
	RET	

;	 Subroutine set 192 lines
;	    Inputs  ________________________
;	    Outputs ________________________

C0DCE:	LD	A,(RG9SAV)
	AND	7FH
	JR	J0DDA

;	 Subroutine set 212 lines
;	    Inputs  ________________________
;	    Outputs ________________________

C0DD5:	LD	A,(RG9SAV)
	OR	80H
J0DDA:	LD	(RG9SAV),A
	RET	

;	 Subroutine set VDP mode bits
;	    Inputs  ________________________
;	    Outputs ________________________

C0DDE:	LD	A,(RG0SAV)
	AND	0F1H
	OR	B
	LD	(RG0SAV),A
	LD	A,(RG1SAV)
	AND	0E7H
	OR	C
	LD	(RG1SAV),A
	RET	

;	 Subroutine S.DSPFNK
;	    Inputs  ________________________
;	    Outputs ________________________

J0DF1:	LD	A,0FFH
	CALL	C065B			; set functionkey display on
	RET	NC			; not in textmode, quit
	PUSH	HL
	LD	A,(CSRY)
	LD	HL,CRTCNT
	CP	(HL)
	LD	A,0AH
	JR	NZ,J0E04
	RST	S.OUTDO			; cursor at the last line, do linefeed to create empty line for functionkeys
J0E04:	LD	A,(NEWKEY+6)
	RRCA	
	LD	HL,FNKSTR+0*16
	LD	A,1
	JR	C,J0E13
	LD	HL,FNKSTR+5*16
	XOR	A
J0E13:	LD	(FNKSWI),A
	CALL	C0E89			; fill LINWRK with spaces
	LD	C,5			; display 5 functionkeys
	LD	A,(LINLEN)
	CP	40+1
	JR	NC,J0E41		; 80 col mode,
	CALL	C0E97			; calculate space for functionkey to display
	JR	C,J0E39			; not enough space for display, display nothing
J0E27:	PUSH	BC
	LD	C,0
J0E2A:	CALL	C0EA5			; put functionkey char
	DJNZ	J0E2A
	LD	A,16
	SUB	C
	LD	C,A
	ADD	HL,BC			; to next functionkey def
	INC	DE			; space between key strings
	POP	BC
	DEC	C
	JR	NZ,J0E27		; next key
J0E39:	LD	HL,(CRTCNT)
	CALL	C0F7E			; copy LINWRK to line
	POP	HL
	RET	
;

J0E41:	PUSH	AF
	CALL	C0E97			; calculate space for functionkey to display
	POP	AF
	SUB	40
J0E48:	PUSH	BC
	PUSH	HL
	LD	C,0
J0E4C:	PUSH	AF
	CALL	C0EA5			; put functionkey char
	POP	AF
	DEC	A
	CALL	Z,C0E79			; first 40 chars done, copy LINWRK to first part of line
	BIT	4,C
	JR	NZ,J0E5B		; functionkey display complete
	DJNZ	J0E4C
J0E5B:	DEC	B
	JP	P,J0E61
	LD	B,0
J0E61:	INC	B
J0E62:	INC	DE
	DEC	A
	CALL	Z,C0E79			; first 40 chars done, copy LINWRK to frist part of line
	DJNZ	J0E62			; do space between
	POP	HL
	LD	C,16
	ADD	HL,BC			; to next functionkey def
	POP	BC
	DEC	C
	JR	NZ,J0E48		; next key
	LD	HL,(CRTCNT)
	CALL	C0F99			; copy LINWRK to second part of line
	POP	HL
	RET	
;

;
;	 Subroutine copy LINWRK to first part of line and clear LINWRK
;	    Inputs  ________________________
;	    Outputs ________________________
;
C0E79:	PUSH	BC
	PUSH	HL
	LD	HL,(CRTCNT)
	CALL	C0F7F			; copy LINWRK to first part of line
	CALL	C0E89			; fill LINWRK with spaces
	POP	HL
	POP	BC
	LD	A,0FFH
	RET	

;	 Subroutine fill LINWRK with spaces
;	    Inputs  ________________________
;	    Outputs ________________________

C0E89:	LD	DE,LINWRK
	PUSH	DE
	LD	B,40
	LD	A," "
J0E91:	LD	(DE),A
	INC	DE
	DJNZ	J0E91
	POP	DE
	RET	

;	 Subroutine calculate space for functionkey to display
;	    Inputs  A=screenwidth
;	    Outputs ________________________

C0E97:	SUB	04H
	RET	C
	LD	B,0FFH
J0E9C:	INC	B
	SUB	05H
	JR	NC,J0E9C
	LD	A,B
	SUB	01H
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C0EA5:	LD	A,(HL)
	INC	HL
	INC	C
	CALL	C135C			; convert character
	JR	NC,C0EA5		; graphic header, next
	JR	NZ,J0EB3		; graphic character
	CP	20H
	JR	C,J0EB4			; controlcode, ignore
J0EB3:	LD	(DE),A
J0EB4:	INC	DE
	RET	

;	 Subroutine S.DELLNO
;	    Inputs  L = linenumber
;	    Outputs ________________________

J0EB6:	CALL	C0FA7			; get last linenumber
	SUB	L
	RET	C			; linenumber out of range, quit
	JP	Z,J0F50			; last line,
	PUSH	HL
	PUSH	AF
	LD	C,A
	LD	B,0
	CALL	C0FB1			; get LINTTB entry
	LD	L,E
	LD	H,D
	INC	HL
	LDIR				; 'scroll' LINTTB up
	LD	HL,FSTPOS
	DEC	(HL)
	POP	AF
	POP	HL
	PUSH	AF
	LD	A,(LINLEN)
	CP	40+1
	JR	NC,J0EEA		; TEXT80 mode, handle special
	POP	AF
J0EDA:	PUSH	AF
	INC	L
	CALL	C0F55			; copy next line to LINWRK
	DEC	L
	CALL	C0F7E			; copy LINWRK to line
	INC	L			; next line
	POP	AF
	DEC	A
	JR	NZ,J0EDA		; do this for all lines
	JR	J0F01
;

J0EEA:	POP	AF
J0EEB:	PUSH	AF
	INC	L
	CALL	C0F56			; copy first part of line to LINWRK
	DEC	L
	CALL	C0F7F			; copy LINWRK to first part of line
	INC	L
	CALL	C0F6F			; copy second part of line to LINWRK
	DEC	L
	CALL	C0F99			; copy LINWRK to second part of line
	INC	L
	POP	AF
	DEC	A
	JR	NZ,J0EEB
;
J0F01:	JP	J0F50

;	 Subroutine S.INSLNO
;	    Inputs  ________________________
;	    Outputs ________________________

J0F04:	CALL	C0FA7			; get last linenumber
	LD	H,A
	SUB	L
	RET	C
	JP	Z,J0F50
	LD	L,H
	PUSH	HL
	PUSH	AF
	LD	C,A
	LD	B,00H
	CALL	C0FB1			; get LINTTB entry
	LD	L,E
	LD	H,D
	PUSH	HL
	DEC	HL
	LDDR	
	POP	HL
	LD	(HL),H
	POP	AF
	POP	HL
	PUSH	AF
	LD	A,(LINLEN)
	CP	40+1
	JR	NC,J0F39

	POP	AF
J0F29:	PUSH	AF
	DEC	L
	CALL	C0F55			; copy line to LINWRK
	INC	L
	CALL	C0F7E			; copy LINWRK to line
	DEC	L
	POP	AF
	DEC	A
	JR	NZ,J0F29
	JR	J0F50			; clear line

J0F39:	POP	AF
J0F3A:	PUSH	AF
	DEC	L
	CALL	C0F56			; copy first part of line to LINWRK
	INC	L
	CALL	C0F7F			; copy LINWRK to frist part of line
	DEC	L
	CALL	C0F6F			; copy second part of line to LINWRK
	INC	L
	CALL	C0F99			; copy LINWRK to second part of line
	DEC	L
	POP	AF
	DEC	A
	JR	NZ,J0F3A
J0F50:	LD	H,1
	JP	J27A6			; clear line

;	 Subroutine copy line to LINWRK
;	    Inputs  ________________________
;	    Outputs ________________________

C0F55:	DEFB	0F6H			; OR xx, skip next instruction
C0F56:	XOR	A
	PUSH	HL
	PUSH	AF
	LD	H,1
	CALL	C0FDC			; convert screenlocation to VRAM adres
	POP	AF
	LD	A,(LINLEN)
	JR	NZ,J0F66
	SUB	40
J0F66:	LD	B,A
J0F67:	LD	DE,LINWRK
	CALL	C0FC9			; copy vram to ram
	POP	HL
	RET	

;	 Subroutine copy second part line to LINWRK
;	    Inputs  
;	    Outputs ________________________

C0F6F:	PUSH	HL
	LD	A,(LINLEN)
	SUB	40
	INC	A
	LD	H,A
	CALL	C0FDC			; convert screenlocation to VRAM adres
	LD	B,40
	JR	J0F67

;	 Subroutine copy LINWRK to line
;	    Inputs  ________________________
;	    Outputs ________________________

C0F7E:	DEFB	0F6H			; OR xx, skip next instruction

;	 Subroutine copy LINWRK to first part of line
;	    Inputs  ________________________
;	    Outputs ________________________

C0F7F:	XOR	A
	PUSH	HL
	PUSH	AF
	LD	H,1
	CALL	C0FDC			; convert screenlocation to VRAM adres
	POP	AF
	LD	A,(LINLEN)
	JR	NZ,J0F8F
	SUB	40
J0F8F:	LD	B,A
J0F90:	EX	DE,HL
	LD	HL,LINWRK
	CALL	C0FD2			; copy ram to vram
	POP	HL
	RET	

;	 Subroutine copy LINWRK to second part of line
;	    Inputs  ________________________
;	    Outputs ________________________

C0F99:	PUSH	HL
	LD	A,(LINLEN)
	SUB	40-1
	LD	H,A
	CALL	C0FDC			; convert screenlocation to VRAM adres
	LD	B,40
	JR	J0F90

;	 Subroutine get last linenumber
;	    Inputs  ________________________
;	    Outputs ________________________

C0FA7:	LD	A,(CNSDFG)
	PUSH	HL
	LD	HL,CRTCNT
	ADD	A,(HL)
	POP	HL
	RET	

;	 Subroutine get LINTTB entry
;	    Inputs  L=linenumber (1 based)
;	    Outputs ________________________

C0FB1:	PUSH	HL
	LD	DE,LINTTB-1
	LD	H,00H
	ADD	HL,DE
	LD	A,(HL)
	EX	DE,HL
	POP	HL
	AND	A
	RET	

;	 Subroutine S.PUTVRM (put char on display)
;	    Inputs  HL=coords, C=char
;	    Outputs ________________________

J0FBD:	PUSH	HL
	CALL	C0FDC			; convert screenlocation to VRAM base adres
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	LD	A,C
	OUT	(98H),A
	POP	HL
	RET	

;	 Subroutine copy vram to ram
;	    Inputs  HL=vram base adres, DE=ram adres, B=size
;	    Outputs ________________________

C0FC9:	CALL	C097F			; setup vdp adresregister for active screenpage (read)
	EX	DE,HL
	LD	C,98H
	INIR	
	RET	

;	 Subroutine copy ram to vram
;	    Inputs  HL=ram adres, DE=vram base adres, B=size
;	    Outputs ________________________

C0FD2:	EX	DE,HL
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	EX	DE,HL
	LD	C,98H
	OTIR	
	RET	

;	 Subroutine convert screenlocation to VRAM adres
;	    Inputs  H=colnumber,L=linenumber
;	    Outputs ________________________

C0FDC:	PUSH	BC
	DEC	H
	DEC	L			; coords zero based
	LD	E,H
	LD	H,0
	LD	D,H			; DE=colnumber
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,HL			; linenumber*32
	LD	A,(SCRMOD)
	AND	A
	LD	A,(LINLEN)
	JR	Z,J0FF7			; screenmode 0,
	SUB	32+2
	JR	J1004

J0FF7:	CP	40+1
	JR	C,J1001			; 40 col mode,
	ADD	HL,BC			; linenumber*40
	ADD	HL,HL			; linenumber*80
	SUB	80+2
	JR	J1004

J1001:	ADD	HL,BC			; linenumber*40
	SUB	40+2
J1004:	ADD	HL,DE			; +colnumber
	CPL	
	AND	A
	RRA	
	LD	E,A
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(NAMBAS)
	ADD	HL,DE
	POP	BC
	RET	

;	 Subroutine S.GETPLT (get palette values)
;	    Inputs  A=palletenumber
;	    Outputs ________________________

C1011:	PUSH	HL
	LD	D,A
	CALL	C10A0			; get palettetable adres in vram
	CALL	C097F			; setup vdp adresregister for active screenpage (read)
	EX	(SP),HL
	EX	(SP),HL
	IN	A,(98H)
	LD	B,A
	NOP
	NOP
	IN	A,(98H)			; read palette values
	LD	C,A
	POP	HL
	RET	

;	 Subroutine S.RSTPLT (restore all palettes)
;	    Inputs  ________________________
;	    Outputs ________________________

J1025:	PUSH	HL
	LD	D,0			; palletenumber 0
	CALL	C10A0			; get palletetable adres in vram
	CALL	C097F			; setup vdp adresregister for active screenpage (read)
	LD	B,D
	LD	C,16
	CALL	C0685			; VDP Color palette address pointer register = 0
	LD	B,16
J1036:	IN	A,(98H)
	NOP				; wait
	OUT	(9AH),A
	NOP				; wait
	IN	A,(98H)
	NOP				; wait
	OUT	(9AH),A
	NOP				; wait
	DJNZ	J1036			; copy palletetable to paletteregisters
	POP	HL
	RET	

;	 Subroutine S.INIPLT (initialize all palettes)
;	    Inputs  ________________________
;	    Outputs ________________________

C1046:	PUSH	HL
	LD	HL,I105A
	LD	B,16			; 16 palettes
	LD	D,0			; begin with palette 0
J104E:	LD	A,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	CALL	C107A			; S.SETPLT (setup palette)
	INC	D
	DJNZ	J104E			; next palette
	POP	HL
	RET	

I105A:	DEFB	000H,000H
	DEFB	000H,000H
	DEFB	011H,006H
	DEFB	033H,007H
	DEFB	017H,001H
	DEFB	027H,003H
	DEFB	051H,001H
	DEFB	027H,006H
	DEFB	071H,001H
	DEFB	073H,003H
	DEFB	061H,006H
	DEFB	064H,006H
	DEFB	011H,004H
	DEFB	065H,002H
	DEFB	055H,005H
	DEFB	077H,007H

;	 Subroutine S.SETPLT (setup palette)
;	    Inputs  D=palettenumber
;	    Outputs ________________________

C107A:	PUSH	BC
	PUSH	HL
	LD	B,D
	LD	C,16
	PUSH	AF
	CALL	C0685			; setup VDP Color palette address pointer register
	POP	AF
	LD	C,9AH
	OUT	(C),A
	PUSH	AF
	POP	AF			; wait
	OUT	(C),E			; write palettevalues to paletteregisters
	PUSH	AF
	CALL	C10A0			; get palletetable adres in vram
	CALL	C0971			; setup vdp adresregister for active screenpage (write)
	EX	(SP),HL
	EX	(SP),HL
	POP	AF
	OUT	(98H),A
	PUSH	AF
	POP	AF			; wait
	LD	A,E
	OUT	(98H),A			; write palettevalues to palettetable in vram
	POP	HL
	POP	BC
	RET	

;	 Subroutine get palletetable adres in vram
;	    Inputs  ________________________
;	    Outputs ________________________

C10A0:	PUSH	AF
	LD	A,(SCRMOD)
	LD	HL,I10C7
	PUSH	BC
	INC	A
	LD	C,A
	LD	B,00H
	DEC	A
	JR	NZ,J10B7		; not screenmode 0,
	LD	A,(LINLEN)
	CP	40+1
	JR	NC,J10B7
	DEC	C
J10B7:	ADD	HL,BC
	ADD	HL,BC
	POP	BC
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	PUSH	DE
	LD	E,D
	LD	D,0
	ADD	HL,DE
	ADD	HL,DE
	POP	DE
	POP	AF
	RET	

I10C7:	DEFW	00400H			; screenmode 0, 40 col mode
	DEFW	00F00H			; screenmode 0, 80 col mode
	DEFW	02020H			; screenmode 1
	DEFW	01B80H
	DEFW	02020H
	DEFW	01B80H
	DEFW	07680H
	DEFW	07680H
	DEFW	0FA80H
	DEFW	0FA80H

;	 Subroutine wait for start of Vertikal Retrace
;	    Inputs  ________________________
;	    Outputs ________________________

C10DB:	LD	A,2
	CALL	C2BEF			; read vdp statusregister 2
	AND	40H
	JR	NZ,C10DB		; wait for VR to finish
J10E4:	LD	A,02H
	CALL	C2BEF			; read vdp statusregister 2
	AND	40H
	JR	Z,J10E4			; wait for start of VR
	RET	

J10EE:	POP	AF
	RET	

;	 Subroutine S.KNJPRT
;	    Inputs  BC=JIS code, A=outputmode
;	    Outputs ________________________

J10F0:	PUSH	AF
J10F1:	LD	A,B
	CP	33
	JR	C,J10EE			; highbyte value <33, quit
	CP	39+1
	JR	C,J1102			; highbyte value is 33-39, kanji-1
	CP	48
	JR	C,J10EE			; highbyte value <48, quit
	CP	116+1
	JR	NC,J10EE		; highbyte value >116, quit
					; highbyte value 48-116, kanji-2
J1102:	LD	A,C
	CP	33
	JR	C,J10EE			; lowbyte value <33, quit
	CP	126+1
	JR	NC,J10EE		; lowbyte value >126, quit
	POP	AF
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	A,C
	SUB	32
	LD	E,A
	LD	D,0			; DE = ten value
	LD	A,B
	SUB	32
	LD	L,A
	LD	H,D			; HL = ku value
	LD	C,L
	LD	B,H
	ADD	HL,HL			; ku*2
	ADD	HL,BC			; ku*3
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; ku*96
	ADD	HL,DE			; ku*96+ten
	CP	48
	JR	C,J1131			; ku<48, kanji-1
	LD	A,H
	SUB	(48*96)/256
	LD	H,A
	LD	C,0DAH			; io adres kanji-2
	JR	J1139

J1131:	CP	16
	JR	C,J1137			; ku<16
	DEC	H
	DEC	H			; for ku>=16 ku*96+ten-512
J1137:	LD	C,0D8H			; io adres kanji-1
J1139:	OUT	(C),L
	ADD	HL,HL
	ADD	HL,HL			; io ports are 6 bit, so shift 2 left
	INC	C
	OUT	(C),H
	LD	B,32
	LD	HL,LINWRK
	INIR				; read kanji pattern
	POP	AF
	PUSH	AF
	AND	A
	LD	C,2			; flag 2 screenpages
	JR	Z,J1178			; print all kanji lines
	LD	HL,LINWRK
	LD	E,L
	LD	D,H
	DEC	A
	JR	Z,J1157			; even lines
	INC	HL			; odd lines
J1157:	LD	C,2
J1159:	LD	B,8
J115B:	LD	A,(HL)
	LD	(DE),A
	INC	HL
	INC	HL			; skip line
	INC	DE
	LD	A,B
	CP	05H
	JR	NZ,J116B
	PUSH	BC
	LD	BC,8
	ADD	HL,BC
	POP	BC			; 4th line, flip right
J116B:	DJNZ	J115B
	PUSH	BC
	LD	BC,0FFF0H
	ADD	HL,BC
	POP	BC			; flip down
	DEC	C
	JR	NZ,J1159
	LD	C,1			; flag 1 screenpage
J1178:	LD	HL,(GRPACX)
	PUSH	HL
	LD	HL,(GRPACY)
	PUSH	HL			; save current graphic pos
	LD	DE,LINWRK
J1183:	LD	HL,(GRPACY)
	PUSH	HL
	LD	HL,(GRPACX)
	PUSH	HL			; save current graphic pos
	LD	B,2
J118D:	PUSH	BC
	EX	DE,HL
	LD	DE,PATWRK
	LD	BC,8
	LDIR				; copy to PATWRK
	PUSH	HL
	CALL	C11E0			; pattern to screen with coords handling
	POP	DE
	POP	BC
	DJNZ	J118D			; next
	POP	HL
	LD	(GRPACX),HL		; restore graphic x pos
	POP	HL
	PUSH	BC
	LD	BC,8
	ADD	HL,BC
	POP	BC
	LD	(GRPACY),HL		; restore graphic y pos + 8
	DEC	C
	JR	NZ,J1183		; next screenpage
	POP	HL
	LD	(GRPACY),HL		; restore graphic y pos
	POP	HL
	LD	BC,16
	ADD	HL,BC
	LD	(GRPACX),HL		; restore graphic x pos + 16
I11BC:	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET	

;	 Subroutine S.GRPPRT
;	    Inputs  ________________________
;	    Outputs ________________________

J11C1:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	HL,I11BC
	PUSH	HL
	CALL	C135C			; convert character
	RET	NC			; graphic header, quit
	JR	NZ,J11D7		; graphic character,
	CP	0DH
	JP	Z,J1216			; handle cr
	CP	20H
	RET	C			; other controlcodes are ignored
J11D7:	CALL	C0852			; copy characterpattern to PATWRK
	LD	A,(FORCLR)
	LD	(ATRBYT),A

;	 Subroutine pattern to screen with coords handling
;	    Inputs  ________________________
;	    Outputs ________________________

C11E0:	LD	HL,(GRPACY)
	EX	DE,HL
	LD	BC,(GRPACX)
	CALL	C137B			; S.SCALXY
	RET	NC			; invalid coords, quit
	CALL	C1401			; S.MAPXYC
	CALL	C122A			; pattern to screen
	LD	A,(SCRMOD)
	AND	0FEH
	CP	6
	JR	Z,J1206			; screenmode 6 and 7 have 512 width, so use 16 bit add
	LD	A,(GRPACX)
	ADD	A,8
	JR	C,J1216			; over the right, next ´line´
	LD	(GRPACX),A		; graphic x coord + 8
	RET

J1206:	LD	HL,(GRPACX)
	LD	BC,8
	ADD	HL,BC
	LD	A,H
	AND	0FEH
	JR	NZ,J1216		; over the right, next ´line´
	LD	(GRPACX),HL		; graphic x coord + 8
	RET	

J1216:	LD	HL,0
	LD	(GRPACX),HL		; graphic x = 0
	LD	A,(GRPACY)
	ADD	A,08H
	CP	0D4H
	JR	C,J1226			; not at bottom of screen, graphic y coord + 8
	XOR	A			; graphic y = 0
J1226:	LD	(GRPACY),A
	RET	

;	 Subroutine pattern to screen
;	    Inputs  ________________________
;	    Outputs ________________________

C122A:	CALL	C2A1D			; special actions for screen 10
	CALL	C2BE4			; wait until VDP command is done
	XOR	A
	CALL	C2C3F			; setup argument
	CALL	C1435			; get coords
	LD	E,A
	CALL	C2C09			; setup dx,dy
	LD	A,E
	SUB	213-8
	LD	L,8
	JR	C,J1247			; vertikal complete
	LD	L,A
	LD	A,7
	SUB	L
	LD	L,A			; partly vertikal
J1247:	LD	B,L			; lines
	LD	DE,8			; nx=8
	LD	H,D			; HL=lines
	CALL	C2C28			; setup nx,ny
	LD	HL,(ATRBYT)
	LD	A,(BAKCLR)
	LD	H,A
	LD	DE,PATWRK
	LD	A,(DE)
	ADD	A,A
	LD	C,A
	LD	A,H
	JR	NC,J1260		; pixel not set, use BAKCLR
	LD	A,L			; pixel set, use ATRBYT
J1260:	CALL	C2C4F			; setup color
	LD	A,(LOGOPR)
	AND	0FH			; logical operation
	OR	0B0H
	CALL	C2C47			; execute vdp command logical move cpu to vram
	DI	
	LD	A,44+128
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; VDP controlregister = colorregister, no update
	LD	A,C
	LD	C,9BH
	DI	
	JR	J1291			; continue with pixel x+1

J127C:	DI	
	LD	A,44+128
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; VDP controlregister = colorregister, no update
	INC	DE
	LD	A,(DE)
	RLCA	
	JR	NC,J128F
	OUT	(C),L
	JP	J1291
J128F:	OUT	(C),H			; pixel x

J1291:	RLCA	
	JR	NC,J1299
	OUT	(C),L
	JP	J129B
J1299:	OUT	(C),H			; pixel x+1

J129B:	RLCA	
	JR	NC,J12A3
	OUT	(C),L
	JP	J12A5
J12A3:	OUT	(C),H			; pixel x+2

J12A5:	RLCA	
	JR	NC,J12AD
	OUT	(C),L
	JP	J12AF
J12AD:	OUT	(C),H			; pixel x+3

J12AF:	RLCA	
	JR	NC,J12B7
	OUT	(C),L
	JP	J12B9
J12B7:	OUT	(C),H			; pixel x+4

J12B9:	RLCA	
	JR	NC,J12C1
	OUT	(C),L
	JP	J12C3
J12C1:	OUT	(C),H			; pixel x+5

J12C3:	RLCA	
	JR	NC,J12CB
	OUT	(C),L
	JP	J12CD
J12CB:	OUT	(C),H			; pixel x+6

J12CD:	RLCA	
	JR	NC,J12D5
	OUT	(C),L
	JP	J12D7
J12D5:	OUT	(C),H			; pixel x+7

J12D7:	EI	
	DJNZ	J127C			; next line
	RET	

;	 Subroutine pattern to screen for startupscreen
;	    Inputs  A=char
;	    Outputs ________________________

C12DB:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	HL,I11BC
	PUSH	HL
	CALL	C135C			; convert character
	RET	NC			; graphic header, quit
	JR	NZ,J12F1		; graphic character,
	CP	07H
	JP	Z,J1B58			; handle beep
	CP	20H
	RET	C			; other controlcodes are ignored
J12F1:	CALL	C0852			; copy characterpattern to PATWRK
	LD	DE,PATWRK
	PUSH	DE
	CALL	C2BE4			; wait until VDP command is done
	XOR	A
	CALL	C2C3F			; setup argument
	CALL	C1435			; get coords
	CALL	C2C09			; setup dx,dy
	LD	HL,8
	LD	DE,16
	CALL	C2C28			; setup nx,ny
	POP	DE
	LD	HL,0103H
	LD	A,(DE)
	ADD	A,A
	LD	C,A
	LD	A,H
	JR	NC,J1319
;
	LD	A,L
J1319:	PUSH	AF
	CALL	C2C4F			; setup color
	LD	A,0B0H
	CALL	C2C47			; execute vdp command logical move cpu to vram
	DI	
	LD	A,44+128
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; vdp controlregister = colorregister, no update
	POP	AF
	OUT	(9BH),A
	LD	A,C
	LD	C,9BH
	LD	B,8
	PUSH	BC
	DEC	B			; b=7 (already done 1 pixel)
	JR	J133C
;

J1337:	INC	DE
	LD	A,(DE)
	PUSH	BC
	LD	B,8
J133C:	RLCA	
	JR	NC,J1347		; pixel not set
	OUT	(C),L
	PUSH	AF
	POP	AF
	OUT	(C),L
	JR	J134D
J1347:	OUT	(C),H
	PUSH	AF
	POP	AF
	OUT	(C),H
J134D:	DJNZ	J133C
;
	POP	BC
	DJNZ	J1337
;
	LD	HL,(CLOC)
	LD	BC,0010H
	ADD	HL,BC
	JP	J1431

;	 Subroutine convert character
;	    Inputs  ________________________
;	    Outputs Cx reset if graphic header, 

C135C:	PUSH	HL
	PUSH	AF
	LD	HL,GRPHED
	XOR	A
	CP	(HL)
	LD	(HL),A
	JR	Z,J1373
	POP	AF
	SUB	40H
	CP	20H
	JR	C,J1371
	ADD	A,40H
J136F:	CP	A
	SCF	
J1371:	POP	HL
	RET	

J1373:	POP	AF
	CP	01H
	JR	NZ,J136F
	LD	(HL),A
	POP	HL
	RET	

;	 Subroutine S.SCALXY
;	    Inputs  ________________________
;	    Outputs ________________________

C137B:	CALL	C066A			; check if new style MSX2 screen
	JP	NC,J13BC		; yep,
	PUSH	HL
	PUSH	BC
	LD	B,01H	; 1 
	EX	DE,HL
	LD	A,H
	ADD	A,A
	JR	NC,J138F
;
	LD	HL,0000H
	JR	J1397
;

J138F:	LD	DE,00C0H
	RST	S.DCOMPR
;
	JR	C,J1399
;
	EX	DE,HL
	DEC	HL
J1397:	LD	B,00H
J1399:	EX	(SP),HL
	LD	A,H
	ADD	A,A
	JR	NC,J13A3
;
	LD	HL,0000H
	JR	J13AB
;

J13A3:	LD	DE,0100H
	RST	S.DCOMPR
;
	JR	C,J13AD
;
	EX	DE,HL
	DEC	HL
J13AB:	LD	B,00H
J13AD:	POP	DE
	SRL	L
	SRL	L
	SRL	E
	SRL	E
	LD	A,B
	RRCA	
	LD	C,L
	LD	B,H
	POP	HL
	RET	
;

J13BC:	PUSH	HL
	PUSH	BC
	LD	B,01H	; 1 
	EX	DE,HL
	LD	A,H
	ADD	A,A
	JR	NC,J13CA
;
	LD	HL,0000H
	JR	J13DC
;

J13CA:	LD	A,(MODE)
	AND	10H
	LD	DE,212
	JR	Z,J13D7
	LD	DE,256
J13D7:	RST	S.DCOMPR
	JR	C,J13DE
	EX	DE,HL
	DEC	HL
J13DC:	LD	B,00H
J13DE:	EX	(SP),HL
	LD	A,H
	ADD	A,A
	JR	NC,J13E8
	LD	HL,0000H
	JR	J13F8

J13E8:	LD	A,(SCRMOD)
	AND	02H	; 2 
	LD	DE,512
	JR	NZ,J13F3
	DEC	D
J13F3:	RST	S.DCOMPR
	JR	C,J13FA
	EX	DE,HL
	DEC	HL
J13F8:	LD	B,00H
J13FA:	LD	A,B
	RRCA	
	LD	B,H
	LD	C,L
	POP	DE
	POP	HL
	RET	
;


;	 Subroutine S.MAPXYC
;	    Inputs  ________________________
;	    Outputs ________________________

C1401:	CALL	C066A			; check if new style MSX2 screen
	JR	C,J140E
	LD	H,B
	LD	L,C
	LD	A,E
	LD	(CMASK),A
	JR	J1431
;

J140E:	PUSH	BC
	LD	A,C
	RRCA	
	LD	A,0F0H
	JR	NC,J1417
;
	LD	A,0FH	; 15 
J1417:	LD	(CMASK),A
	LD	A,C
	ADD	A,A
	ADD	A,A
	AND	0F8H
	LD	C,A
	LD	A,E
	AND	07H	; 7 
	OR	C
	LD	C,A
	LD	A,E
	RRCA	
	RRCA	
	RRCA	
	AND	07H	; 7 
	LD	B,A
	LD	HL,(MLTCGP)
	ADD	HL,BC
	POP	BC
J1431:	LD	(CLOC),HL
	RET	

;	 Subroutine get coords
;	    Inputs  ________________________
;	    Outputs A=current y, HL=current x

C1435:	LD	A,(CMASK)
	LD	HL,(CLOC)
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C143C:	LD	(CMASK),A
	LD	(CLOC),HL
	RET	

;	 Subroutine S.READC
;	    Inputs  ________________________
;	    Outputs ________________________

C1443:	CALL	C066A			; check if new style MSX2 screen
	JP	NC,J1460		; yep,
	PUSH	BC
	PUSH	HL
	CALL	C1435			; get masks
	LD	B,A
	CALL	C0961
	INC	B
	DEC	B
	JP	P,J145B
	RRCA	
	RRCA	
	RRCA	
	RRCA	
J145B:	AND	0FH	; 15 
	POP	HL
	POP	BC
	RET	

J1460:	PUSH	HL
	LD	HL,(CLOC)
	LD	A,(CMASK)
	CALL	C2B99
	POP	HL
	RET	
;


;	 Subroutine S.SETATR
;	    Inputs  ________________________
;	    Outputs ________________________

C146C:	CALL	C1DCC			; validate colorattribute
	RET	C			; illegal, quit
	LD	(ATRBYT),A
	RET	
;


;	 Subroutine S.SETC
;	    Inputs  ________________________
;	    Outputs ________________________

C1474:	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	C066A			; check if new style MSX2 screen
	LD	A,(CMASK)
	LD	HL,(CLOC)
	JR	C,J1489			; nope,
	CALL	C2BC0
	POP	HL
	POP	DE
	POP	BC
	RET	
;

J1489:	LD	B,A
	CALL	C0964			; RDVRM
;
	LD	C,A
	LD	A,B
	CPL	
	AND	C
	LD	C,A
	LD	A,(ATRBYT)
	INC	B
	DEC	B
	JP	P,J149E
;
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
J149E:	OR	C
	CALL	C0959			; WRTVRM
;
	POP	HL
	POP	DE
	POP	BC
	RET	
;


;	 Subroutine S.TLEFTC
;	    Inputs  ________________________
;	    Outputs ________________________

C14A6:	PUSH	HL
	CALL	C066A			; check if new style MSX2 screen
	CALL	C1435			; get coords/masks
	JP	C,J1530			; nope,
	DEC	HL
	LD	A,H
	OR	A
	JP	M,J153B
	LD	(CLOC),HL
	POP	HL
	RET	
;


;	 Subroutine S.TDOWNC
;	    Inputs  ________________________
;	    Outputs ________________________

C14BB:	PUSH	HL
	CALL	C066A			; check if new style MSX2 screen
	CALL	C1435			; get coords/masks
	JP	C,J153E			; nope,
	LD	A,(MODE)
	AND	10H	; 16 
	LD	A,(CMASK)
	JR	Z,J14D3
	CP	255
	JR	J14D5

J14D3:	CP	211
J14D5:	JR	NC,J153B
;
	INC	A
	LD	(CMASK),A
	POP	HL
	AND	A
	RET	
;


;	 Subroutine S.TUPC
;	    Inputs  ________________________
;	    Outputs ________________________

C14DE:	CALL	C066A			; check if new style MSX2 screen
	JP	C,J1578			; nope,
	LD	A,(CMASK)
	OR	A
	SCF	
	RET	Z
;
	DEC	A
	LD	(CMASK),A
	OR	A
	RET	
;


;	 Subroutine S.TRIGHT
;	    Inputs  ________________________
;	    Outputs ________________________

C14F0:	PUSH	HL
	CALL	C1435			; get masks
	AND	A
	LD	A,0FH	; 15 
	JP	M,J152A
	LD	A,L
	AND	0F8H
	CP	0F8H
	JR	NZ,J150D
	JR	J153B

;	 Subroutine S.RIGHTC
;	    Inputs  ________________________
;	    Outputs ________________________

J1503:	PUSH	HL
	CALL	C1435			; get masks
	AND	A
	LD	A,0FH	; 15 
	JP	M,J152A
;
J150D:	PUSH	DE
	LD	DE,8
	LD	A,0F0H
	JR	J1525

;	 Subroutine S.LEFTC
;	    Inputs  ________________________
;	    Outputs ________________________

J1515:	PUSH	HL
	CALL	C1435			; get masks
;
	AND	A
	LD	A,0F0H
	JP	P,J152A
;
J151F:	PUSH	DE
	LD	DE,0FFF8H
	LD	A,0FH	; 15 
J1525:	ADD	HL,DE
	LD	(CLOC),HL
	POP	DE
J152A:	LD	(CMASK),A
	AND	A
	POP	HL
	RET	
;

J1530:	AND	A
	LD	A,0F0H
	JP	P,J152A
;
	LD	A,L
	AND	0F8H
	JR	NZ,J151F
;
J153B:	SCF	
	POP	HL
	RET	
;

J153E:	PUSH	DE
	PUSH	HL
	LD	HL,(MLTCGP)
	LD	DE,0500H
	ADD	HL,DE
	EX	DE,HL
	POP	HL
	RST	S.DCOMPR
;
	JR	C,J1558
;
	LD	A,L
	INC	A
	AND	07H	; 7 
	JR	NZ,J1558
;
	SCF	
	POP	DE
	POP	HL
	RET	

;	 Subroutine S.DOWNC
;	    Inputs  ________________________
;	    Outputs ________________________

J1556:	PUSH	HL
	PUSH	DE
J1558:	CALL	C1435			; get coords
	INC	HL
	LD	A,L
	LD	DE,00F8H
	JR	J156C

;	 Subroutine S.UPC
;	    Inputs  ________________________
;	    Outputs ________________________

J1562:	PUSH	HL
	PUSH	DE
J1564:	CALL	C1435			; get coords
	LD	A,L
	DEC	HL
	LD	DE,0FF08H
J156C:	AND	07H	; 7 
	JR	NZ,J1571
;
	ADD	HL,DE
J1571:	LD	(CLOC),HL
	AND	A
	POP	DE
	POP	HL
	RET	
;

J1578:	PUSH	HL
	PUSH	DE
	LD	HL,(MLTCGP)
	LD	DE,0100H
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(CLOC)
	RST	S.DCOMPR
;
	JR	NC,J1564
;
	LD	A,L
	AND	07H	; 7 
	JR	NZ,J1564
;
	SCF	
	POP	DE
	POP	HL
	RET	
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C1591:	AND	A
	PUSH	AF
	LD	A,(SCRMOD)
	CP	08H	; 8 
	JR	Z,J15A2
;
	POP	AF
	CP	10H	; 16 
	CCF	
J159E:	LD	(BDRATR),A
	RET	
;

J15A2:	POP	AF
	JR	J159E
;


;	 Subroutine S.SCANR
;	    Inputs  ________________________
;	    Outputs ________________________

C15A5:	LD	HL,0000H
	LD	C,L
	CALL	C066A			; check if new style MSX2 screen
	JP	C,J162E
	PUSH	HL
	PUSH	BC
	PUSH	DE
	LD	HL,(CLOC)
	LD	A,(CMASK)
	LD	E,A
	LD	D,00H
	LD	A,(BDRATR)
	CALL	C2AC8
;
	JR	C,J15C9
;
	POP	DE
J15C4:	POP	BC
	POP	HL
	LD	D,H
	LD	E,H
	RET	
;

J15C9:	POP	DE
	PUSH	HL
	LD	HL,(CLOC)
	ADD	HL,DE
	POP	DE
	OR	A
	SBC	HL,DE
	JR	C,J15C4
;
	JR	Z,J15C4
;
	POP	BC
	POP	BC
	PUSH	HL
	EX	DE,HL
	LD	(CSAVEA),HL
	LD	A,(CMASK)
	LD	(CSAVEM),A
	LD	E,A
	LD	D,00H
	LD	A,(BDRATR)
	CALL	C2ACC
;
	PUSH	AF
	JR	C,J15FB
;
	LD	A,(SCRMOD)
	AND	02H	; 2 
	LD	HL,01FFH
	JR	NZ,J15FB
;
	DEC	H
J15FB:	LD	(CLOC),HL
	POP	AF
	JR	C,J1602
;
	INC	HL
J1602:	PUSH	HL
	EX	DE,HL
	LD	HL,(CSAVEA)
	EX	DE,HL
	OR	A
	SBC	HL,DE
	EX	(SP),HL
	PUSH	HL
	EX	DE,HL
	LD	A,(CSAVEM)
	LD	E,A
	LD	D,00H
	LD	A,(ATRBYT)
	CALL	C2AC8
;
	POP	DE
	JR	NC,J1629
;
	RST	S.DCOMPR
;
	JR	NC,J1629
;
	POP	DE
	LD	HL,(CSAVEA)
	CALL	C16A3
;
	POP	DE
	RET	
;

J1629:	LD	C,00H
	POP	HL
	POP	DE
	RET	
;

J162E:	CALL	C1720
;
	JR	NC,J1640
;
	DEC	DE
	LD	A,D
	OR	E
	RET	Z
;
	CALL	C14F0
;
	JR	NC,J162E
;
	LD	DE,0000H
	RET	
;

J1640:	CALL	C1435			; get coords/masks
	LD	(CSAVEA),HL
	LD	(CSAVEM),A
	LD	HL,0000H
J164C:	INC	HL
	CALL	C14F0
;
	RET	C
;
	CALL	C1720
;
	JR	NC,J164C
;
	RET	
;


;	 Subroutine S.SCANL
;	    Inputs  ________________________
;	    Outputs ________________________

C1657:	LD	HL,0000H
	LD	C,L
	CALL	C066A			; check if new style MSX2 screen
	JP	C,J1713			; nope,
	CALL	C14A6
	RET	C
	LD	HL,(CLOC)
	PUSH	HL
	LD	A,(CMASK)
	LD	E,A
	LD	D,00H
	LD	A,(BDRATR)
	CALL	C2AC0
;
	PUSH	AF
	JR	C,J167B
;
	LD	HL,0FFFFH
J167B:	INC	HL
	LD	(CLOC),HL
	EX	DE,HL
	POP	HL
	EX	(SP),HL
	PUSH	HL
	OR	A
	SBC	HL,DE
	INC	HL
	EX	(SP),HL
	PUSH	DE
	LD	A,(CMASK)
	LD	E,A
	LD	D,00H
	LD	A,(ATRBYT)
	CALL	C2AC4
;
	JR	NC,J1708
;
	POP	DE
	POP	BC
	POP	AF
	PUSH	BC
	PUSH	DE
	JR	NC,J16A1
;
	RST	S.DCOMPR
;
	JR	C,J170E
;
J16A1:	POP	HL
	POP	DE
;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C16A3:	CALL	C2A0F			; check if screen 10
	JR	NZ,J16C0		; nope,
	LD	C,07H			; this mask will clear colorpaletselector and flag
	LD	A,81H			; logical move vdp to vram, AND operation
	CALL	C16D6
	CALL	C2BE4			; wait until VDP command is done
	LD	A,(ATRBYT)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A			; colorpaletselector
	OR	08H			; and flag to use it
	LD	C,A
	LD	A,82H			; logical move vdp to vram, OR operation
	JR	J16CF

J16C0:	LD	A,(ATRBYT)
	LD	C,A
	LD	A,(SCRMOD)
	CP	08H
	LD	A,80H			; logical move vdp to vram
	JR	NZ,J16CF
	LD	A,0C0H			; screenmode 8, highspeed move vdp to vram
J16CF:	CALL	C16D6
	EX	DE,HL
	LD	C,0FFH
	RET	

;	 Subroutine __________________________
;	    Inputs  HL = dx, DE = nx, C = color, A = command
;	    Outputs ________________________

C16D6:	PUSH	AF
	LD	A,36
	DI	
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; vdp controlregister = dx register, autoupdate
	LD	A,L
	OUT	(9BH),A
	LD	A,H
	OUT	(9BH),A			; DX
	LD	A,(CMASK)
	OUT	(9BH),A
	LD	A,(ACPAGE)
	OUT	(9BH),A			; DY
	LD	A,E
	OUT	(9BH),A
	LD	A,D
	OUT	(9BH),A			; NX
	LD	A,1
	OUT	(9BH),A
	XOR	A
	OUT	(9BH),A			; NY=1
	LD	A,C
	OUT	(9BH),A			; Color
	XOR	A
	OUT	(9BH),A			; argument
	POP	AF
	EI	
	OUT	(9BH),A			; command
	RET	

J1708:	POP	DE
	POP	HL
	POP	DE
	LD	C,00H
	RET	
;

J170E:	POP	DE
	POP	HL
	LD	C,00H
	RET	
;

J1713:	CALL	C14A6
;
	RET	C
;
	CALL	C1720
;
	JP	C,J1503
;
	INC	HL
	JR	J1713
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C1720:	CALL	C1443
;
	LD	B,A
	LD	A,(BDRATR)
	SUB	B
	SCF	
	RET	Z
;
	LD	A,(ATRBYT)
	CP	B
	RET	Z
;
	CALL	C1474
;
	LD	C,01H	; 1 
	AND	A
	RET	

;	 Subroutine subrom call statement handler
;	    Inputs  ________________________
;	    Outputs ________________________

I1736:	EI	
	LD	DE,I174D
	PUSH	HL
	LD	HL,PROCNM
	CALL	C179A
	POP	HL
	RET	C
	SCF	
	RET	NZ
	CALL	C174B
	EI	
	AND	A
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C174B:	PUSH	DE
	RET	

I174D:	DEFB	"MEMINI",0
	DEFW	C36E1
	DEFB	"MKILL",0
	DEFW	C3880
	DEFB	"MNAME",0
	DEFW	C38D7
	DEFB	"MFILES",0
	DEFW	C37AC
	DEFB	0FFH

;	 Subroutine S.PUTGET
;	    Inputs  ________________________
;	    Outputs ________________________

J1770:	PUSH	AF
	PUSH	HL
	LD	DE,I1786
	CALL	C179A
	JR	C,J1782
	POP	AF
	POP	AF
	DEC	HL
	CALL	C174B
	AND	A
	RET	

J1782:	POP	HL
	POP	AF
	SCF	
	RET	

I1786:	DEFB	0CBH,0
	DEFW	C17C8
	DEFB	"DATE",0
	DEFW	C17CE
	DEFB	"KANJI",0
	DEFW	C21DE
	DEFB	0FFH

;
;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C179A:	PUSH	HL
	LD	A,(DE)
	INC	A
	JR	Z,J17B3
;
	CALL	C17B6
;
	JR	Z,J17AA
;
	INC	DE
	INC	DE
	INC	DE
	POP	HL
	JR	C179A
;

J17AA:	LD	A,(HL)
	EX	(SP),HL
	EX	DE,HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	AND	A
	DEFB	038H			; JR C,xxxx, skip next instruction
J17B3:	SCF
	POP	HL
	RET	
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C17B6:	LD	A,(DE)
	OR	A
	RET	Z
;
	CP	(HL)
	JR	NZ,J17C0
;
	INC	DE
	INC	HL
	JR	C17B6
;

J17C0:	LD	A,(DE)
	AND	A
	INC	DE
	JR	NZ,J17C0
;
	DEC	DE
	DEC	A
	RET
	
;	 Subroutine GET TIME statement
;	    Inputs  ________________________
;	    Outputs ________________________

C17C8:	DEC	B
	LD	BC,I1838
	JR	J17D2

;	 Subroutine GET DATE statement
;	    Inputs  ________________________
;	    Outputs ________________________

C17CE:	DEC	B
	LD	BC,I1854
J17D2:	JP	P,J274A			; not GET but PUT, illegal function call
	RST	S.CHRGTR
	PUSH	BC
	CALL	C27EE			; locate variable
	CALL	C27E8			; check for string
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J17EB			; end of statement, no alarm
	RST	S.SYNCHR
	DEFB	","
	RST	S.SYNCHR
	DEFB	"A"			; check for ,A
	EX	(SP),HL
	LD	BC,14
	ADD	HL,BC
	EX	(SP),HL			; alarm version
J17EB:	POP	BC
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	A,8			; length=8
	CALL	C2800			; allocate stringspace
	LD	HL,(DSCTMP+1)		; adres of stringspace
	POP	DE
	PUSH	HL
	LD	A,(DE)
	RLCA
	AND	01H
	LD	B,A			; bank, normal or alarm
	LD	C,04H			; keep alarm bit, pause state (freezes time/date)
	CALL	C1A41
	LD	C,3-1			; 3 pairs
J1805:	LD	B,2			; 2 digits
J1807:	LD	A,(DE)
	INC	A
	JR	Z,J1810			; FFH means skip, use 0 value
	DEC	A
	OUT	(0B4H),A		; register
	IN	A,(0B5H)
J1810:	INC	DE
	EX	DE,HL
	ADD	A,(HL)			; extra offset
	EX	DE,HL
	DEC	DE
	DAA	
	AND	0FH
	OR	"0"
	LD	(HL),A			; ASCII digit
	INC	DE
	INC	DE
	INC	HL
	DJNZ	J1807
	INC	C
	DEC	C
	JR	Z,J182B			; all pairs done,
	LD	A,(DE)
	LD	(HL),A
	INC	DE
	INC	HL
	DEC	C
	JR	J1805			; next pair

J182B:	CALL	C1A3D			; set clock in running state
	POP	DE
	POP	HL
	LD	(HL),8
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D			; setup stringdescriptor
	POP	HL
	RET	

I1838:	DEFB	5,0
	DEFB	4,0
	DEFB	":"
	DEFB	3,0
	DEFB	2,0
	DEFB	":"
	DEFB	1,0
	DEFB	0,0

	DEFB	085H,0
	DEFB	084H,0
	DEFB	":"
	DEFB	083H,0
	DEFB	082H,0
	DEFB	":"
	DEFB	081H,0
	DEFB	080H,0
	
I1854:
	IF	DATFMT EQ 0
	DEFB	12,8
	DEFB	11,0
	DEFB	"/"
	DEFB	10,0
	DEFB	9,0
	DEFB	"/"
	DEFB	8,0
	DEFB	7,0

	DEFB	0FFH,0
	DEFB	0FFH,0
	DEFB	"/"
	DEFB	0FFH,0
	DEFB	0FFH,0
	DEFB	"/"
	DEFB	088H,0
	DEFB	087H,0
	ENDIF

	IF	DATFMT EQ 1
	DEFB	10,0
	DEFB	9,0
	DEFB	"/"
	DEFB	8,0
	DEFB	7,0
	DEFB	"/"
	DEFB	12,8
	DEFB	11,0

	DEFB	0FFH,0
	DEFB	0FFH,0
	DEFB	"/"
	DEFB	088H,0
	DEFB	087H,0
	DEFB	"/"
	DEFB	0FFH,0
	DEFB	0FFH,0
	ENDIF

	IF	DATFMT EQ 2
	DEFB	8,0
	DEFB	7,0
	DEFB	"/"
	DEFB	10,0
	DEFB	9,0
	DEFB	"/"
	DEFB	12,8
	DEFB	11,0

	DEFB	088H,0
	DEFB	087H,0
	DEFB	"/"
	DEFB	0FFH,0
	DEFB	0FFH,0
	DEFB	"/"
	DEFB	0FFH,0
	DEFB	0FFH,0
	ENDIF

;	 Subroutine SET SCREEN statement
;	    Inputs  ________________________
;	    Outputs ________________________

J1870:	RST	S.CHRGTR
	PUSH	HL
	CALL	C1C83			; select bank 2 clockchip
	LD	B,3			; pos 3
	LD	A,(OLDSCR)
	LD	C,A			; screenmode when in textmode in b0
	LD	A,(RG9SAV)
	RRCA
	RRCA
	AND	02H			; interlace mode in b1
	OR	C			; so b2 and b3 of pos 3 are not used
	CALL	C1B4F			; write nibble to clockchip
	LD	A,(LINLEN)		; pos 4, screenwidth when in textmode
	CALL	C1B46			; write byte to clockchip
	LD	A,(FORCLR)		; pos 5, forground color
	CALL	C1B4F			; write nibble to clockchip
	LD	A,(BAKCLR)		; pos 6, background color
	CALL	C1B4F			; write nibble to clockchip
	LD	A,(BDRCLR)		; pos 7, border color
	CALL	C1B4F			; write nibble to clockchip
	LD	C,0
	LD	A,(CNSDFG)
	OR	A
	JR	Z,J18A8
	SET	0,C			; functionkey display status in b0
J18A8:	LD	A,(CLIKSW)
	OR	A
	JR	Z,J18B0
	SET	1,C			; keyclick status in b1
J18B0:	LD	A,(NTMSXP)
	OR	A
	JR	Z,J18B8
	SET	2,C			; printertype in b2
J18B8:	LD	A,(CS1200)
	LD	HL,LOW
	CP	(HL)
	JR	Z,J18C3
	SET	3,C			; cassettespeed in b3 (not needed on Turbo-R)
J18C3:	LD	A,C
	JP	J1B82			; pos 8, write nibble to clockchip and quit

;	 Subroutine SET ADJUST statement
;	    Inputs  ________________________
;	    Outputs ________________________

C18C7:	RST	S.SYNCHR
	DEFB	"("			; check for (
	CALL	C18FA			; evaluate adjust x parameter
	LD	A,E
	PUSH	AF
	RST	S.SYNCHR
	DEFB	","			; check for ,
	CALL	C18FA			; evaluate adjust y parameter
	RST	S.SYNCHR
	DEFB	")"			; check for )
	POP	AF
	AND	0FH
	LD	D,A
	CALL	C18E5			; write vdp adjust register
	CALL	C1C83			; select bank 2 clockchip
	LD	B,1			; pos 1
	LD	A,D
	JP	C1B46			; write byte to clockchip

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C18E5:	LD	A,E
	RLCA	
	RLCA	
	RLCA	
	RLCA	
	AND	0F0H
	OR	D
	LD	D,A
	LD	(RG18SA),A
	DI	
	OUT	(99H),A
	LD	A,18+128
	EI	
	OUT	(99H),A
	RET	

;	 Subroutine evaluate adjust parameter
;	    Inputs  ________________________
;	    Outputs ________________________

C18FA:	CALL	C281E			; evaluate integer
	PUSH	HL
	EX	DE,HL
	CALL	C28B9			; negate
	EX	DE,HL
	LD	HL,7
	RST	S.DCOMPR
	JR	NC,J1910
	LD	HL,-8-1
	RST	S.DCOMPR
	JP	NC,J274A		; adjust not between -8 and 7, illegal function call
J1910:	POP	HL
	RET	

;	 Subroutine get string parameter
;	    Inputs  ________________________
;	    Outputs A=size,DE=adres of string

C1912:	CALL	C2812			; evaluate expression
	PUSH	HL
	CALL	C282A			; free string
	LD	A,(HL)
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	POP	HL
	RET	

;	 Subroutine S.SETS (SET statement handler)
;	    Inputs  ________________________
;	    Outputs ________________________

J1920:	CP	0C5H
	JP	Z,J1870			; SCREEN token,
	CP	0CBH
	JP	Z,J1980			; TIME token,
	CP	0C0H
	JP	Z,J1A9C			; BEEP token,
	LD	DE,I193C
	CALL	C179A
	JP	C,J2744			; syntax error
	DEC	HL
	RST	S.CHRGTR
	PUSH	DE
	RET	

I193C:	DEFB	"PAGE",0
	DEFW	C1F8F
	DEFB	"SCROLL",0
	DEFW	C1FBD
	DEFB	"VIDEO",0
	DEFW	C358E
	DEFB	"ADJUST",0
	DEFW	C18C7
	DEFB	"TITLE",0
	DEFW	C1A76
	DEFB	"PASSW",0F7H,"D",0
	DEFW	C1AD3
	DEFB	"PROMPT",0
	DEFW	C1AD7
	DEFB	"DATE",0
	DEFW	C1984
	DEFB	0FFH

;	 Subroutine SET TIME statement
;	    Inputs  ________________________
;	    Outputs ________________________

J1980:	RST	S.CHRGTR
	LD	A,":"
	DEFB	001H			; LD BC,xxxx skip next instruction

;	 Subroutine SET DATE statement
;	    Inputs  ________________________
;	    Outputs ________________________

C1984:	LD	A,"/"
	PUSH	AF
	CALL	C1912			; get string parameter
	POP	IX
	CP	8
	JP	NZ,J2744		; stringsize<>8, syntax error
	PUSH	HL
	EX	DE,HL
	CALL	C1A54			; get digitpair

	IF	DATFMT EQ 0

	JR	Z,J199C			; date (YY alway correct, 00-99)
	CP	24H			; hh max 23
	JR	NC,J19B6
J199C:	LD	B,A
	CALL	C1A4C			; check for seperator and get digit pair
	JR	Z,J19A6			; date
	CP	60H			; mm max 59
	JR	J19A8
J19A6:	CP	13H			; MM max 12
J19A8:	JR	NC,J19B6
	LD	C,A
	CALL	C1A4C			; check for seperator and get digit pair
	JR	Z,J19B4			; date
	CP	60H			; ss max 59
	JR	J19B6
J19B4:	CP	32H			; DD max 31
J19B6:	JP	NC,J274A		; illegal function call
	LD	D,A

	ENDIF

	IF	DATFMT EQ 1

	JR	NZ,J199C		; time
	CP	13H			; MM max 12
	JR	NC,J19B6
J199C:	CP	24H			; hh max 23
	JR	NC,J19B6
	LD	D,A
	LD	B,A
	CALL	C1A4C			; check for seperator and get digit pair
	JR	Z,J19A6			; date
	CP	60H
	JR	NC,J19B6		; mm max 59
J19A6:	CP	32H
J19A8:	JR	NC,J19B6		; DD max 31
	LD	C,A
	CALL	C1A4C			; check for seperator and get digit pair
	JR	NZ,J19B4		; time
	LD	D,C			; D= day
	LD	C,B			; C= month
	LD	B,A			; B= year
	JR	J19B9
J19B4:	CP	60H			; ss max 59
J19B6:	JP	NC,J274A		; illegal function call
	LD	D,A
J19B9:
	ENDIF

	IF	DATFMT EQ 2

	JR	Z,J199C			; date
	CP	24H			; HH max 23
	JR	NC,J19B6
J199C:	CP	32H			; DD max 31
	JR	NC,J19B6
	LD	D,A
	LD	B,A
J199D:	CALL	C1A4C			; check for seperator and get digit pair
	JR	NZ,J19A6		; time
	CP	13H			; MM max 12
	JR	NC,J19B6
J19A6:	CP	60H			; MM max 59
	JR	NC,J19B6
	LD	C,A
	CALL	C1A4C			; check for seperator and get digit pair
	JR	NZ,J19B4		; time
	LD	B,A			; B=year
	JR	J19B9			; YY
J19B4:	CP	60H
J19B6:	JP	NC,J274A		; SS max 59, illegal function call
	LD	D,A
J19B9:


	ENDIF

	POP	HL
	PUSH	IX
	DEC	HL
	RST	S.CHRGTR
	POP	IX			; WHY POP IT HERE ???
	LD	A,0			; flag normal
	JR	Z,J19CF			; end of statement, no alarm specifier
	PUSH	IX			; AND PUSH IT HERE ??? 
	RST	S.SYNCHR
	DEFB	","
	RST	S.SYNCHR
	DEFB	"A"			; check for ,A
	POP	IX
	OR	1			; flag alarm
J19CF:	PUSH	HL
	PUSH	AF
	PUSH	BC
	PUSH	DE
	JR	NZ,J19E0		; alarm,
	LD	BC,0004H		; bank 0, keep alarm bit, pause
	CALL	C1A41
	LD	BC,0E00H		; No 1Hz test, No 16 Hz test, reset divider stages, do not reset alarm registers
	JR	J19EE			; change test/reset status and continue

J19E0:	LD	BC,0108H
	CALL	C1A41			; bank 1, keep running bit, reset alarm bit
	CALL	C1A62			; date ?
	JR	Z,J19F3			; yep, skip
	LD	BC,0D00H		; No 1Hz test, No 16 Hz test, no not reset divider stages, reset alarm registers
J19EE:	LD	A,15
	CALL	C1A43			; change test/reset status
J19F3:	POP	DE
	LD	B,0			; seconds nibble
	CALL	C1A62			; date ?
	JR	NZ,J19FD		; nope,
	LD	B,7			; day nibble
J19FD:	LD	A,D			; DD or ss
	CALL	C1B46			; write byte to clockchip
	POP	DE
	POP	AF
	PUSH	AF
	JR	Z,J1A0B			; no alarm,
	CALL	C1A62			; date ?
	JR	Z,J1A37			; yep, skip (alarm has no month and year)
J1A0B:	LD	A,E			; MM or mm
	CALL	C1B46			; write byte to clockchip
	LD	A,D			; YY or hh
	CALL	C1A62			; date ?
	JR	NZ,J1A34		; nope, skip leapyear count calc
	PUSH	AF
	PUSH	BC
	BIT	4,A
	JR	Z,J1A1D			; normaly leapyear 1980,1984,1986,2000,2004,2008 (every 4 years)
	ADD	A,02H			; but 1992,1996,2012,2016 etc also leapyear (INCORRECT)
J1A1D:	AND	03H
	PUSH	AF
	LD	A,1			; bank 1
	CALL	C1C85			; select bank clockchip
	POP	AF
	LD	B,11			; pos 11
	CALL	C1B4F			; write nibble to clockchip
	XOR	A			; bank 0
	CALL	C1C85			; select bank clockchip
	POP	BC
	POP	AF
	SUB	80H
	DAA
J1A34:	CALL	C1B46			; write byte to clockchip
J1A37:	POP	AF
	POP	HL
	LD	B,04H
	JR	NZ,J1A3F		; alarm, alarm bit on

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C1A3D:	LD	B,08H			; running bit on
J1A3F:	LD	C,0FH

;	 Subroutine put clockchip in running state
;	    Inputs  ________________________
;	    Outputs ________________________

C1A41:	LD	A,13

;	 Subroutine write clockchip setup register
;	    Inputs  ________________________
;	    Outputs ________________________

C1A43:	OUT	(0B4H),A
	IN	A,(0B5H)
	AND	C
	OR	B
	OUT	(0B5H),A
	RET	

;	 Subroutine check for seperator and get digitpair
;	    Inputs  ________________________
;	    Outputs A=digitpair (BCD)

C1A4C:	PUSH	IX
	POP	AF
	CP	(HL)
	INC	HL
	JP	NZ,J2744		; syntax error

;	 Subroutine get digitpair
;	    Inputs  ________________________
;	    Outputs ________________________

C1A54:	CALL	C1A6A
	RLCA	
	RLCA	
	RLCA	
	RLCA	
	AND	0F0H
	LD	E,A
	CALL	C1A6A
	OR	E

;	 Subroutine check if date
;	    Inputs  ________________________
;	    Outputs ________________________

C1A62:	PUSH	BC
	PUSH	IX
	POP	BC
	BIT	4,B
	POP	BC
	RET	

;	 Subroutine get digit
;	    Inputs  ________________________
;	    Outputs ________________________

C1A6A:	LD	A,(HL)
	INC	HL
	SUB	"0"
	JR	C,J1A73
	CP	10
	RET	C
J1A73:	JP	J274A			; illegal function call

;	 Subroutine SET TITLE statement
;	    Inputs  ________________________
;	    Outputs ________________________

C1A76:	CP	","
	JR	Z,J1A81
	XOR	A			; a title
	CALL	C1AE2			; get string parameter and write clockchip bank 3
	DEC	HL
	RST	S.CHRGTR
	RET	Z			; end of statement, quit
J1A81:	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT		; evaluate colorparameter
	RET	NZ
	DEC	A			; to zero based
	CP	4
	JR	NC,J1A73		; color must be 1-4
	PUSH	AF
	CALL	C1C83			; select bank 2 clockchip
	LD	B,11			; pos 11
	CALL	C1C5E			; read nibble from clockchip
	AND	0CH
	LD	C,A
	POP	AF
	OR	C			; b3 and b2 used otherwise, b1 and b0 for color
	DEC	B			; pos 11
	JP	C1B4F			; write nibble to clockchip

;	 Subroutine SET BEEP statement
;	    Inputs  ________________________
;	    Outputs ________________________

J1A9C:	CALL	C1C83			; select bank 2 clockchip
	LD	B,10			; pos 10
	CALL	C1C5E			; read nibble from clockchip
	PUSH	AF
	RST	S.CHRGTR
	CP	","
	JR	Z,J1ABE			; timbre parameter not specified, skip to volume
	RST	S.GETBYT		; evaluate timbre operand
	DEC	A			; zero based
	CP	4
	JR	NC,J1AC4		; timbre must be 1-4, illegal function call
	RLCA	
	RLCA	
	AND	0CH
	LD	B,A			; shift to b3 and b2
	POP	AF
	AND	03H
	OR	B			; combine with current volume settings from clockchip
	PUSH	AF
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J1ACD			; end of statement, no volume specified
J1ABE:	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT
	DEC	A			; zero based
	CP	04H			; volume must be 1-4
J1AC4:	JP	NC,J274A		; illegal function call
	LD	B,A
	POP	AF
	AND	0CH
	OR	B
	PUSH	AF
J1ACD:	LD	B,10			; pos 10
	POP	AF
	JP	C1B4F			; write nibble to clockchip

;	 Subroutine SET PASSWORD statement
;	    Inputs  ________________________
;	    Outputs ________________________

C1AD3:	LD	A,1			; a password
	JR	J1AD9

;	 Subroutine SET PROMPT statement
;	    Inputs  ________________________
;	    Outputs ________________________

C1AD7:	LD	A,2			; a prompt
J1AD9:	CALL	C1AE2			; get string parameter and write bank 3
	DEC	HL
	RST	S.CHRGTR
	JP	NZ,J2744		; not end of statement, syntax error
	RET	

;	 Subroutine get string parameter and write bank 3
;	    Inputs  A = type (0=title,1=password,2=prompt)
;	    Outputs ________________________

C1AE2:	PUSH	AF
	CALL	C1912			; get string parameter
	LD	C,A
	CALL	C1C7F			; select bank 3 clockchip
	LD	B,12			; pos 12
	XOR	A
J1AED:	CALL	C1B4F			; write nibble to clockchip
	DEC	B
	DJNZ	J1AED			; clear bank
	POP	AF
	CALL	C1B4F			; write nibble to pos 0 clockchip
	PUSH	HL
	EX	DE,HL
	DEC	A
	JR	Z,J1B0D			; handle password
	LD	E,6			; 6 chars max
J1AFE:	DEC	C
	INC	C
	JR	Z,J1B0B			; end of string, quit
	LD	A,(HL)
	INC	HL
	CALL	C1B46			; write byte to clockchip
	DEC	C
	DEC	E
	JR	NZ,J1AFE		; next char
J1B0B:	POP	HL
	RET

J1B0D:	LD	A,21H
	CALL	C1B46			; write byte to clockchip (pos 1)
	LD	A,03H
	CALL	C1B4F			; write nibble to clockchip, special password signature (010203)
	LD	A,C
	PUSH	AF
	CALL	C2E01			; calculate ´crc´ of password
	LD	B,4			; pos 4
	LD	A,E
	CALL	C1B46			; write byte to clockchip
	LD	A,D
	CALL	C1B46			; Write byte to clockchip, write crc
	POP	AF
	LD	C,A
	XOR	A
	OUT	(7FH),A
	IN	A,(7FH)
	CP	0AAH
	JR	NZ,J1B0B		; no keycard reader, quit
	LD	A,C
	OR	A
	LD	A,1
	JR	Z,J1B38			; empty string, code 1
	INC	A			; code 2
J1B38:	CALL	C1B4F			; write nibble to clockchip (pos 8)
	PUSH	BC
	CALL	C2DF3			; calculate ´crc´ of keycard code
	POP	BC
	LD	A,E
	CALL	C1B46			; write byte to clockchip (pos 9)
	LD	A,D
	POP	HL
					; write byte to clockchip and quit (pos 11)

;	 Subroutine write byte to clockchip
;	    Inputs  A=data,B=pos
;	    Outputs B=pos+2

C1B46:	PUSH	AF
	CALL	C1B4F			; write nibble to clockchip
	POP	AF
	RRCA	
	RRCA	
	RRCA	
	RRCA	

;	 Subroutine write nibble to clockchip
;	    Inputs  A=data,B=pos
;	    Outputs B=pos+1

C1B4F:	PUSH	AF
	LD	A,B
	OUT	(0B4H),A
	INC	B
	POP	AF
	OUT	(0B5H),A
	RET

;	 Subroutine S.BEEP
;	    Inputs  ________________________
;	    Outputs ________________________

J1B58:	PUSH	HL
	CALL	C1BC6			; read beep setting from clockchip
	PUSH	AF
	DEC	B
	JR	Z,J1B86			; timbre 1,
	DEC	B
	JR	Z,J1BA3			; timbre 2,
	DEC	B
	JR	Z,J1BB2			; timbre 3,

; timbre 0 is a simple beep

	LD	E,55H			; 1316 Hz
	CALL	C1C07			; setup channel A frequency
	CALL	C1C10			; enable tonegenerator channel A
	CALL	C1C21			; get amplitude value
	LD	A,8
	CALL	C1C14			; setup amplitude channel A
	LD	BC,41
	CALL	C1C1E			; wait 41 ms
J1B7C:	CALL	C277B			; initialize PSG (silence)
	POP	AF
	LD	B,13			; pos 13 (restore selected bank)
J1B82:	POP	HL
	JP	C1B4F			; write nibble to clockchip

; timbre 1 is a polyphonic beep

J1B86:	LD	HL,I1C2D
	LD	E,0B8H
	CALL	C1C12			; enable tonegenerator on all channels
	LD	E,0A7H			; 670 Hz
	LD	A,2
	CALL	C1C08			; setup channel B frequency
	LD	E,0A8H			; 666 Hz
	LD	A,4
	CALL	C1C08			; setup channel C frequency
	LD	E,0A6H			; 675 Hz
J1B9E:	CALL	C1BE0			; setup channel A, setup amplitude and loop to decrease amplitude
	JR	J1B7C			; end

; timbre 2 is a 2 tones beep

J1BA3:	LD	HL,I1C2D
	CALL	C1C10			; enable tonegenerator channel A
	LD	E,2AH			; 2663 Hz
	CALL	C1BE0			; setup channel A, setup amplitude and loop to decrease amplitude
	LD	E,35H			; 2111 Hz
	JR	J1B9E

; timbre 3 is a 3 tones beep

J1BB2:	LD	HL,J1C35
	CALL	C1C10			; enable tonegenerator channel A
	LD	E,6BH			; 1045 Hz
	CALL	C1BE0			; setup channel A, setup amplitude and loop to decrease amplitude
	LD	E,47H			; 1576 Hz
	CALL	C1BE0			; setup channel A, setup amplitude and loop to decrease amplitude
	LD	E,55H			; 1316 Hz
	JR	J1B9E

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C1BC6:	LD	B,13			; pos 13
	CALL	C1C5E			; read nibble from clockchip
	PUSH	AF			; save current selected bank
	CALL	C1C83			; select bank 2 clockchip
	LD	B,10			; pos 10
	CALL	C1C5E			; read nibble from clockchip
	LD	C,A
	RRCA	
	RRCA	
	AND	03H
	LD	B,A			; B=timbre
	LD	A,C
	AND	03H
	LD	C,A			; C=volume
	POP	AF
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C1BE0:	CALL	C1C07			; setup channel A frequency
	PUSH	BC
	PUSH	HL
	CALL	C1C21			; get amplitude value
	POP	HL
	PUSH	HL
	ADD	HL,BC
	ADD	HL,BC
	LD	C,(HL)			; # of ms to wait for amplitude decrease
	INC	HL
	LD	B,(HL)			; ??? does nothing, remainer of MSX2+ subrom
J1BEF:	LD	A,8
	CALL	C1C14			; setup amplitude channel A
	LD	A,9
	CALL	C1C14			; setup amplitude channel B
	LD	A,10
	CALL	C1C14			; setup amplitude channel C
	CALL	C1C1E			; wait C ms
	DEC	E
	JR	NZ,J1BEF
	POP	HL
	POP	BC
	RET	

;	 Subroutine setup channel A frequency
;	    Inputs  ________________________
;	    Outputs ________________________

C1C07:	XOR	A

;	 Subroutine setup channel frequency
;	    Inputs  A=0,2 or 4
;	    Outputs ________________________

C1C08:	CALL	C1C14			; write psg register
	LD	E,0
	INC	A
	JR	C1C14			; write psg register

;	 Subroutine enable tone generator on channel A
;	    Inputs  ________________________
;	    Outputs ________________________

C1C10:	LD	E,0BEH			; port B=output, port A=input, noice disabled on all channels, tone disabled on channel B and C, tone enabled on channel A

;	 Subroutine write psg configregister
;	    Inputs  ________________________
;	    Outputs ________________________

C1C12:	LD	A,7

;	 Subroutine write psg register
;	    Inputs  A = register, E = data
;	    Outputs ________________________

C1C14:	DI	
	OUT	(0A0H),A
	PUSH	AF
	LD	A,E
	EI	
	OUT	(0A1H),A
	POP	AF
	RET	

;	 Subroutine wait for ms
;	    Inputs  C = number of ms (milliseconds)
;	    Outputs ________________________

C1C1E:	JP	J3571

;	 Subroutine get amplitude value
;	    Inputs  C=volume id (0-3)
;	    Outputs E=amplitude value

C1C21:	LD	B,0
	LD	HL,I1C29
	ADD	HL,BC
	LD	E,(HL)
	RET	

; amplitude table

I1C29:	DEFB	4,7,10,15

; timbre 2 table

I1C2D:	DEFW	88
	DEFW	51
	DEFW	35
	DEFW	24

; timbre 3 table

J1C35:	DEFW	30
	DEFW	17
	DEFW	12
	DEFW	8

;	 Subroutine S.PROMPT
;	    Inputs  ________________________
;	    Outputs ________________________

J1C3D:	CALL	C27C4			; CR/LF to OUTDO if not at start of line
	CALL	C1C7F			; select bank 3 clockchip
	CALL	C1C5C			; read nibble from clockchip at pos 0
	CP	2			; custom prompt ?
	LD	HL,M.3FD7
	JP	NZ,C280C		; nope, print default Ok prompt
J1C4E:	CALL	C1C67			; read byte from clockchip
	JR	Z,J1C59			; end of prompt string
	RST	S.OUTDO
	LD	A,B
	CP	13
	JR	C,J1C4E			; next char
J1C59:	JP	J27BE			; CR/LF to OUTDO and quit

;	 Subroutine read nibble from clockchip at pos 0
;	    Inputs  ________________________
;	    Outputs ________________________

C1C5C:	LD	B,0

;	 Subroutine read nibble from clockchip
;	    Inputs  B = pos nr
;	    Outputs A = nibble, B = pos nr (updated)

C1C5E:	LD	A,B
	OUT	(0B4H),A
	INC	B
	IN	A,(0B5H)
	AND	0FH
	RET	

;	 Subroutine read byte from clockchip
;	    Inputs  B = pos nr
;	    Outputs A = byte, B = pos nr (updated)

C1C67:	PUSH	DE
	CALL	C1C5E
	LD	D,A
	CALL	C1C5E
	RLCA	
	RLCA	
	RLCA	
	RLCA	
	OR	D
	POP	DE
	RET	

;	 Subroutine read word from clockchip
;	    Inputs  B = pos nr
;	    Outputs HL = word, B = pos nr (updated)

C1C76:	CALL	C1C67			; read byte from clockchip
	LD	L,A
	CALL	C1C67			; read byte from clockchip
	LD	H,A
	RET	

;	 Subroutine select bank 3 clockchip
;	    Inputs  ________________________
;	    Outputs ________________________

C1C7F:	LD	A,3
	JR	C1C85			; select bank 3 clockchip

;	 Subroutine select bank 2 clockchip
;	    Inputs  ________________________
;	    Outputs ________________________

C1C83:	LD	A,2			; select bank 2 clockchip

;	 Subroutine select bank clockchip
;	    Inputs  A = bank nr
;	    Outputs ________________________

C1C85:	PUSH	BC
	PUSH	AF
	LD	B,13
	CALL	C1C5E
	AND	0CH
	POP	BC
	OR	B
	OUT	(0B5H),A
	POP	BC
	RET	

;	 Subroutine S.REDCLK
;	    Inputs  C = pos nr (b3-b0), bank nr (b5-b4)
;	    Outputs ________________________

J1C94:	CALL	C1CA6			; select bank and pos clockchip
	IN	A,(0B5H)
	AND	0FH			; read nibble
	RET	

;	 Subroutine S.WRTCLK
;	    Inputs  C = pos nr (b3-b0), bank nr (b5-b4)
;	    Outputs ________________________

J1C9C:	PUSH	AF
	CALL	C1CA6			; select bank and pos clockchip
	POP	AF
	AND	0FH
	OUT	(0B5H),A		; write nibble
	RET	

;	 Subroutine select bank and pos clockchip
;	    Inputs  C = pos nr (b3-b0), bank nr (b5-b4)
;	    Outputs ________________________

C1CA6:	LD	A,C
	PUSH	AF
	AND	30H
	RRCA	
	RRCA	
	RRCA	
	RRCA	
	CALL	C1C85			; select bank clockchip
	POP	AF
	AND	0FH
	OUT	(0B4H),A
	RET	

;	 Subroutine S.SYNCHR
;	    Inputs  
;	    Outputs Zx set=end of statement

J1CB7:	LD	A,(HL)
	EX	(SP),HL
	CP	(HL)
	JP	NZ,J2744		; syntax error
	INC	HL
	EX	(SP),HL

;	 Subroutine S.CHRGTR
;	    Inputs  
;	    Outputs Zx set=end of statement

J1CBF:	CALL	H.CHRG
	INC	HL
J1CC3:	LD	A,(HL)
	CP	":"
	RET	NC
	CP	" "
	JR	Z,J1CBF			; ignore spaces
	JR	NC,J1D36		; 021H-039H
	OR	A
	RET	Z			; end of line, quit
	CP	0BH
	JR	C,J1D31			; 001H-00AH
	CP	1EH
	JR	NZ,J1CDC
	LD	A,(CONSAV)		; special 01EH code, return CONSAV
	OR	A
	RET

J1CDC:	CP	10H
	JR	Z,J1D14			; 010H code, resume in basic text
	PUSH	AF
	INC	HL
	LD	(CONSAV),A
	SUB	1CH
	JR	NC,J1D19		; 01CH (int), 01DH (sng) or 01FH (dbl) code,
	SUB	0F5H
	JR	NC,J1CF3		; 011H - 01BH code, 0-9 constant
	CP	0FEH
	JR	NZ,J1D07		; 00BH (oct), 00CH (hex), 00DH (linepointer) or 00EH (linenumber)

; code 00FH (byte constant)

	LD	A,(HL)			; byte constant
	INC	HL
J1CF3:	LD	(CONTXT),HL		; save basic pointer after constant
	LD	H,0
J1CF8:	LD	L,A
	LD	(CONLO),HL		; integer
	LD	A,2
	LD	(CONTYP),A		; type is integer
	LD	HL,M.46E6		; basicpointer to special basictext to handle constant
	POP	AF
	OR	A			; Zx reset, Cx reset
	RET	

J1D07:	LD	A,(HL)			; A= lowbyte constant
	INC	HL
	INC	HL
	LD	(CONTXT),HL		; save basic pointer after constant
	DEC	HL
	LD	H,(HL)			; H= highbyte constant
	JR	J1CF8

; unused code

?.1D11:	CALL	C1D3C			; UNUSED

; end of unused code

; code 010H

J1D14:	LD	HL,(CONTXT)
	JR	J1CC3			; resume with saved basic pointer

J1D19:	INC	A
	RLCA	
	LD	(CONTYP),A		; variabletype (2,4 or 8)
	PUSH	DE
	PUSH	BC
	LD	DE,CONLO
	CALL	C1D75			; copy to CONLO
	POP	BC
	POP	DE
	LD	(CONTXT),HL		; save basic pointer after constant
	POP	AF
	LD	HL,M.46E6		; basicpointer to special basictext to handle constant
	OR	A			; Cx reset, Zx reset
	RET	

J1D31:	CP	09H
	JP	NC,J1CBF		; TAB or LF, ignore

J1D36:	CP	"0"
	CCF				; Cx set if 0-9
	INC	A
	DEC	A			; Zx reset
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;	    Remark  NOT USED ANYWHERE

; unused code

C1D3C:	LD	A,(CONSAV)
	CP	0FH
	JR	NC,J1D56
	CP	0DH
	JR	C,J1D56
	LD	HL,(CONLO)
	JR	NZ,J1D53
	INC	HL
	INC	HL
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	EX	DE,HL
J1D53:	JP	C27F4			; convert to SGN in DAC

J1D56:	LD	A,(CONTYP)
	LD	(VALTYP),A
	CP	2
	JR	NZ,J1D66
	LD	HL,(CONLO)
	LD	(DAC+2),HL
J1D66:	LD	HL,CONLO
	LD	DE,DAC
	LD	A,(VALTYP)
	CP	4
	JR	NC,C1D75
	INC	DE
	INC	DE

; end of unused code

;	 Subroutine copy
;	    Inputs  HL=source,DE=destination,A=size
;	    Outputs ________________________

C1D75:	LD	C,A
	LD	B,0
	LDIR	
	RET	

;	 Subroutine S.COLOR
;	    Inputs  ________________________
;	    Outputs ________________________

J1D7B:	JP	Z,J1E5E
	CP	0EFH
	JP	Z,J1E4D			; COLOR=
	CP	0C7H
	JP	Z,J2089			; COLORSPRITE
	LD	DE,(FORCLR)
	PUSH	DE			; take current forground and backgroundcolor as default
	CP	","
	JR	Z,J1D9C			; no foreground parameter specified,
	RST	S.GETBYT		; evaluate forground color operand
	CALL	C1DC5			; check colorattribute
	POP	DE
	LD	E,A			; new forgroundcolor
	PUSH	DE
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J1DB8			; end of statement, finish
J1D9C:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J1DAD			; no background parameter specified,
	RST	S.GETBYT
	CALL	C1DC5			; check colorattribute
	POP	DE
	LD	D,A			; new backgroundcolor
	PUSH	DE
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J1DB8			; end of statement, finish
J1DAD:	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT
	CALL	C1DC5			; check colorattribute
	LD	(BDRCLR),A		; new bordercolor
	DEC	HL
	RST	S.CHRGTR
J1DB8:	EX	(SP),HL
	LD	(FORCLR),HL		; set forground and backgroundcolor
	LD	A,L
	LD	(ATRBYT),A		; current pencolor
	CALL	C09E1			; S.CHGCLR
	POP	HL
	RET	

;	 Subroutine check colorattribute
;	    Inputs  ________________________
;	    Outputs ________________________

C1DC5:	CALL	C1DCC			; validate colorattribute
	RET	NC
	JP	J274A			; not valid, illegal function call

;	 Subroutine validate colorattribute
;	    Inputs  ________________________
;	    Outputs ________________________

C1DCC:	PUSH	AF
	CALL	C2A0F			; check if screen 10
	JR	Z,J1DDD			; yep, has '16' colors
	LD	A,(SCRMOD)
	CP	6
	JR	Z,J1DE5			; screenmode 6
	CP	8
	JR	Z,J1DE2			; screenmode 8 (256 colors), always correct
J1DDD:	POP	AF
	CP	16
	CCF				; other screenmodes have 16 colors max
	RET

J1DE2:	POP	AF
	AND	A
	RET

J1DE5:	POP	AF
	CP	32
	CCF	
	RET	C			; >31, flag illegal and quit
	CP	16
	JR	C,J1DF1			; <16,
	AND	0FH			; >=16, bring to 0-15 range
	RET

J1DF1:	AND	03H			; bring to 0-3 range
	PUSH	BC
	LD	B,A
	ADD	A,A
	ADD	A,A
	ADD	A,B			; and set it for 2 pixels ?
	POP	BC
	RET	

;	 Subroutine COLOR=(a,b,c,d,e) statement
;	    Inputs  ________________________
;	    Outputs ________________________

J1DFA:	RST	S.CHRGTR
	LD	A,0FH
	CALL	C1E80
	PUSH	AF
	CALL	C1011			; S.GETPLT
	PUSH	BC
	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J1E20
	CALL	C1E7E
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	E,A
	POP	BC
	LD	A,B
	AND	0FH
	OR	E
	LD	B,A
	PUSH	BC
	DEC	HL
	RST	S.CHRGTR
	CP	")"
	JR	Z,J1E3E
J1E20:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J1E32
	CALL	C1E7E
	POP	BC
	LD	C,A
	PUSH	BC
	DEC	HL
	RST	S.CHRGTR
	CP	")"
	JR	Z,J1E3E
J1E32:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CALL	C1E7E
	POP	BC
	LD	A,B
	AND	0F0H
	OR	E
	LD	B,A
	PUSH	BC
J1E3E:	RST	S.SYNCHR
	DEFB	")"			; check for )
	POP	BC
	LD	A,B
	LD	E,C
	POP	BC
	LD	D,B
	PUSH	AF
	CALL	C10DB			; wait for start of Vertikal Retrace
	POP	AF
	JP	C107A			; S.SETPLT

;	 Subroutine COLOR= statement
;	    Inputs  ________________________
;	    Outputs ________________________

J1E4D:	CALL	C1E6B			; MSX-JE active ?
	JP	C,J274A			; yep, illegal function call
	RST	S.CHRGTR
	CP	"("
	JR	Z,J1DFA
	CP	8CH
	JR	Z,J1E67			; COLOR=RESTORE
	RST	S.SYNCHR
	DEFB	094H			; check for NEW token

;	 Subroutine COLOR=NEW statement
;	    Inputs  ________________________
;	    Outputs ________________________

J1E5E:	CALL	C1E6B			; MSX-JE active ?
	JP	C,J274A			; illegal function call
	JP	C1046			; S.INIPLT (initialize pallette)

;	 Subroutine COLOR=RESTORE statement
;	    Inputs  ________________________
;	    Outputs ________________________

J1E67:	RST	S.CHRGTR
	JP	J1025			; S.RSTPLT

;	 Subroutine check if MSX-je is active
;	    Inputs  ________________________
;	    Outputs ________________________

C1E6B:	LD	A,(SCRMOD)
	CP	02H
	RET	NC			; not in textmode, quit
	PUSH	HL
	XOR	A
	LD	DE,01100H
	CALL	C27AC			; KANJI active ?
	POP	HL
	AND	A
	RET	Z			; nope, quit
	SCF	
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C1E7E:	LD	A,07H	; 7 

;	 Subroutine evaluate operand
;	    Inputs  E=max value
;	    Outputs ________________________

C1E80:	PUSH	AF
	RST	S.GETBYT
	POP	AF
	CP	E
	LD	A,E
	RET	NC
	JP	J274A			; illegal function call

;	 Subroutine S.SCREEN
;	    Inputs  ________________________
;	    Outputs ________________________

J1E89:	CP	","
	JR	Z,J1F06
	RST	S.GETBYT		; evaluate screenmode operand
	CP	12+1
	JP	NC,J274A		; max screenmode=12, illegal function call
	CP	9
	JP	Z,J274A			; screenmode 9 does not exists, illegal function call
	PUSH	HL
	JR	C,J1EF8			; not a MSX2+ screenmode,
	LD	HL,RG25SA
	LD	B,(HL)
	LD	C,B
	SET	3,B			; YJK=1
	RES	4,B			; YAE=0
	CP	12
	JR	Z,J1EE6			; screen 12,
	SET	4,B			; YAE=1
	LD	HL,MODE
	CP	11
	SET	5,(HL)			; flag screen 11
	JR	Z,J1EB5
	RES	5,(HL)			; screen 10, flag no screen 11
J1EB5:	BIT	3,C
	JR	Z,J1EEA			; was not in YJK mode (screen 10-12), screenmode setup
	BIT	4,C
	JR	NZ,J1EFB		; was in YAE mode (screen 10,11), so do nothing
	BIT	4,(HL)
	LD	HL,212-1
	JR	Z,J1EC7
	LD	HL,256-1
J1EC7:	PUSH	BC
	LD	(GYPOS),HL
	LD	HL,256-1
	LD	(GXPOS),HL
	LD	A,1
	LD	(LOGOPR),A		; logical operation = AND
	LD	A,0F7H
	LD	(ATRBYT),A		; mask to reset paletflag
	LD	BC,0
	LD	DE,0			; 0,0
	CALL	C2A78			; box fill
	JR	J1EF0

J1EE6:	BIT	3,C
	JR	NZ,J1EF1		; was already in YJK mode, skip screenmode setup
J1EEA:	PUSH	BC
	LD	A,8
	CALL	C0A4C			; setup screenmode 8 with paletteinit
J1EF0:	POP	BC
J1EF1:	LD	C,25
	CALL	C0685			; write new YJK and YAE settings
	JR	J1EFB

J1EF8:	CALL	C0A4C			; setup screenmode with paletteinit
J1EFB:	LD	A,(LINLEN)
	LD	E,A
	CALL	C207C			; initialize CLMLST
	POP	HL
	DEC	HL
	RST	S.CHRGTR
	RET	Z			; end of statement, quit
J1F06:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J1F23
	RST	S.GETBYT		; evaluate spritemode operand
	CP	3+1 
	JP	NC,J274A		; spritemode must be 0-3, illegal function call
	LD	A,(RG1SAV)
	AND	0FCH
	OR	E
	LD	(RG1SAV),A
	PUSH	HL
	CALL	C076A			; S.CLRSPR
	POP	HL
	DEC	HL
	RST	S.CHRGTR
	RET	Z			; end of statement, quit
J1F23:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J1F2E
	RST	S.GETBYT		; evaluate keyclick operand
	LD	(CLIKSW),A
	RET	Z			; end of statement, quit
J1F2E:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J1F3A
	CALL	C1F63			; evaluate cassettespeed operand and set it up
	DEC	HL
	RST	S.CHRGTR
	RET	Z			; end of statement, quit
J1F3A:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J1F45
	RST	S.GETBYT		; evaluate msxprinter operand
	LD	(NTMSXP),A
	RET	Z			; end of statement, quit
J1F45:	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT		; evaluate interlace operand
	CP	3+1 
	JP	NC,J274A		; must be 0-3, illegal function call
	ADD	A,A
	BIT	1,A
	JR	Z,J1F54			; not interlaced,
	SET	3,A
J1F54:	AND	0CH
	LD	B,A
	LD	A,(RG9SAV)
	AND	0F3H
	OR	B
	LD	C,9
J1F5F:	LD	B,A
	JP	C0685			; vdp(9)

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C1F63:	RST	S.GETBYT		; evaluate operand
	DEC	A			; zero based
	CP	02H
	JP	NC,J274A		; must be 1-2, illegal function call
	PUSH	HL
	LD	BC,5
	AND	A
	LD	HL,CS1200
	JR	Z,J1F75
	ADD	HL,BC
J1F75:	LD	DE,LOW
	LDIR	
	POP	HL
	RET	

;	 Subroutine check screenpage is valid
;	    Inputs  ________________________
;	    Outputs ________________________

C1F7C:	PUSH	BC
	LD	B,A
	CALL	C066A			; check if new style MSX2 screen
	JR	C,J1F8C			; nope, flag invalid
	CP	7
	LD	A,1
	JR	NC,J1F8B		; screenmode 7 and 8, page 1 is max
	LD	A,3			; screenmode 5 and 6, page 3 is max
J1F8B:	CP	B
J1F8C:	LD	A,B
	POP	BC
	RET	

;	 Subroutine SET PAGE statement
;	    Inputs  ________________________
;	    Outputs ________________________

C1F8F:	LD	DE,(DPPAGE)		; use current page settings as default
	CP	","
	JR	Z,J1FA5
	PUSH	DE
	RST	S.GETBYT
	POP	DE
	CALL	C1F7C			; check screenpage is valid
J1F9D:	JP	C,J274A			; nope, illegal function call
	LD	E,A
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J1FB0
J1FA5:	PUSH	DE
	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT
	POP	DE
	CALL	C1F7C			; check screenpage is valid
	JR	C,J1F9D			; nope, illegal function call
	LD	D,A
J1FB0:	LD	(DPPAGE),DE
	PUSH	HL
	CALL	C2BE4			; wait until VDP command is done
	CALL	C0711			; S.SETPAG (setup display and active page)
	POP	HL
	RET	

;	 Subroutine SET SCROLL statement
;	    Inputs  ________________________
;	    Outputs ________________________

C1FBD:	CP	","
	JR	Z,J1FE8			; horizontal parameter not specified,
	CALL	C281E			; evaluate integer
	LD	A,D
	CP	02H
	JP	NC,J274A		; >511, illegal function call
	LD	B,E
	DEC	DE
	RR	D
	RR	E
	SRL	E
	SRL	E
	INC	E
	LD	A,E
	AND	3FH
	LD	E,A
	LD	A,B
	NEG	
	AND	07H
	LD	D,A
	LD	(RG26SA),DE
	LD	A,(HL)
	CP	","
	JR	NZ,J2025		; no parameters, end of statement
J1FE8:	RST	S.CHRGTR
	CP	","
	JR	Z,J1FF6			; vertikal parameter not specified,
	RST	S.GETBYT
	LD	(RG23SA),A
	LD	A,(HL)
	CP	","
	JR	NZ,J2025
J1FF6:	RST	S.CHRGTR
	CP	","
	JR	Z,J2012			; mask parameter not specified,
	RST	S.GETBYT
	CP	1+1
	JP	NC,J274A		; >1, illegal function call
	AND	A
	PUSH	HL
	LD	HL,RG25SA
	RES	1,(HL)
	JR	Z,J200C
	SET	1,(HL)
J200C:	POP	HL
	LD	A,(HL)
	CP	","
	JR	NZ,J2025		; multipage parameter not specified,
J2012:	RST	S.CHRGTR
	RST	S.GETBYT
	CP	1+1
	JP	NC,J274A		; >1, illegal function call
	AND	A
	PUSH	HL
	LD	HL,RG25SA
	RES	0,(HL)
	JR	Z,J2024
	SET	0,(HL)
J2024:	POP	HL
J2025:	JP	J0733			; setup VDP registers and digitizehardware

;	 Subroutine S.WIDTHS
;	    Inputs  ________________________
;	    Outputs ________________________

J2028:	JP	Z,J274A			; illegal function call
	LD	A,(OLDSCR)
	AND	A
	LD	A,E
	JR	Z,J2037			; screenmode 0, 80 kol max
	CP	32+1			; screenmode 1, 32 kol max
	JP	NC,J274A		; illegal function call
J2037:	CP	40+1			;
	JR	C,J2040			; wreid code, not needed at all
	CP	80+1
	JP	NC,J274A		; illegal function call
J2040:	LD	A,(LINLEN)
	CP	E
	RET	Z			; screenwidth not changed, just quit
	LD	A,0CH
	RST	S.OUTDO			; clear screen
J2048:	LD	A,E
	LD	(LINLEN),A		; set new screenwidth
	CALL	C207C			; initialize CLMLST
	LD	A,(OLDSCR)
	DEC	A
	LD	A,E
	JR	NZ,J205D		; screenmode 0
	LD	(LINL32),A		; new screenwidth screenmode 1
	LD	A,0CH
	RST	S.OUTDO			; clear screen
	RET	

J205D:	LD	C,40+1
	LD	A,(LINL40)
	CP	C
	LD	A,E
	LD	(LINL40),A		; new screenwidth screenmode 0
	PUSH	AF
	LD	A,0CH
	RST	S.OUTDO			; clear screen
	POP	AF
	JR	C,J2071			; was in TEXT40 mode
	CP	C
	RET	NC			; was in TEXT80 mode, not changed, quit
	LD	C,A			; change screenmode
J2071:	CP	C
	RET	C			; not changed, quit
	PUSH	AF
	PUSH	HL
	XOR	A
	CALL	C0A4C			; setup screenmode 0 with paletteinit
	POP	HL
	POP	AF
	LD	E,A

;	 Subroutine initialize CLMLST
;	    Inputs  ________________________
;	    Outputs ________________________

C207C:	SUB	0EH
	JR	NC,C207C
	ADD	A,1CH
	CPL	
	INC	A
	ADD	A,E
	LD	(CLMLST),A
	RET	

;	 Subroutine COLORSPRITE statement
;	    Inputs  ________________________
;	    Outputs ________________________

J2089:	CALL	C0664			; MSX1 screenmode ?
	JP	C,J274A			; yep, illegal function call
	RST	S.CHRGTR
	CP	"$"
	JR	Z,J20AE
	LD	A,31
	CALL	C2380			; evaluate (operand), max 31
	PUSH	HL
	CALL	C07EE			; get spritecolor table entry
	EX	(SP),HL
	RST	S.SYNCHR
	DEFB	0EFH			; check for =
	RST	S.GETBYT
	AND	A
	JP	M,J274A			; illegal function call
	LD	BC,16
	EX	(SP),HL
	CALL	C0A05			; fill vram
	POP	HL
	RET	

J20AE:	RST	S.SYNCHR
	DEFB	"$"			; check for $
	LD	A,31
	CALL	C2380			; evaluate (operand), max 31
	PUSH	HL
	CALL	C07EE			; get spritecolor table
	EX	(SP),HL
	RST	S.SYNCHR
	DEFB	0EFH			; check for =
	CALL	C2812			; evaluate expression
	PUSH	HL
	CALL	C282A			; free string
	LD	A,(HL)
	CP	16+1
	JR	C,J20CA
	LD	A,16			; only use first 16 bytes
J20CA:	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	POP	HL
	EX	(SP),HL
	AND	A			; empty string ?
	LD	B,A
	EX	DE,HL
	CALL	NZ,C0FD2		; nope, copy ram to vram
	POP	HL
	RET	

;	 Subroutine S.PUTSPR
;	    Inputs  ________________________
;	    Outputs ________________________

J20D8:	RST	S.CHRGTR
	RST	S.GETBYT
	CP	31+1
	JP	NC,J274A		; planenumber must be 0-31, illegal function call
	LD	(BUF+2),A
	PUSH	HL
	PUSH	AF
	CALL	C07EE			; get spritecolor table
	LD	(LINWRK+0),HL
	LD	DE,LINWRK+2
	LD	B,16
	CALL	C0FC9			; copy vram to ram
	POP	AF
	PUSH	AF
	CALL	C07E3			; get planeattribute table
	LD	(BUF+0),HL
	POP	AF
	LD	B,A
	LD	A,32
	SUB	B
	LD	B,A
	LD	(BUF+3),A
	LD	DE,BUF+4
	PUSH	DE
	CALL	C0FC9			; copy vram to ram (planeattributes)
	POP	HL
	EX	(SP),HL
	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J213E			; coordinate parameter not specified, skip
	CALL	C27B2			; evaluate graphic coordinatepair (complex form)
	EX	(SP),HL
	LD	(HL),E			; sprite y
	INC	HL
	LD	A,B
	ADD	A,A
	LD	A,C
	LD	C,0
	JR	NC,J2123
	ADD	A,32			; negative x, set EC (-32) and adjust X by 32
	LD	C,80H
J2123:	LD	(HL),A			; sprite x and EC bit
	PUSH	HL
	LD	HL,LINWRK+2
	LD	B,16
J212A:	LD	A,(HL)
	AND	7FH
	OR	C
	LD	(HL),A
	INC	HL
	DJNZ	J212A			; also setup EC bit in spritecolor table
	CALL	C21C3			; copy spritecolor table back
	POP	HL
	INC	HL
	EX	(SP),HL
	DEC	HL
	RST	S.CHRGTR
	POP	BC
	JR	Z,J2177
	PUSH	BC
J213E:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J2162			; color parameter not specified, skip
	RST	S.GETBYT
	AND	A
	JP	M,J274A			; color number must be 0-127, illegal function call
	PUSH	HL
	LD	HL,LINWRK+2
	LD	C,A
	LD	B,16
J2150:	LD	A,(HL)
	AND	80H
	OR	C
	LD	(HL),A
	INC	HL
	DJNZ	J2150			; setup color, CC and IC bits
	CALL	C21C3			; copy spritecolor table back
	POP	HL
	DEC	HL
	RST	S.CHRGTR
	POP	BC
	JR	Z,J2177
	PUSH	BC
J2162:	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT		; evaluate spritepattern number
	CALL	C07F8			; get spritesize
	LD	A,E
	JR	NC,J2172		; 8*8 sprite, spritepattern number 0-255
	CP	63+1
	JP	NC,J274A		; 16*16 sprite, spritepattern number must be 0-63, illegal function call
	ADD	A,A
	ADD	A,A			; convert to vdp numbering
J2172:	EX	(SP),HL
	LD	(HL),A			; setup pattern number
	LD	B,H
	LD	C,L
	POP	HL
J2177:	PUSH	HL
	LD	A,(BUF+2)
	SUB	31
	JR	Z,J21B3			; plane 31, is last plane, so nothing more to adjust
	LD	HL,(LINWRK)
	LD	A,(BUF+3)
	LD	B,A
J2186:	LD	DE,0010H
	ADD	HL,DE
	PUSH	HL
	PUSH	BC
	LD	DE,LINWRK+2
	LD	B,16
	CALL	C0FC9			; copy vram to ram
	CALL	C21D0			; check if CC bit is on
	POP	BC
	POP	HL
	JR	Z,J219D			; nope, quit
	DJNZ	J2186
J219D:	LD	A,(BUF+3)
	SUB	B
	JR	Z,J21B3
	LD	B,A
	LD	HL,BUF+8
	LD	DE,(BUF+4)
J21AB:	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	INC	HL
	INC	HL
	DJNZ	J21AB
J21B3:	INC	A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	HL,BUF+4
	LD	DE,(BUF+0)
	CALL	C0FD2			; copy ram to vram
	POP	HL
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C21C3:	LD	HL,LINWRK+2
	LD	DE,(LINWRK)
	LD	B,16
	CALL	C0FD2			; copy ram to vram
	RET	

;	 Subroutine check if CC bit of spritecolor is on
;	    Inputs  ________________________
;	    Outputs ________________________

C21D0:	LD	HL,LINWRK+2
	LD	B,16
J21D5:	LD	A,(HL)
	AND	40H
	RET	NZ
	INC	HL
	DJNZ	J21D5
	XOR	A
	RET	

;	 Subroutine PUT KANJI statement
;	    Inputs  ________________________
;	    Outputs ________________________

C21DE:	DEC	B
	JP	M,J2744			; not PUT but GET, syntax error
	LD	A,(SCRMOD)
	CP	5
	JP	C,J274A			; illegal function call
	RST	S.CHRGTR
	CP	","
	CALL	NZ,C27B2		; evaluate graphic coordinatepair (complex form)
	RST	S.SYNCHR
	DEFB	","			; check for ,
	CALL	C281E			; evaluate integer
	PUSH	DE
	CALL	C284C			; S.ATRSCN
	CALL	C2871			; evaluate graphic logical operand
	DEC	HL
	RST	S.CHRGTR
	CP	","
	LD	A,0
	JR	NZ,J220B		; displaymode parameter not specified, use 0 as default
	RST	S.CHRGTR
	RST	S.GETBYT		; evaluate displaymode parameter
J2206:	CP	3
	JP	NC,J274A		; displaymode must be 0-2, illegal function call
J220B:	POP	BC
	JP	J10F0			; S.KNJPRT

;	 Subroutine S.VDP
;	    Inputs  ________________________
;	    Outputs ________________________

J220F:	LD	A,47
	CALL	C2380			; evaluate (operand), max 47
	CP	8
	JR	C,J222D
	JP	Z,J274A			; basic vdp register 8 does not exist, illegal function call
	DEC	E
	DEC	A
	CP	24
	JR	C,J222D
	JP	Z,J274A			; illegal function call
	CP	28
	JR	C,J222D
	CP	32
	JP	C,J274A			; illegal function call
J222D:	PUSH	DE
	RST	S.SYNCHR
	DEFB	0EFH			; check for =
	RST	S.GETBYT
	POP	BC
	JP	J1F5F

;	 Subroutine S.VDPF
;	    Inputs  ________________________
;	    Outputs ________________________

J2235:	RST	S.CHRGTR
	RST	S.SYNCHR
	DEFB	"("			; check for (
	CALL	C281E			; evaluate integer
	RST	S.SYNCHR
	DEFB	")"			; check for )
	PUSH	HL
	LD	A,D
	RLCA	
	JR	C,J2267			; status register,
	AND	A
	JR	NZ,J2248
	LD	A,E
	CP	1DH
J2248:	JP	NC,J274A		; illegal function call
	CP	09H	; 9 
	JR	NC,J2254
	LD	HL,RG0SAV
	JR	J2260

J2254:	CP	19H
	JR	Z,J2248
	LD	HL,RG25SA-25-1
	JR	NC,J2260
	LD	HL,RG8SAV-8-1
J2260:	ADD	HL,DE
	LD	A,(HL)
J2262:	CALL	C27FA			; byte to DAC
	POP	HL
	RET

J2267:	EX	DE,HL
	CALL	C28B9			; negate
	EX	DE,HL
	LD	HL,9
	RST	S.DCOMPR
	JP	C,J274A			; illegal function call
	LD	A,E
	CALL	C2BEF			; read vdp status register
	JR	J2262

;	 Subroutine S.BASE
;	    Inputs  ________________________
;	    Outputs ________________________

J2279:	LD	A,19
	CALL	C2380			; evaluate (operand), max 19
	LD	D,00H
	PUSH	DE
	RST	S.SYNCHR
	DEFB	0EFH			; check for =
	CALL	C281E			; evaluate integer
	CP	63+1
	JP	NC,J274A		; baseparameter must be 0-63, illegal function call
	EX	(SP),HL
	PUSH	HL
	LD	C,E
	LD	B,D
	POP	HL
	LD	A,L
	PUSH	AF
	ADD	HL,HL
	EX	DE,HL
	LD	HL,I22C8
	ADD	HL,DE
	LD	A,C
	AND	(HL)
	JR	NZ,J229F
;
	INC	HL
	LD	A,B
	AND	(HL)
J229F:	JP	NZ,J274A		; illegal function call
;
	LD	HL,TXTNAM
	ADD	HL,DE
	LD	(HL),C
	INC	HL
	LD	(HL),B
	POP	AF
	LD	E,0FFH
J22AC:	INC	E
	SUB	05H	; 5 
	JR	NC,J22AC
;
	LD	A,(SCRMOD)
	CP	E
	CALL	Z,C22BA
;
	POP	HL
	RET	
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C22BA:	DEC	A
	JP	M,C0BE3			; S.SETTXT
	JP	Z,C0C3D			; S.SETT32
	DEC	A
	JP	Z,C0C73			; S.SETGRP
	JP	C0CC3			; S.SETMLT

I22C8:	DEFW	003FFH
	DEFW	0003FH
	DEFW	007FFH
	DEFW	0007FH
	DEFW	007FFH
	DEFW	003FFH
	DEFW	0003FH
	DEFW	007FFH
	DEFW	0007FH
	DEFW	007FFH
	DEFW	003FFH
	DEFW	01FFFH
	DEFW	01FFFH
	DEFW	0007FH
	DEFW	007FFH
	DEFW	003FFH
	DEFW	0003FH
	DEFW	007FFH
	DEFW	0007FH
	DEFW	007FFH

;	 Subroutine S.BASEF
;	    Inputs  ________________________
;	    Outputs ________________________

J22F0:	RST	S.CHRGTR
	LD	A,64
	CALL	C2380			; evaluate (operand), max 64
	CP	2DH	; "-"
	JR	C,J2305
;
	CP	32H	; "2"
	JP	C,J274A			; illegal function call
;
J22FF:	SUB	05H	; 5 
	CP	2DH	; "-"
	JR	NC,J22FF
;
J2305:	CP	14H	; 20 
	JR	NC,J232A
;
	PUSH	HL
J230A:	CP	02H	; 2 
	JR	NZ,J231A
;
	LD	A,(LINLEN)
	CP	29H	; ")"
	JR	C,J231A
;
	LD	HL,1000H
	JR	J2325
;

J231A:	LD	HL,TXTNAM
	LD	D,00H
	ADD	HL,DE
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
J2325:	CALL	C27F4			; convert to SGN in DAC
	POP	HL
	RET	
;

J232A:	PUSH	HL
	SUB	19H
	JR	NC,J233B
;
	ADD	A,0FH	; 15 
	LD	E,A
	CP	0DH	; 13 
	JR	NZ,J230A
;
	LD	HL,(D2346)
	JR	J2325
;

J233B:	LD	D,00H
	LD	E,A
	LD	HL,I2348
	ADD	HL,DE
	LD	H,(HL)
	LD	L,D
	JR	J2325
;

D2346:	DEFW	01E00H

I2348:	DEFB	000H,000H,000H,076H,078H,000H,000H,000H
	DEFB	076H,078H,000H,000H,000H,0FAH,0F0H,000H
	DEFB	000H,000H,0FAH,0F0H

;	 Subroutine S.VPOKE
;	    Inputs  ________________________
;	    Outputs ________________________

J235C:	CALL	C2818		; evaluate adres operand
	PUSH	DE
	RST	S.SYNCHR
	DEFB	","		; check for ,
	RST	S.GETBYT
	EX	(SP),HL
	CALL	C0959		; WTRVRM
	LD	HL,0000H
	CALL	C0964		; RDVRM
	POP	HL
	RET	

;	 Subroutine S.VPEEK
;	    Inputs  ________________________
;	    Outputs ________________________

J236F:	CALL	C27CA		; convert DAC to adres operand
	CALL	C0964		; RDVRM
	PUSH	AF
	LD	HL,0
	CALL	C0964		; RDVRM
	POP	AF
	JP	C27FA		; byte to DAC

;	 Subroutine evaluate (operand) with max
;	    Inputs  E=max value
;	    Outputs ________________________

C2380:	PUSH	AF
	RST	S.SYNCHR
	DEFB	"("		; check for (
	RST	S.GETBYT
	POP	AF
	CP	E
	JP	C,J274A		; illegal function call
	RST	S.SYNCHR
	DEFB	")"		; check for )
	LD	A,E
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C238D:	LD	A,(VALTYP)
	CP	08H	; 8 
	JR	NC,J2399
	SUB	03H	; 3 
	OR	A
	SCF	
	RET	

J2399:	SUB	03H	; 3 
	OR	A
	RET	

; unused code ??

?.239D:	CALL	C238D
	LD	HL,(DAC+2)
	RET	M
	JP	Z,J2756			; string, type mismatch
	JP	J2806			; convert floating point to integer

;	 Subroutine S.SCOPY
;	    Inputs  ________________________
;	    Outputs ________________________

J23AA:	CP	0C5H
	JP	Z,J3655			; COPY SCREEN
	LD	(BUF),HL
	CP	"("
	JR	Z,J242B			; looks like a graphic coordinate, handle
	CALL	C255E			; evaluate string or arrayexpression
	LD	(BUF+4),DE
	LD	(BUF+6),BC
	JR	NC,J23F4		; arrayvariable,
	DEC	HL
	RST	S.CHRGTR
	JP	Z,J25B5
	CP	0D9H			; TO token ?
	JR	NZ,J23D7		; nope,
	RST	S.CHRGTR
	CP	"("
	JR	NZ,J23E0		; no graphic coordinate,
	XOR	A
	LD	(BUF+17),A
	JR	J23DA

J23D7:	CALL	C2593			; evaluate ,direction operand TO
J23DA:	PUSH	HL
	LD	HL,J301B		; graphic copy, variant "file TO vram" (BLTVD)
	JR	J240C

J23E0:	CALL	C255E			; evaluate string or arrayexpression
	JP	C,J25B5			; stringvariable, not a graphic copy statement, quit
	LD	(BUF+8),DE
	LD	(BUF+10),BC
	PUSH	HL
	LD	HL,J2FE2		; graphic copy, variant "file TO array" (BLTMD)
	JR	J2425

J23F4:	DEC	HL
	RST	S.CHRGTR
	CP	0D9H			; TO token ?
	JR	NZ,J2405		; nope,
	RST	S.CHRGTR
	CP	"("
	JR	NZ,J2413		; not a graphic coordinate,
	XOR	A
	LD	(BUF+17),A
	JR	J2408

J2405:	CALL	C2593			; evaluate ,direction operand TO
J2408:	PUSH	HL
	LD	HL,J2EB5		; graphic copy, variant "array TO vram" (BLTVM)
J240C:	LD	(BUF+2),HL
	POP	HL
	JP	J2511

J2413:	CALL	C255E			; evaluate string or arrayexpression
	JP	NC,J2744		; not a string, syntax error
	LD	(BUF+8),DE
	LD	(BUF+10),BC
	PUSH	HL
	LD	HL,J2FEF		; graphic copy, variant "array TO file" (BLTDM)
J2425:	LD	(BUF+2),HL
	JP	J254C

J242B:	PUSH	HL
	LD	HL,J2E2C
	LD	(BUF+2),HL		; speculate for graphic copy, variant "vram to vram" (BLTVV)
	POP	HL
	CALL	C27B2			; evaluate graphic coordinatepair (complex form)
	PUSH	BC
	PUSH	DE
	RST	S.SYNCHR
	DEFB	0F2H			; check for -
	CALL	C27B8			; evaluate graphic coordinatepair (simple form)
	DEC	HL
	RST	S.CHRGTR
	CP	0D9H			; TO token ?
	LD	A,(ACPAGE)
	JR	Z,J2449			; yep, use active page as source page
	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT		; evaluate active page operand
J2449:	CALL	C1F7C			; check screenpage is valid
	JP	C,J274A			; nope, illegal function call
	LD	(BUF+7),A		; source screenpage
	POP	DE
	POP	BC
	RST	S.SYNCHR
	DEFB	0D9H			; check for TO token
	PUSH	HL
	CALL	C137B			; S.SCALXY
	LD	(BUF+4),BC
	LD	A,E
	LD	(BUF+6),A
	CALL	C28CE			; switch GXPOS and GYPOS
	CALL	C137B			; S.SCALXY
	CALL	C28CE			; switch GXPOS and GYPOS
	EX	AF,AF'
	XOR	A
	EX	AF,AF'
	CALL	C28B2			; calculate nx
	JR	NC,J2477
	EX	AF,AF'
	OR	04H			; flag right to left direction
	EX	AF,AF'
J2477:	INC	HL
	LD	(BUF+12),HL
	CALL	C28C3			; calculate ny
	JR	NC,J2484
	EX	AF,AF'
	OR	08H			; flag down to up direction
	EX	AF,AF'
J2484:	INC	HL
	LD	(BUF+14),HL
	EX	AF,AF'
	LD	(BUF+17),A
	EX	AF,AF'
	PUSH	BC
	PUSH	DE
	LD	BC,(BUF+12)
	LD	E,L
	LD	D,H
	CALL	C32E9			; validate NX and NY
	JP	C,J274A			; not valid, illegal function call
	POP	DE
	POP	BC
	POP	HL
	DEC	HL
	RST	S.CHRGTR
	CP	"("
	JR	Z,J2511			; graphic coordinate
	CALL	C255E			; evaluate string or arrayexpression
	LD	(BUF+8),DE
	LD	(BUF+10),BC
	JR	NC,J24B8		; array
	PUSH	HL
	LD	HL,J3127		; graphic copy, variant "vram to file" (BLTDV)
	JP	J250C

J24B8:	PUSH	HL
	PUSH	BC
	PUSH	DE
	LD	BC,(BUF+12)
	LD	DE,(BUF+14)
	CALL	C2FC5			; multiply
	LD	A,00H
	ADD	A,A
	LD	E,A
	CALL	C25A3
	DEC	B
	JR	Z,J24F5
	DEC	B
	JR	Z,J24E8
	LD	BC,0003H
	ADD	HL,BC
	LD	A,E
	ADC	A,00H
	SRL	A
	RR	H
	RR	L
	SRL	A
	RR	H
	RR	L
	JR	J24F5

J24E8:	LD	BC,0001H
	ADD	HL,BC
	LD	A,E
	ADC	A,00H
	SRL	A
	RR	H
	RR	L
J24F5:	POP	DE
	ADD	HL,DE
	JR	C,J2506
	NOP	
	LD	DE,0004H
	ADD	HL,DE
	JR	C,J2506
	NOP	
	POP	DE
	EX	DE,HL
	AND	A
	SBC	HL,DE
J2506:	JP	C,J274A			; illegal function call
	LD	HL,J2E52		; graphic copy, variant "vram to array" (BLTMV)
J250C:	LD	(BUF+2),HL
	JR	J2546

J2511:	CALL	C27B8			; evaluate graphic coordinatepair (simple form)
	PUSH	HL
	CALL	C137B			; S.SCALXY
	LD	(BUF+8),BC
	LD	A,E
	LD	(BUF+10),A
	POP	HL
	XOR	A
	LD	(BUF+11),A
	DEC	HL
	RST	S.CHRGTR
	LD	A,(ACPAGE)
	JR	Z,J2536
	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	LD	A,(ACPAGE)		; default is active screenpage
	CALL	NZ,C2824		; evaluate byte operand
J2536:	CALL	C1F7C			; check screenpage is valid
	JP	C,J274A			; nope, illegal function call
	LD	(BUF+11),A
	CALL	C2871			; evaluate graphic logical operand
	LD	(BUF+18),A
	PUSH	HL
J2546:	CALL	C066A			; check if new style MSX2 screen
	JP	C,J274A			; nope, illegal function call
J254C:	LD	HL,I2558
	PUSH	HL
	LD	HL,(BUF+2)
	PUSH	HL
	LD	HL,BUF+4
	RET	

I2558:	POP	HL
	JP	C,J274A			; illegal function call
	AND	A
	RET	

;	 Subroutine evaluate string or arrayexpression
;	    Inputs  ________________________
;	    Outputs Cx set if string, Cx reset if array

C255E:	PUSH	HL
	CALL	C2812			; evaluate expression
	LD	A,(VALTYP)
	CP	3
	JR	Z,J258B			; string, free string and quit
	POP	HL
	LD	A,1
	LD	(SUBFLG),A		; flag search for array
	CALL	C27EE			; locate variable
	JP	NZ,J274A		; illegal function call
	LD	(SUBFLG),A
	PUSH	HL
	LD	H,B
	LD	L,C
	EX	DE,HL
	ADD	HL,DE
	DEC	HL
	PUSH	HL
	LD	A,(BC)
	ADD	A,A
	LD	L,A
	LD	H,0
	INC	BC
	ADD	HL,BC
	EX	DE,HL
	POP	BC
	POP	HL
	AND	A
	RET	

J258B:	PUSH	HL
	CALL	C282A			; free string
	POP	HL
	POP	DE
	SCF	
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2593:	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT
	CP	4
	JP	NC,J274A		; illegal function call
	ADD	A,A
	ADD	A,A
	LD	(BUF+17),A
	RST	S.SYNCHR
	DEFB	0D9H			; check for TO token
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C25A3:	LD	B,1
	LD	A,(SCRMOD)
	CP	8
	RET	Z
	INC	B
	CP	5
	RET	Z
	CP	7
	RET	Z
	INC	B
	INC	B
	RET	

J25B5:	XOR	A
	LD	(SUBFLG),A		; flag search for normal variable
	LD	HL,(BUF)
	SCF	
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C25BE:	LD	A,(LFPROG)
	LD	C,A
	LD	A,(RTPROG)
	OR	C
	RET	Z
	LD	A,(PDIREC)

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C25CA:	LD	B,A
	CALL	C1435			; get coords/masks
	LD	C,A

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C25CF:	EX	(SP),HL
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,02H	; 2 
	PUSH	HL
	LD	HL,(STREND)
	LD	B,00H
	ADD	HL,BC
	ADD	HL,BC
	LD	A,88H
	SUB	L
	LD	L,A
	LD	A,0FFH
	SBC	A,H
	LD	H,A
	JR	C,J25EA			; out of memory
	ADD	HL,SP
	POP	HL
	RET	C
J25EA:	JP	J275C			; out of memory

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C25ED:	CALL	C15A5
	LD	(SKPCNT),DE
	LD	(MOVCNT),HL
	LD	A,H
	OR	L
	LD	A,C
	LD	(RTPROG),A
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C25FE:	CALL	C1435			; get coords/masks
	PUSH	HL
	PUSH	AF
	LD	HL,(CSAVEA)
	LD	A,(CSAVEM)
	CALL	C143C			; set coords/masks
	POP	AF
	POP	HL
	LD	(CSAVEA),HL
	LD	(CSAVEM),A
	CALL	C1657
	LD	A,C
	LD	(LFPROG),A
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C261C:	PUSH	HL
	CALL	C137B			; S.SCALXY
	JP	NC,J274A		; illegal function call
	POP	HL
	RET	

J2625:	CALL	C28B9			; negate
	DEC	HL
	DEC	HL
	LD	A,H
	ADD	A,A
	JR	C,J2642
	INC	HL
	PUSH	HL
	EX	DE,HL
	LD	HL,(CLOC)
	OR	A
	SBC	HL,DE
	LD	(CLOC),HL
	POP	DE
	LD	A,(PDIREC)
	CPL	
	CALL	C25CA
J2642:	JP	J2693

; unused data ??

?.2645:	DEFB	0,0,0,0,0,0,0,0,0,0

;	 Subroutine S.PAINT
;	    Inputs  ________________________
;	    Outputs ________________________

J264F:	CALL	C27B2			; evaluate graphic coordinatepair (complex form)
	PUSH	BC
	PUSH	DE
	CALL	C284C			; S.ATRSCN
	LD	A,(ATRBYT)
	LD	E,A
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J2662
	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT
J2662:	LD	A,E
	AND	A
	CALL	C1591
	JP	C,J274A			; illegal function call
	POP	DE
	POP	BC

; strange nop´s here

	IF	MSXMID EQ 0

	NOP
	NOP
	NOP
	NOP
	NOP

	ELSE


	NOP
	NOP

	ENDIF

; ?? looks like the following code is always on A266E ??

	PUSH	HL
	CALL	C261C
	CALL	C1401			; S.MAPXYC
	LD	DE,0001H
	CALL	C25ED
	JR	Z,J2691
	PUSH	HL
	CALL	C25FE
	POP	DE
	ADD	HL,DE
	EX	DE,HL
	XOR	A
	CALL	C25CA
	LD	A,40H	; "@"
	CALL	C25CA
	LD	B,0C0H
	JR	J26B3
;

J2691:	POP	HL
	RET	
;

J2693:	LD	A,(INTFLG)
	OR	A
	CALL	NZ,C2799
;
	LD	A,(LOHDIR)
	OR	A
	JR	Z,J26AC
;
	LD	HL,(LOHADR)
	PUSH	HL
	LD	HL,(LOHMSK)
	PUSH	HL
	LD	HL,(LOHCNT)
	PUSH	HL
J26AC:	POP	DE
	POP	BC
	POP	HL
	LD	A,C
	CALL	C143C			; set coords/masks
;
J26B3:	LD	A,B
	LD	(PDIREC),A
	ADD	A,A
	JR	Z,J2691
;
	PUSH	DE
	JR	NC,J26C2
;
	CALL	C14DE
;
	JR	J26C5
;

J26C2:	CALL	C14BB
;
J26C5:	POP	DE
	JR	C,J26AC
;
	CALL	C25ED
;
	JP	Z,J26AC
;
	XOR	A
	LD	(LOHDIR),A
	CALL	C25FE
;
	LD	E,L
	LD	D,H
	OR	A
	JR	Z,J26F4
;
	DEC	HL
	DEC	HL
	LD	A,H
	ADD	A,A
	JR	C,J26F4
	LD	(LOHCNT),DE
	CALL	C1435			; get coords/masks
	LD	(LOHADR),HL
	LD	(LOHMSK),A
	LD	A,(PDIREC)
	CPL	
	LD	(LOHDIR),A
J26F4:	LD	HL,(MOVCNT)
	ADD	HL,DE
	EX	DE,HL
	CALL	C25BE
	LD	HL,(CSAVEA)
	LD	A,(CSAVEM)
	CALL	C143C			; set coords/masks
J2705:	LD	HL,(SKPCNT)
	LD	DE,(MOVCNT)
	OR	A
	SBC	HL,DE
	JP	Z,J2693
;
	JP	C,J2625
;
	EX	DE,HL
	LD	B,01H	; 1 
	CALL	C25ED
;
	JP	Z,J2693
;
	OR	A
	JR	Z,J2705
;
	EX	DE,HL
	LD	HL,(CSAVEA)
	LD	A,(CSAVEM)
	LD	C,A
	LD	A,(PDIREC)
	LD	B,A
	CALL	C25CF
;
	JR	J2705

;	 Subroutine bad filename
;	    Inputs  ________________________
;	    Outputs ________________________

J2732:	LD	IX,M.6E6B
	JR	J2766

;	 Subroutine sequencial io only
;	    Inputs  ________________________
;	    Outputs ________________________

J2738:	LD	IX,M.6E86
	JR	J2766

;	 Subroutine file already open
;	    Inputs  ________________________
;	    Outputs ________________________

J273E:	LD	IX,M.6E6E
	JR	J2766

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J2744:	LD	IX,M.4055
	JR	J2766

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J274A:	LD	IX,M.475A
	JR	J2766

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J2750:	LD	IX,M.406A
	JR	J2766

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J2756:	LD	IX,M.406D
	JR	J2766

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J275C:	LD	IX,M.6275
	JR	J2766

;	 Subroutine file not found
;	    Inputs  ________________________
;	    Outputs ________________________

J2762:	LD	IX,M.6E74
J2766:	JP	J282E

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2769:	LD	IX,RDRES
	JR	C279D			; call RDRES in mainbios

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C276F:	LD	IX,WRRES
	JR	C279D			; call WRRES in mainbios

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2775:	LD	IX,CHGET
	JR	C279D			; call CHGET in mainbios

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C277B:	LD	IX,GICINI
	JR	C279D			; call GICINI in mainbios

;	 Subroutine display functionkeys when enabled
;	    Inputs  ________________________
;	    Outputs ________________________

J2781:	LD	IX,FNKSB
	JR	C279D			; call FNKSB in mainbios

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J2787:	LD	IX,OUTDO
	JR	C279D			; call OUTDO in mainbios

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C278D:	LD	IX,RDSLT
	JR	C279D			; call RDSLT in mainbios

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2793:	LD	IX,WRSLT
	JR	C279D			; call WRSLT in mainbios

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2799:	LD	IX,CKCNTC
C279D:	JP	J0258			; call CKCNTC in mainbios

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C27A0:	LD	IX,SNSMAT
	JR	C279D			; call SNSMAT in mainbios

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J27A6:	LD	IX,EOL
	JR	C279D			; call EOL in mainbios

;	 Subroutine EXTBIO with basic rom invoked
;	    Inputs  ________________________
;	    Outputs ________________________

C27AC:	LD	IX,M.7FFA
	JR	J280A

;	 Subroutine evaluate graphic coordinatepair (complex form)
;	    Inputs  ________________________
;	    Outputs ________________________

C27B2:	LD	IX,M.579C
	JR	J282E

;	 Subroutine evaluate graphic coordinatepair (simple form)
;	    Inputs  ________________________
;	    Outputs ________________________

C27B8:	LD	IX,M.57AB
	JR	J282E

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J27BE:	LD	IX,M.7328
	JR	J280A

;	 Subroutine CR/LF to OUTDO if not at start of line
;	    Inputs  ________________________
;	    Outputs ________________________

C27C4:	LD	IX,M.7323
	JR	J280A

;	 Subroutine convert DAC to adres operand
;	    Inputs  ________________________
;	    Outputs ________________________

C27CA:	LD	IX,M.5439
	JR	J280A

;	 Subroutine parse filespec
;	    Inputs  ________________________
;	    Outputs ________________________

C27D0:	LD	IX,M.6A0E
	JR	J280A

;	 Subroutine close io buffer
;	    Inputs  ________________________
;	    Outputs ________________________

C27D6:	LD	IX,M.6B24
	JR	J280A

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

J27DC:	LD	IX,M.406F
	JR	J280A

;	 Subroutine print number
;	    Inputs  HL = number
;	    Outputs ________________________

C27E2:	LD	IX,M.3412
	JR	J280A

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C27E8:	LD	IX,M.3058
	JR	J280A

;	 Subroutine locate variable
;	    Inputs  ________________________
;	    Outputs ________________________

C27EE:	LD	IX,M.5EA4
	JR	J280A

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C27F4:	LD	IX,M.3236
	JR	J280A

;	 Subroutine byte to DAC
;	    Inputs  ________________________
;	    Outputs ________________________

C27FA:	LD	IX,M.4FCF
	JR	J280A

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2800:	LD	IX,M.6627
	JR	J280A

;	 Subroutine convert float (SGN or DBL) to integer
;	    Inputs  ________________________
;	    Outputs ________________________

J2806:	LD	IX,M.2F92
J280A:	JR	J282E

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C280C:	LD	IX,M.6678
	JR	J280A

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2812:	LD	IX,FRMEVL
	JR	J282E

;	 Subroutine 
;	    Inputs  ________________________
;	    Outputs ________________________

C2818:	LD	IX,FRMQNT
	JR	J282E

;	 Subroutine evaluate integer
;	    Inputs  ________________________
;	    Outputs ________________________

C281E:	LD	IX,M.520F
	JR	J282E

;	 Subroutine evaluate byte
;	    Inputs  ________________________
;	    Outputs ________________________

C2824:	LD	IX,GETBYT
	JR	J282E

;	 Subroutine free (temp) string
;	    Inputs  ________________________
;	    Outputs ________________________

C282A:	LD	IX,M.67D0
J282E:	CALL	C0262			; call mainrom
	EI	
	RET	

;	 Subroutine S.PSET
;	    Inputs  ________________________
;	    Outputs ________________________

J2833:	PUSH	AF
	CALL	C27B8			; evaluate graphic coordinatepair (simple form)
	POP	AF
	CALL	C284F
	CALL	C2871			; evaluate graphic logical operand
	PUSH	HL
	CALL	C137B			; S.SCALXY
	JR	NC,J284A
	CALL	C1401			; S.MAPXYC
	CALL	C1474
J284A:	POP	HL
	RET	

;	 Subroutine S.ATRSCN
;	    Inputs  ________________________
;	    Outputs ________________________

C284C:	LD	A,(FORCLR)

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C284F:	PUSH	BC
	PUSH	DE
	LD	E,A
	CALL	C065E			; in graphic screenmode ?
	JP	C,J274A			; nope, illegal function call
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J2863
	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J2863
	RST	S.GETBYT
J2863:	LD	A,E
	PUSH	HL
	CALL	C146C			; S.SETATR (set colorattribute)
	JP	C,J274A			; not valid, illegal function call
	POP	HL
	POP	DE
	POP	BC
	JP	J1CC3

;	 Subroutine evaluate graphic logical operand
;	    Inputs  ________________________
;	    Outputs ________________________

C2871:	LD	A,00H
	PUSH	DE
	LD	D,00H
	LD	E,A
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J28A9
	RST	S.SYNCHR
	DEFB	","			; check for ,
	JP	Z,J2750			; missing operand
	CP	","
	JR	Z,J28A9
	LD	E,A
	CP	"T"
	JR	Z,J28A1			; T, transparent logical operation
	CP	0D9H
	JR	Z,J2899			; TO, check TOR operation
	INC	A
	JR	NZ,J28A8		; not a function token, normal logical operation
	RST	S.CHRGTR
	RST	S.SYNCHR
	DEFB	08DH
	RST	S.SYNCHR
	DEFB	"D"			; check for TAND
	LD	E,0F6H
	JR	J289E

J2899:	RST	S.CHRGTR
	RST	S.SYNCHR
	DEFB	"R"			; check for R
	LD	E,0F7H
J289E:	DEC	HL
	JR	J28A6

J28A1:	RST	S.CHRGTR
	JP	Z,J2744			; syntax error
	LD	E,A
J28A6:	LD	D,08H
J28A8:	RST	S.CHRGTR
J28A9:	LD	A,E
	CALL	C292E			; evaluate logical operation
	JP	C,J2744			; not recognized, syntax error
	POP	DE
	RET	

;	 Subroutine calculate nx
;	    Inputs  ________________________
;	    Outputs ________________________

C28B2:	LD	HL,(GXPOS)
	AND	A
	SBC	HL,BC
J28B8:	RET	NC

;	 Subroutine negate
;	    Inputs  HL=value
;	    Outputs HL=negated value

C28B9:	XOR	A
	SUB	L
	LD	L,A
	SBC	A,H
	SUB	L
	LD	H,A
	XOR	A
	SUB	01H
	RET	

;	 Subroutine calculate ny
;	    Inputs  ________________________
;	    Outputs ________________________

C28C3:	LD	HL,(GYPOS)
	AND	A
	SBC	HL,DE
	JR	J28B8

;	 Subroutine SCALXY and switch GXPOS and GYPOS
;	    Inputs  ________________________
;	    Outputs ________________________

C28CB:	CALL	C137B			; S.SCALXY

;	 Subroutine switch GXPOS and GYPOS
;	    Inputs  DE=new GYPOS,BC=new GXPOS
;	    Outputs DE=old GYPOS,BC=old GXPOS

C28CE:	CALL	C28DD			; switch GYPOS

;	 Subroutine switch GXPOS
;	    Inputs  BC=new GXPOS
;	    Outputs BC=old GXPOS

C28D1:	PUSH	HL
	PUSH	BC
	LD	HL,(GXPOS)
	EX	(SP),HL
	LD	(GXPOS),HL
	POP	BC
	POP	HL
	RET	

;	 Subroutine switch GYPOS
;	    Inputs  DE=new GYPOS
;	    Outputs DE=old GYPOS
;
C28DD:	PUSH	HL
	LD	HL,(GYPOS)
	EX	DE,HL
	JR	J2917

;	 Subroutine S.GLINE
;	    Inputs  ________________________
;	    Outputs ________________________

J28E4:	CALL	C27B2			; evaluate graphic coordinatepair (complex form)
	PUSH	BC
	PUSH	DE
	RST	S.SYNCHR
	DEFB	0F2H			; check for -
	CALL	C27B8			; evaluate graphic coordinatepair (simple form)
	CALL	C284C			; S.ATRSCN
	POP	DE
	POP	BC
	DEC	HL
	RST	S.CHRGTR
	JR	Z,J291C
	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J291C
	RST	S.SYNCHR
	DEFB	"B"			; check for B
	JR	Z,J2925
	CP	","
	JR	Z,J2925
	RST	S.SYNCHR
	DEFB	"F"			; check for F

;	 Subroutine S.DOBOXF
;	    Inputs  ________________________
;	    Outputs ________________________

J2907:	CALL	C2871			; evaluate graphic logical operand
	PUSH	HL
	CALL	C2A75
J290E:	LD	HL,(GRPACX)
	LD	(GXPOS),HL
	LD	HL,(GRPACY)
J2917:	LD	(GYPOS),HL
	POP	HL
	RET	

;	 Subroutine S.DOLINE
;	    Inputs  ________________________
;	    Outputs ________________________

J291C:	CALL	C2871			; evaluate graphic logical operand
	PUSH	HL
	CALL	C299B
	JR	J290E

;	 Subroutine S.BOXLIN
;	    Inputs  ________________________
;	    Outputs ________________________

J2925:	CALL	C2871			; evaluate graphic logical operand
	PUSH	HL
	CALL	C295F
	JR	J290E

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C292E:	AND	A
	JR	Z,J295A
	PUSH	BC
	LD	B,A
	CALL	C066A			; check if new style MSX2 screen
	LD	A,B
	POP	BC
	RET	C			; nope, quit
	CP	0F8H
	JR	Z,J2958			; XOR
	CP	0F7H
	JR	Z,J2955			; OR
	CP	0F6H
	JR	Z,J2952			; AND
	CP	0C3H
	JR	Z,J294F			; PRESET
	CP	0C2H
	SCF
	RET	NZ			; not PSET, not recognized
	XOR	A
	DEFB	0C2H			; JP NZ,xxxx (skip next instruction)

J294F:	LD	A,4
	DEFB	0C2H

J2952:	LD	A,1
	DEFB	0C2H

J2955:	LD	A,2
	DEFB	0C2H
;
J2958:	LD	A,3
;
J295A:	OR	D
	LD	(LOGOPR),A
	RET	
;


;	 Subroutine S.NVBXLN
;	    Inputs  ________________________
;	    Outputs ________________________

C295F:	CALL	C28CB			; S.SCALXY and switch GXPOS and GYPOS
	CALL	C28CB			; S.SCALXY and switch GXPOS and GYPOS
	CALL	C28B2			; calculate nx
	JR	Z,C299B
	CALL	C,C28D1			; switch GXPOS
	CALL	C28C3			; calculate ny
	JR	Z,C299B
	CALL	C,C28DD
	LD	HL,(GYPOS)
	PUSH	HL
	PUSH	DE
	EX	DE,HL
	CALL	C299B
	POP	HL
	LD	(GYPOS),HL
	EX	DE,HL
	CALL	C299B
	POP	HL
	DEC	HL
	INC	DE
	LD	(GYPOS),HL
	LD	HL,(GXPOS)
	PUSH	BC
	LD	C,L
	LD	B,H
	CALL	C299B
	POP	HL
	LD	(GXPOS),HL
	LD	C,L
	LD	B,H

;	 Subroutine S.DOGRPH
;	    Inputs  ________________________
;	    Outputs ________________________

C299B:	CALL	C2A1D			; special actions for screen 10
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	HL,(GYPOS)
	PUSH	HL
	LD	HL,(GXPOS)
	PUSH	HL
	CALL	C28CB			; S.SCALXY and switch GXPOS and GYPOS
	CALL	C137B			; S.SCALXY
	CALL	C28C3			; calculate ny
	CALL	C,C28CE			; switch GXPOS and GYPOS
	PUSH	DE
	PUSH	HL
	EX	AF,AF'
	XOR	A
	EX	AF,AF'
	CALL	C28B2			; calculate nx
	EX	DE,HL
	JR	NC,J29C4
	EX	AF,AF'
	OR	04H			; flag right to left direction
	EX	AF,AF'
J29C4:	POP	HL
	RST	S.DCOMPR
	JR	C,J29CD
	EX	DE,HL
	EX	AF,AF'
	OR	01H			; flag major is ny
	EX	AF,AF'
J29CD:	EX	(SP),HL
	CALL	C2BE4			; wait until VDP command is done
	LD	A,36
	DI	
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; vdp controlregister = dx register, autoupdate
	LD	A,C
	OUT	(9BH),A
	LD	C,9BH
	OUT	(C),B			; DX
	OUT	(C),L
	LD	A,(ACPAGE)
	OUT	(9BH),A			; DY
	OUT	(C),E
	OUT	(C),D			; NX
	POP	HL
	OUT	(C),L
	OUT	(C),H			; NY
	LD	A,(ATRBYT)
	OUT	(9BH),A			; color
	EX	AF,AF'
	OUT	(9BH),A			; argument
	LD	A,(LOGOPR)
	AND	0FH			; logical operation
	OR	70H			; LINE command
	OUT	(9BH),A
	EI	
	POP	HL
	LD	(GXPOS),HL
	POP	HL
	LD	(GYPOS),HL
	POP	HL
	POP	DE
	POP	BC
	RET	

;	 Subroutine check if screen 10
;	    Inputs  ________________________
;	    Outputs ________________________

C2A0F:	LD	A,(RG25SA)
	AND	18H
	CP	18H			; YJK=1 and YAE=1 ?
	RET	NZ			; nope, quit
	LD	A,(MODE)
	AND	20H			; screen 10 ?
	RET	

;	 Subroutine special actions for screen 10
;	    Inputs  ________________________
;	    Outputs ________________________

C2A1D:	CALL	C2A0F			; check if screen 10
	RET	NZ			; nope, quit
	POP	IX
	LD	A,(LOGOPR)
	AND	A
	PUSH	AF			; save current logical operation
	EX	AF,AF'
	LD	A,(BAKCLR)
	AND	A
	PUSH	AF			; save current background color
	EX	AF,AF'
	LD	A,(ATRBYT)
	PUSH	AF			; save current pen color
	JR	NZ,J2A56		; already logical operation specified,
	LD	A,0FH
	LD	(ATRBYT),A
	LD	(BAKCLR),A
	LD	A,01H
	LD	(LOGOPR),A		; logical operation = AND
	PUSH	IX
	CALL	CLPRM1			; do action (clears paletselector and flag)
	POP	IX
	LD	A,02H
	LD	(LOGOPR),A		; logical operation = OR
	POP	AF
	EX	AF,AF'
	POP	AF
	PUSH	AF
	SCF				; palet flag on
	EX	AF,AF'
	PUSH	AF
	SCF				; palet flag on
J2A56:	RLA	
	RLA	
	RLA	
	RLA	
	LD	(ATRBYT),A
	EX	AF,AF'
	RLA	
	RLA	
	RLA	
	RLA	
	LD	(BAKCLR),A
	CALL	CLPRM1			; action
	POP	AF
	LD	(ATRBYT),A
	POP	AF
	LD	(BAKCLR),A
	POP	AF
	LD	(LOGOPR),A		; restore
	RET	

;	 Subroutine S.NVBXFL
;	    Inputs  ________________________
;	    Outputs ________________________

C2A75:	CALL	C2A1D			; special actions for screen 10

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2A78:	PUSH	BC
	PUSH	DE
	CALL	C137B			; S.SCALXY
	LD	L,C
	LD	H,B
	LD	A,E
	CALL	C2C09			; setup dx,dy
	CALL	C28CE			; switch GXPOS and GYPOS
	CALL	C28CB			; S.SCALXY and switch GXPOS and GYPOS
	EX	AF,AF'
	XOR	A
	EX	AF,AF'
	CALL	C28B2			; calculate nx
	JR	NC,J2A95
	EX	AF,AF'
	OR	04H			; flag right to left direction
	EX	AF,AF'
J2A95:	INC	HL
	PUSH	HL
	CALL	C28C3			; calculate ny
	JR	NC,J2AA0
	EX	AF,AF'
	OR	08H			; flag down to up direction
	EX	AF,AF'
J2AA0:	INC	HL
	POP	DE
	CALL	C2C28			; setup nx,ny
	EX	AF,AF'
	CALL	C2C3F			; setup argument
	EX	AF,AF'
	LD	A,(ATRBYT)
	CALL	C2C4F			; setup color
	LD	A,(LOGOPR)
	AND	0FH			; logical operation
	ADD	A,80H
	CALL	C2C47			; execute vdp command logical move vdp to vram
	CALL	C2BE4			; wait until VDP command is done
	POP	DE
	POP	BC
	RET	
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C2AC0:	LD	B,04H	; 4 
	JR	J2ACE
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C2AC4:	LD	B,06H	; 6 
	JR	J2ACE
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C2AC8:	LD	B,02H	; 2 
	JR	J2ACE
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C2ACC:	LD	B,00H
J2ACE:	LD	C,A
	CALL	C2A0F			; check if screen 10
	LD	A,C
	JR	Z,J2B38			; yep,
	PUSH	BC
	CALL	C2B14			; setup sx,sy and color
	POP	AF
	DI	
	OUT	(99H),A
	LD	A,45+128
	OUT	(99H),A			; argument vdp register
	LD	A,60H
	OUT	(99H),A
	LD	A,0AEH
	OUT	(99H),A			; SEARCH vdp command
	CALL	C2BE4			; wait until VDP command is done
	AND	10H
	RET	Z
	LD	A,8
	DI	
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 8
	IN	A,(99H)
	LD	L,A			; read statusregister (border x-low)
	LD	A,9
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 9
	IN	A,(99H)			; read statusregister (border x-high)
	PUSH	AF
	XOR	A
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 0
	EI	
	POP	AF
	AND	01H
	LD	H,A
	SCF	
	RET	

;	 Subroutine setup sx, sy and color
;	    Inputs  ________________________
;	    Outputs ________________________

C2B14:	PUSH	AF
	CALL	C2BE4			; wait until VDP command is done
	LD	A,32
	DI	
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; vdp controlregister = sx register
	LD	A,L
	OUT	(9BH),A
	LD	A,H
	OUT	(9BH),A			; sx
	LD	A,E
	OUT	(9BH),A
	LD	A,(ACPAGE)
	OUT	(9BH),A			; sy
	POP	AF
	OUT	(99H),A
	LD	A,44+128
	OUT	(99H),A			; color
	EI	
	RET	
;

J2B38:	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	08H
	LD	C,A
	PUSH	BC
	PUSH	HL
	LD	H,E
	LD	L,00H
	LD	DE,BUF
	LD	BC,0100H
	CALL	C0829			; transfer VRAM to RAM
	POP	DE
	LD	HL,BUF
	ADD	HL,DE
	POP	BC
	LD	A,E
	INC	E
	BIT	2,B
	JR	NZ,J2B76
	NEG	
	BIT	1,B
	LD	B,A
	JR	NZ,J2B6B
J2B60:	LD	A,(HL)
	AND	0F8H
	CP	C
	JR	Z,J2B91
	INC	HL
	DJNZ	J2B60
	AND	A
	RET	

J2B6B:	LD	A,(HL)
	AND	0F8H
	CP	C
	JR	NZ,J2B91
	INC	HL
	DJNZ	J2B6B
	AND	A
	RET	

J2B76:	BIT	1,B
	LD	B,E
	JR	NZ,J2B86
J2B7B:	LD	A,(HL)
	AND	0F8H
	CP	C
	JR	Z,J2B91
	DEC	HL
	DJNZ	J2B7B
	AND	A
	RET	

J2B86:	LD	A,(HL)
	AND	0F8H
	CP	C
	JR	NZ,J2B91
	DEC	HL
	DJNZ	J2B86
	AND	A
	RET	

J2B91:	LD	DE,BUF
	AND	A
	SBC	HL,DE
	SCF	
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2B99:	PUSH	DE
	CALL	C2C04			; setup sx,sy
	XOR	A
	CALL	C2C3F			; setup argument
	LD	A,40H
	CALL	C2C47			; execute vdp command POINT
	CALL	C2BE4			; wait until VDP command is done
	LD	A,7
	CALL	C2BEF			; read vdp statusregister 7
	EI	
	LD	E,A
	CALL	C2A0F			; check if screen 10
	LD	A,E
	POP	DE
	RET	NZ			; nope, quit
	AND	0F8H			; ignore J and K
	RRA	
	RRA	
	RRA	
	RRA
	RET	C			; pallete used, return C value
	LD	A,0FFH			; return 255
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2BC0:	LD	B,A
	CALL	C2A1D			; special actions for screen 10
	LD	A,B
	CALL	C2C09			; setup dx,dy
	LD	A,44
	DI	
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; vdp controlregister = colorregister, autoupdate
	LD	A,(ATRBYT)
	OUT	(9BH),A			; color
	XOR	A
	OUT	(9BH),A			; argument
	LD	A,(LOGOPR)
	AND	0FH			; logical operation
	OR	50H			; PSET command
	OUT	(9BH),A
	EI	
	RET	

;	 Subroutine wait until VDP command is done
;	    Inputs  ________________________
;	    Outputs ________________________

C2BE4:	LD	A,2
	CALL	C2BEF			; read vdp statusregister 2
	EI	
	RRCA	
	JR	C,C2BE4
	RLCA	
	RET

;	 Subroutine S.VDPSTA (read vdp statusregister)
;	    Inputs  A = statusregisternr
;	    Outputs ________________________

C2BEF:	DI	
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A
	PUSH	HL
	POP	HL
	IN	A,(99H)
	PUSH	AF
	XOR	A
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A
	POP	AF
	RET	

;	 Subroutine setup sx,sy
;	    Inputs  HL = sx, A = sy
;	    Outputs ________________________

C2C04:	PUSH	AF
	LD	A,32			; vdp sx register, autoupdate
	JR	J2C0C

;	 Subroutine setup dx,dy
;	    Inputs  HL = dx, A = dy
;	    Outputs ________________________

C2C09:	PUSH	AF
	LD	A,36			; vdp dx register, autoupdate
J2C0C:	PUSH	AF
	CALL	C2BE4			; wait until VDP command is done
	DI	
	POP	AF
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; setup vdp controlregister
	LD	A,L
	OUT	(9BH),A
	LD	A,H
	OUT	(9BH),A
	POP	AF
	OUT	(9BH),A
	LD	A,(ACPAGE)
	OUT	(9BH),A
	EI	
	RET	

;	 Subroutine setup nx,ny
;	    Inputs  DE = nx, HL = ny
;	    Outputs ________________________

C2C28:	LD	A,40
	DI	
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A			; vdp controlregister = register 40, autoupdate
	LD	A,E
	OUT	(9BH),A
	LD	A,D
	OUT	(9BH),A
	LD	A,L
	OUT	(9BH),A
	LD	A,H
	OUT	(9BH),A
	EI	
	RET	

;	 Subroutine setup vdp argument
;	    Inputs  ________________________
;	    Outputs ________________________

C2C3F:	PUSH	AF
	DI	
	OUT	(99H),A
	LD	A,45+128
	JR	J2C55

;	 Subroutine execute vdp command
;	    Inputs  ________________________
;	    Outputs ________________________

C2C47:	PUSH	AF
	DI	
	OUT	(99H),A
	LD	A,46+128
	JR	J2C55

;	 Subroutine setup vdp color
;	    Inputs  ________________________
;	    Outputs ________________________

C2C4F:	PUSH	AF
	DI	
	OUT	(99H),A
	LD	A,44+128
J2C55:	EI	
	OUT	(99H),A
	POP	AF
	RET	
;

I2C5A:	DEFB	000H,020H,000H,000H,000H,000H,000H,000H
	DEFB	008H

	IF	INTHZ EQ 60

	DEFB	000H

	ELSE

	DEFB	002H

	ENDIF

	DEFB	000H,000H,000H,000H,000H,000H
	DEFB	000H,000H,000H,000H,000H,03BH,005H,000H
	DEFB	000H,000H,000H,000H

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2C76:	PUSH	HL
	LD	A,0C3H
	LD	(H.NMI+0),A
	LD	HL,BUF
	LD	(H.NMI+1),HL		; JP BUF
	LD	DE,BUF
	LD	HL,I2CB3
	LD	BC,11
	LDIR	
	LD	IX,NMI
	CALL	C279D			; call NMI in mainbios
	LD	HL,0C9C9H
	LD	(H.NMI+0),HL
	LD	(H.NMI+2),HL		; clear hook
	LD	A,2
	LD	(SCRMOD),A
	POP	HL
	CALL	C2CBE
	LD	B,3
	LD	HL,0
J2CAB:	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,J2CAB
	DJNZ	J2CAB
	RET	

I2CB3:	LD	IY,OPTSID*256
	LD	IX,OPTENT
	JP	CALSLT
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C2CBE:	LD	A,L
	OR	H
	JR	NZ,J2CC4
	LD	L,4			; always 64 Kb (4 pages)
J2CC4:	PUSH	HL
	LD	HL,112
	LD	A,116
	CALL	C2D84			; pos 112,116
	LD	HL,I2D9E
	CALL	C2D8B			; print text main ram
	POP	HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			; *16 to have in Kb´s
	CALL	C2DAF			; convert number to text
	CALL	C2D8B			; print text
	LD	HL,I2DA8
	CALL	C2D8B			; print text Kb
	XOR	A
	OUT	(99H),A
	OUT	(99H),A
	OUT	(99H),A
	LD	A,8EH
	OUT	(99H),A
	CALL	C1C7F			; select bank 3 clockchip
	CALL	C1C5C			; read nibble from clockchip at pos 0
	JR	Z,J2D6D
	DEC	A
	RET	NZ
	CALL	C1C5E
	CP	01H
	RET	NZ
	CALL	C1C5E
	CP	02H
	RET	NZ
	CALL	C1C5E
	CP	03H
	RET	NZ
	LD	B,08H	; 8 
	CALL	C1C5E
	JR	Z,J2D27
	XOR	A
	OUT	(7FH),A
	IN	A,(7FH)
	CP	0AAH
	JR	NZ,J2D27
	PUSH	BC
	CALL	C2DF3
	POP	BC
	CALL	C1C76			; read word from clockchip
	RST	S.DCOMPR
	RET	Z
	JR	J2D38

J2D27:	LD	A,6
	CALL	C27A0
	AND	04H			; GRAPH key ?
	JR	NZ,J2D38		; nope,
	LD	A,7
	CALL	C27A0
	AND	10H			; STOP key ?
	RET	Z			; GRAPH+STOP, quit
J2D38:	LD	HL,50
	LD	A,144
	CALL	C2D84			; pos 50,144
	LD	HL,I2D94
	CALL	C2D8B			; print text password
	LD	B,08H
	CALL	C1C5E
	DEC	A
J2D4C:	JR	Z,J2D4C
J2D4E:	LD	HL,BUF
	LD	B,0FFH
J2D53:	CALL	C2775			; chget
	CP	0DH
	JR	Z,J2D5E			; return means stop
	LD	(HL),A
	INC	HL
	DJNZ	J2D53
J2D5E:	LD	A,0FFH
	SUB	B			; length
	CALL	C2DFE			; calc crc16
	LD	B,04H			; pos 4
	CALL	C1C76			; read word from clockchip
	RST	S.DCOMPR
	RET	Z
	JR	J2D4E			; try again

J2D6D:	LD	HL,200
	LD	A,136
	CALL	C2D84			; pos 200,136
J2D75:	CALL	C1C67			; read byte from clockchip
	RET	Z
	CALL	C12DB			; pattern to screen for startupscreen
	LD	A,B
	CP	13
	JR	C,J2D75
	JP	C2775

;	 Subroutine set coordinate for startscreen
;	    Inputs  ________________________
;	    Outputs ________________________

C2D84:	LD	(CLOC),HL
	LD	(CMASK),A
	RET	

;	 Subroutine print text for startupscreen
;	    Inputs  HL = pointer to text
;	    Outputs ________________________

C2D8B:	LD	A,(HL)
	INC	HL
	OR	A
	RET	Z
	CALL	C12DB			; pattern to screen for startupscreen
	JR	C2D8B

I2D94:	DEFM	'Password:',0
I2D9E:	DEFM	'Main RAM:',0
I2DA8:	DEFM	'Kbytes',0

;	 Subroutine convert number to text
;	    Inputs  HL = number
;	    Outputs ________________________

C2DAF:	LD	IX,BUF
	LD	C,00H
	LD	DE,0D8F0H
	CALL	C2DDB
	LD	DE,0FC18H
	CALL	C2DDB
	LD	DE,0FF9CH
	CALL	C2DDB
	LD	DE,0FFF6H
	CALL	C2DDB
	LD	A,L
	ADD	A,"0"
	LD	(IX),A
	LD	(IX+1),00H
	LD	HL,BUF
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2DDB:	LD	A,0FFH
J2DDD:	ADD	HL,DE
	INC	A
	JR	C,J2DDD
	SBC	HL,DE
	BIT	0,C
	JR	NZ,J2DEB
	AND	A
	RET	Z
	SET	0,C
J2DEB:	ADD	A,"0"
	LD	(IX),A
	INC	IX
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2DF3:	IN	A,(7FH)
	LD	L,A
	IN	A,(7FH)
	LD	H,A
	LD	(BUF),HL
	LD	A,2

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2DFE:	LD	HL,BUF

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2E01:	LD	DE,0000H
	LD	C,A
	OR	A
	RET	Z
	SCF	
J2E08:	PUSH	AF
J2E09:	LD	B,08H
J2E0B:	POP	AF
	PUSH	AF
	JR	NC,J2E11
	RLC	(HL)
J2E11:	RL	E
	RL	D
	JR	NC,J2E1F
	LD	A,D
	XOR	80H
	LD	D,A
	LD	A,E
	XOR	05H
	LD	E,A
J2E1F:	DJNZ	J2E0B
	INC	HL
	DEC	C
	JR	NZ,J2E09
	POP	AF
	RET	NC
	OR	A
	LD	C,02H
	JR	J2E08



; ******************************************
; Begin Section Blit
; ******************************************



;	 Subroutine S.BLTVV (blit vram-vram)
;	    Inputs  ________________________
;	    Outputs ________________________

J2E2C:	LD	BC,(BUF+12)		; NX
	LD	DE,(BUF+14)		; NY
	CALL	C32E9			; validate NX and NY
	RET	C			; illegal, quit
	CALL	C2BE4			; wait until VDP command is done
	LD	A,32			; sx register, autoupdate
	CALL	C32E1			; set VDP controlregister
	LD	HL,BUF+4
	LD	BC,0E9BH
	OTIR	
	LD	A,(HL)
	AND	0FH			; logical operation
	OR	90H			; LMMM
	OUT	(C),A
	EI	
	AND	A
	RET	

;	 Subroutine S.BLTMV (blit vram-ram)
;	    Inputs  ________________________
;	    Outputs ________________________

J2E52:	CALL	C3293			; setup VDP and array
	LD	A,(SCRMOD)
	SUB	6
	JR	C,J2E6D			; screenmode 5, 2 pixels per byte
	JR	Z,J2E8E			; screenmode 6, 4 pixels per byte
	DEC	A
	JR	Z,J2E6D			; screenmode 7, 2 pixels per byte

J2E61:	CALL	C32C7			; read vdp colorregister
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,C
	OR	B
	JP	NZ,J2E61
	RET

J2E6D:	LD	D,2
	LD	(HL),0
J2E71:	CALL	C2E86			; shift 4 left
	CALL	C32C7			; read vdp colorregister
	OR	(HL)
	LD	(HL),A
	DEC	BC
	LD	A,C
	OR	B
	JR	Z,J2E84			; all done
	DEC	D
	JR	NZ,J2E71		; next pixel in byte
	INC	HL
	JR	J2E6D

J2E84:	DEC	D
	RET	Z			; byte complete, quit

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C2E86:	LD	A,(HL)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(HL),A
	AND	A
	RET	

J2E8E:	LD	D,4
	LD	(HL),0
J2E92:	LD	A,(HL)
	ADD	A,A
	ADD	A,A
	LD	(HL),A			; shift 2 left
	CALL	C32C7			; read vdp colorregister
	OR	(HL)
	LD	(HL),A
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J2EA4
	OR	E
	JR	Z,J2EAA
	DEC	E
J2EA4:	DEC	D
	JR	NZ,J2E92		; next pixel in byte
	INC	HL
	JR	J2E8E

J2EAA:	DEC	D
	RET	Z			; byte complete, quit
	LD	A,(HL)
J2EAD:	ADD	A,A
	ADD	A,A
	DEC	D
	JR	NZ,J2EAD		; shift 2 left
	LD	(HL),A
	AND	A
	RET	

;	 Subroutine S.BLTVM (blit ram-vram)
;	    Inputs  ________________________
;	    Outputs ________________________

J2EB5:	CALL	C323C
	RET	C
	CALL	C2BE4			; wait until VDP command is done
	LD	A,32			; sx register, autoupdate
	CALL	C32E1			; set VDP controlregister
	PUSH	BC
	LD	HL,BUF+4
	LD	BC,0E9BH
	OTIR
	POP	BC
	LD	A,(HL)
	AND	0FH
	OR	0B0H			; LMMC
	POP	HL
	PUSH	AF
	LD	A,(SCRMOD)
	SUB	06H
	JR	C,J2F05			; screenmode 5, 2 pixels per byte
	JR	Z,J2F47			; screenmode 6, 4 pixels per byte
	DEC	A
	JR	Z,J2F05			; screenmode 7, 2 pixels per byte
	CALL	C32DF			; set vdp controlregister for colorregister
	LD	A,(BUF+74)
	LD	E,A
	AND	A
	CALL	NZ,C331F
	LD	A,(HL)
	OUT	(9BH),A
	POP	AF
	OUT	(99H),A
	LD	A,0AEH
	OUT	(99H),A			; start vdp command
	EI	
J2EF4:	DEC	BC
	LD	A,C
	OR	B
	RET	Z
	INC	HL
	LD	A,E
	AND	A
	CALL	NZ,C331F
	JR	C,J2EF4
	LD	A,(HL)
	OUT	(9BH),A
	JR	J2EF4

J2F05:	CALL	C32DF			; set vdp controlregister for colorregister
	LD	D,0FH
	LD	A,(BUF+74)
	LD	E,A
	AND	A
	CALL	NZ,C331F
	LD	A,(HL)
	RRCA	
	RRCA	
	RRCA	
	RRCA	
	AND	D
	OUT	(9BH),A
	POP	AF
	OUT	(99H),A
	LD	A,0AEH
	OUT	(99H),A
	EI	
J2F22:	DEC	BC
	LD	A,C
	OR	B
	RET	Z
	LD	A,E
	AND	A
	CALL	NZ,C331F
	JR	C,J2F31
	LD	A,(HL)
	AND	D
	OUT	(9BH),A
J2F31:	INC	HL
	DEC	BC
	LD	A,C
	OR	B
	RET	Z
	LD	A,E
	AND	A
	CALL	NZ,C331F
	JR	C,J2F22
	LD	A,(HL)
	RRCA	
	RRCA	
	RRCA	
	RRCA	
	AND	D
	OUT	(9BH),A
	JR	J2F22
;

J2F47:	CALL	C32DF			; set vdp controlregister for colorregister
	LD	D,03H
	LD	A,(BUF+74)
	AND	A
	CALL	NZ,C331F
	LD	A,(HL)
	RLCA	
	RLCA	
	AND	D
	OUT	(9BH),A
	POP	AF
	OUT	(99H),A
	LD	A,0AEH
	OUT	(99H),A
	EI	
J2F61:	DEC	BC
	LD	A,C
	OR	B
	JP	NZ,J2F6A
	OR	E
	RET	Z
	DEC	E
J2F6A:	LD	A,(BUF+74)
	AND	A
	CALL	NZ,C331F
	JR	C,J2F7B
	LD	A,(HL)
	RRCA	
	RRCA	
	RRCA	
	RRCA	
	AND	D
	OUT	(9BH),A
J2F7B:	DEC	BC
	LD	A,C
	OR	B
	JP	NZ,J2F84
	OR	E
	RET	Z
	DEC	E
J2F84:	LD	A,(BUF+74)
	AND	A
	CALL	NZ,C331F
	JR	C,J2F93
	LD	A,(HL)
	RRCA	
	RRCA	
	AND	D
	OUT	(9BH),A
J2F93:	DEC	BC
	LD	A,C
	OR	B
	JP	NZ,J2F9C
	OR	E
	RET	Z
	DEC	E
J2F9C:	LD	A,(BUF+74)
	AND	A
	CALL	NZ,C331F
	JR	C,J2FA9
	LD	A,(HL)
	AND	D
	OUT	(9BH),A
J2FA9:	DEC	BC
	LD	A,C
	OR	B
	JP	NZ,J2FB2
	OR	E
	RET	Z
	DEC	E
J2FB2:	INC	HL
	LD	A,(BUF+74)
	AND	A
	CALL	NZ,C331F
	JR	C,J2F61
	LD	A,(HL)
	RLCA	
	RLCA	
	AND	D
	OUT	(9BH),A
	JP	J2F61

;	 Subroutine multiply
;	    Inputs  ________________________
;	    Outputs ________________________

C2FC5:	LD	HL,0
	LD	A,16
	AND	A
J2FCB:	PUSH	AF
	ADD	HL,HL
	JR	NC,J2FD2
	POP	AF
	SCF	
	PUSH	AF
J2FD2:	EX	DE,HL
	ADD	HL,HL
	EX	DE,HL
	JR	NC,J2FDD
	ADD	HL,BC
	JR	NC,J2FDD
	POP	AF
	SCF	
	PUSH	AF
J2FDD:	POP	AF
	DEC	A
	JR	NZ,J2FCB
	RET	

;	 Subroutine S.BLTMD (blit disk to ram)
;	    Inputs  ________________________
;	    Outputs ________________________

J2FE2:	PUSH	HL
	CALL	C322E			; parse filespec and check if diskdrive
	POP	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	LD	E,0			; flag read
	JR	J2FFA

;	 Subroutine S.BLTDM (blit ram to disk)
;	    Inputs  ________________________
;	    Outputs ________________________

J2FEF:	PUSH	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL			; FNPTR (adres of the filename)
	CALL	C322E			; parse filespec and check if diskdrive
	POP	HL
	LD	E,1			; flag write
J2FFA:	PUSH	DE
	LD	C,(HL)
	INC	HL
	LD	B,(HL)			; starting adres
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; ending adres
	EX	DE,HL
	AND	A
	SBC	HL,BC
	INC	HL			; size of transfer
	POP	DE
	PUSH	DE
	CALL	C3344			; open file
	POP	DE
	DEC	E
	PUSH	AF
	CALL	NZ,C33E3		; read, read from file
	POP	AF
	CALL	Z,C33CB			; write, write whole buffer to file
	CALL	C33FD			; close file
	AND	A
	RET	

;	 Subroutine S.BLTVD (blit disk to vram)
;	    Inputs  ________________________
;	    Outputs ________________________

J301B:	PUSH	HL
	CALL	C322E			; parse filespec and check if diskdrive
	LD	HL,0			; flag use free basic space
	LD	E,L			; flag read
	CALL	C3344			; open file
	CALL	C33E3			; read from file
	LD	(BUF+23),HL
	LD	DE,(BUF+19)
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	DEC	HL
	CALL	C323C
	JR	C,J3066
	CALL	C2BE4			; wait until VDP command is done
	LD	A,32			; sx register, autoupdate
	CALL	C32E1			; set VDP controlregister
	PUSH	BC
	LD	HL,BUF+4
	LD	BC,0E9BH
	OTIR	
	POP	BC
	LD	A,(HL)
	AND	0FH
	OR	0B0H			; LMMC
	LD	HL,I3065
	EX	(SP),HL			; finish routine
	PUSH	AF
	LD	A,(SCRMOD)
	SUB	6
	JR	C,J308F			; screenmode 5, 2 pixels per byte
	JP	Z,J30CF			; screenmode 6, 4 pixels per byte
	DEC	A
	JR	Z,J308F			; screenmode 7, 2 pixels per byte
	JR	J306C			; screenmode 8, 1 pixel per byte

I3065:	AND	A
J3066:	PUSH	AF
	CALL	C33FD			; close file
	POP	AF
	RET

J306C:	CALL	C32DF			; set vdp controlregister for colorregister
	CALL	C331A
	LD	A,(HL)
	OUT	(9BH),A
	POP	AF
	OUT	(99H),A
	LD	A,0AEH
	OUT	(99H),A
	EI	
J307D:	DEC	BC
	LD	A,C
	OR	B
	RET	Z
	INC	HL
	CALL	C31EC
	CALL	C331A
	JR	C,J307D
	LD	A,(HL)
	OUT	(9BH),A
	JR	J307D

J308F:	CALL	C32DF			; set vdp controlregister for colorregister
	LD	D,00H
	CALL	C331A
	LD	A,(HL)
	RRCA	
	RRCA	
	RRCA	
	RRCA	
	AND	0FH
	OUT	(9BH),A
	POP	AF
	OUT	(99H),A
	LD	A,0AEH
	OUT	(99H),A
	EI	
J30A8:	INC	D
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J30B1
	OR	E
	RET	Z
	DEC	E
J30B1:	CALL	C31EC
	LD	A,D
	RRCA	
	LD	A,(HL)
	INC	HL
	JR	C,J30BF
	DEC	HL
	RRCA	
	RRCA	
	RRCA	
	RRCA	
J30BF:	PUSH	AF
	CALL	C331A
	JR	C,J30CC
	POP	AF
	AND	0FH
	OUT	(9BH),A
	JR	J30A8

J30CC:	POP	AF
	JR	J30A8

J30CF:	CALL	C32DF			; set vdp controlregister for colorregister
	LD	D,00H
	CALL	C331A
	LD	A,(HL)
	RLCA	
	RLCA	
	AND	03H
	OUT	(9BH),A
	POP	AF
	OUT	(99H),A
	LD	A,0AEH
	OUT	(99H),A
	EI	
J30E6:	INC	D
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J30EF
	OR	E
	RET	Z
	DEC	E
J30EF:	CALL	C31EC
	LD	A,D
	AND	03H
	JR	Z,J310A
	DEC	A
	JR	Z,J3112
	DEC	A
	JR	Z,J310D
	CALL	C331A
	JR	C,J3107
	LD	A,(HL)
	AND	03H
	OUT	(9BH),A
J3107:	INC	HL
	JR	J30E6

J310A:	LD	A,(HL)
	JR	J3115

J310D:	LD	A,(HL)
	RRCA	
	RRCA	
	JR	J3117

J3112:	LD	A,(HL)
	RLCA	
	RLCA	
J3115:	RLCA	
	RLCA	
J3117:	PUSH	AF
	CALL	C331A
	JR	C,J3124
	POP	AF
	AND	03H
	OUT	(9BH),A
	JR	J30E6

J3124:	POP	AF
	JR	J30E6

;	 Subroutine S.BLTDV (blit vram to disk)
;	    Inputs  ________________________
;	    Outputs ________________________

J3127:	PUSH	HL
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	PUSH	HL
	CALL	C322E
	LD	HL,0			; flag use free basic space
	LD	E,1			; flag write
	CALL	C3344			; open file
	LD	DE,(BUF+19)
	POP	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	POP	HL
	CALL	C3293
	LD	A,(SCRMOD)
	SUB	06H
	JR	C,J3160
;
	JR	Z,J319A
;
	DEC	A
	JR	Z,J3160
;
J3150:	CALL	C3205
;
	CALL	C32C7			; read vdp colorregister
;
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J3150
;
	JP	J31E3
;

J3160:	LD	D,00H
J3162:	CALL	C3205
	LD	A,7
	DI	
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 7
	PUSH	HL
	POP	HL
	LD	A,D
	RRCA	
	IN	A,(99H)			; read vdp colorregister
	JR	NC,J317B
	OR	(HL)
	LD	(HL),A
	INC	HL
	JR	J3180

J317B:	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	(HL),A
J3180:	XOR	A
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 0
	EI	
	INC	D
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J3162
	OR	E
	JR	Z,J3194
	DEC	E
	JR	J3162
;

J3194:	LD	A,D
	RRCA	
	JR	C,J31E4
;
	JR	J31E3
;

J319A:	LD	D,00H
J319C:	CALL	C3205
;
	LD	A,7
	DI	
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 7
	PUSH	HL
	POP	HL
	LD	A,D
	AND	03H
	JR	Z,J31BC
	DEC	A
	JR	Z,J31C2
	DEC	A
	IN	A,(99H)			; read vdp colorregister
	JR	Z,J31C6
;
	OR	(HL)
	LD	(HL),A
	INC	HL
	JR	J31CA
;

J31BC:	IN	A,(99H)			; read vdp colorregister
	RRCA	
	RRCA	
	JR	J31C9

J31C2:	IN	A,(99H)			; read vdp colorregister
	RLCA	
	RLCA	
J31C6:	RLCA	
	RLCA	
	OR	(HL)
J31C9:	LD	(HL),A
J31CA:	XOR	A
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 0
	EI	
	INC	D
	DEC	BC
	LD	A,C
	OR	B
	JR	NZ,J319C
	OR	E
	JR	Z,J31DE
	DEC	E
	JR	J319C

J31DE:	LD	A,D
	AND	03H	; 3 
	JR	NZ,J31E4
;
J31E3:	DEC	HL
J31E4:	CALL	C3223
	CALL	C33FD			; close file
	AND	A
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C31EC:	PUSH	DE
	PUSH	HL
	LD	HL,(BUF+19)
	LD	DE,(BUF+23)
	ADD	HL,DE
	EX	DE,HL
	POP	HL
	RST	S.DCOMPR
	POP	DE
	RET	C
	PUSH	BC
	PUSH	DE
	CALL	C33E3			; read from file
	LD	(BUF+23),HL
	JR	J321D
;

;
;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________
;
C3205:	PUSH	DE
	PUSH	HL
	LD	HL,(BUF+19)
	LD	DE,(BUF+21)
	ADD	HL,DE
	EX	DE,HL
	POP	HL
	RST	S.DCOMPR
	POP	DE
	RET	C
	LD	HL,(BUF+21)		; size of buffer
	PUSH	BC
	PUSH	DE
	CALL	C33CE			; write to file
	AND	A
J321D:	POP	DE
	POP	BC
	LD	HL,(BUF+19)
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3223:	LD	DE,(BUF+19)		; start of buffer
	AND	A
	SBC	HL,DE
	INC	HL			; size
	JP	C33CE			; write to file and quit

;	 Subroutine parse filespec and check if diskdrive
;	    Inputs  ________________________
;	    Outputs ________________________

C322E:	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	CALL	C27D0			; parse filespec
	LD	A,D
	CP	09H
	RET	C			; diskdrive, quit
	JP	J2732			; no diskdrive, bad filename

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C323C:	LD	HL,(BUF+4)		; DPTR, adres of array
	LD	C,(HL)
	INC	HL
	LD	B,(HL)			; NX
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			; NY
	INC	HL
	CALL	C32E9			; validate NX and NY
	RET	C			; illegal, quit
	PUSH	HL
	PUSH	BC
	PUSH	DE
	LD	HL,(BUF+8)		; DX
	LD	A,(BUF+17)
	AND	04H
	JR	NZ,J3260		; ARG
	EX	DE,HL
	CALL	C330D			; get maximum X
	AND	A
	SBC	HL,DE
	DEFB	03EH			; LD A,xx skip next instruction
J3260:	INC	HL
	LD	(BUF+66),HL
	LD	(BUF+68),HL
	LD	D,B
	LD	E,C
	EX	DE,HL
	SBC	HL,DE
	JR	NC,J3271
	LD	HL,0
J3271:	LD	(BUF+70),HL
	LD	(BUF+72),HL
	LD	A,H
	OR	L
	LD	(BUF+74),A
	POP	DE
	POP	BC
	LD	(BUF+12),BC
	LD	(BUF+14),DE
	CALL	C2FC5			; multiply
	LD	B,H
	LD	C,L
	LD	A,00H
	ADC	A,A
	LD	E,A
	AND	A			; EBC = size
	POP	HL
	EX	(SP),HL
	JP	(HL)

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3293:	CALL	C2BE4			; wait until VDP command is done
	LD	A,32			; sx register, autoupdate
	CALL	C32E1			; set VDP controlregister
	LD	HL,BUF+4
	LD	BC,0E9BH
	OTIR	
	LD	A,0A0H
	OUT	(C),A			; LMCM
	EI	
	LD	BC,(BUF+12)		; NX
	LD	DE,(BUF+14)		; NY
	LD	HL,(BUF+8)		; DPTR
	LD	(HL),C
	INC	HL
	LD	(HL),B
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	INC	HL
	PUSH	HL
	CALL	C2FC5			; multiply
	LD	B,H
	LD	C,L
	LD	A,0
	ADC	A,A
	LD	E,A			; EBC=size
	POP	HL
	RET	

;	 Subroutine read vdp colorregister (status register 7)
;	    Inputs  ________________________
;	    Outputs ________________________

C32C7:	DI	
	LD	A,7
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrol register 7
	PUSH	HL
	POP	HL			; wait
	IN	A,(99H)			; read vdp statusregister
	PUSH	AF
	XOR	A
	OUT	(99H),A
	LD	A,8FH
	OUT	(99H),A			; vdp statuscontrolregister 0
	POP	AF
	EI	
	RET	

;	 Subroutine set vdp controlregister to colorregister
;	    Inputs  ________________________
;	    Outputs ________________________

C32DF:	LD	A,44+128		; colorregister, no update

;	 Subroutine set VDP controlregister
;	    Inputs  ________________________
;	    Outputs ________________________

C32E1:	DI	
	OUT	(99H),A
	LD	A,91H
	OUT	(99H),A
	RET	
;


;	 Subroutine validate NX and NY
;	    Inputs  BC=NX,DE=NY
;	    Outputs ________________________

C32E9:	LD	A,B
	OR	C
	SCF	
	RET	Z
	LD	A,D
	OR	E
	SCF	
	RET	Z
	PUSH	HL
	PUSH	DE
	LD	E,C
	LD	D,B
	CALL	C330D			; get maximum X
	RST	S.DCOMPR
	POP	DE
	POP	HL
	RET	C
	PUSH	HL
	LD	A,(MODE)
	AND	10H
	LD	HL,212
	JR	Z,J330A
	LD	HL,256
J330A:	RST	S.DCOMPR
	POP	HL
	RET	

;	 Subroutine get maximum X
;	    Inputs  ________________________
;	    Outputs ________________________

C330D:	LD	HL,256
	LD	A,(SCRMOD)
	AND	06H
	CP	06H
	RET	NZ
	INC	H
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C331A:	LD	A,(BUF+74)
	AND	A
	RET	Z

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C331F:	PUSH	HL
	LD	HL,(BUF+68)
	LD	A,L
	OR	H
	JR	Z,J332D
	DEC	HL
	LD	(BUF+68),HL
	POP	HL
	RET	

J332D:	LD	HL,(BUF+72)
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,J333E
	LD	HL,(BUF+66)
	LD	(BUF+68),HL
	LD	HL,(BUF+70)
J333E:	LD	(BUF+72),HL
	POP	HL
	SCF	
	RET	

;	 Subroutine open file
;	    Inputs  HL=size (0 specifies free basic space), BC=start
;	    Outputs ________________________

C3344:	LD	A,(H.PHYD+0)
	CP	0C9H
	JP	Z,J274A			; PHYDIO hook not initialized, illegal function call
	PUSH	BC
	PUSH	HL
	XOR	A
	LD	(BUF+75),A		; flag use FCBs
	LD	C,6FH
	PUSH	DE
	CALL	C3409			; Get MSXDisk version
	POP	DE
	OR	A
	JR	NZ,J3369		; error, version 1.x
	LD	A,B
	CP	2
	JR	C,J3369			; version 1.x
	LD	A,1
	LD	(BUF+75),A		; flag use FDs
	JP	J3410

;	 Subroutine open file for FCB (MSXDisk 1.x)
;	    Inputs  ________________________
;	    Outputs ________________________

J3369:	LD	HL,BUF+25
	PUSH	HL
	LD	(HL),D
	LD	A,E
	AND	A			; read or write ?
	PUSH	AF
	EX	DE,HL
	INC	DE
	LD	HL,FILNAM
	LD	BC,11
	LDIR	
	XOR	A
	LD	B,19H
J337E:	LD	(DE),A
	INC	DE
	DJNZ	J337E			; create FCB
	POP	AF
	POP	DE
	PUSH	AF
	LD	C,0FH
	JR	Z,J338B			; read, open file (FCB)
	LD	C,16H			; write, create file (FCB)
J338B:	CALL	C3409			; BDOS
	INC	A
	JR	NZ,J3399		; no error,
	POP	AF
	JP	Z,J2762			; error on read, file not found
	LD	E,67
	JR	J33FA			; error on write, error 67 (too many files)

J3399:	LD	HL,1
	LD	(BUF+39),HL		; recordsize=1
J339F:	POP	AF
	POP	HL			; size
	POP	DE			; start
	LD	A,H
	OR	L
	JR	NZ,J33C0		; size<>0, use the given startadres
	LD	HL,0FE00H
	ADD	HL,SP			; 512 bytes stackspace
	JR	NC,J33B9		; ?? (only when stackpointer is 0000H-01FFH, impossible)
	LD	DE,(STREND)
	AND	A
	SBC	HL,DE
	JR	C,J33B9			; less then 512 bytes free, use NULBUF
	LD	A,H
	AND	A
	JR	NZ,J33C0		; free space>255 bytes, use free space
J33B9:	LD	DE,(NULBUF)
	LD	HL,256			; use the NULBUF, size=256
J33C0:	LD	(BUF+19),DE		; save DTA adres
	LD	(BUF+21),HL		; save size of buffer
	LD	C,1AH
	JR	C3409			; set DTA and quit

;	 Subroutine write whole buffer to file
;	    Inputs  ________________________
;	    Outputs ________________________

C33CB:	LD	HL,(BUF+21)		; size of buffer

;	 Subroutine write to file
;	    Inputs  HL=size
;	    Outputs ________________________

C33CE:	LD	A,(BUF+75)
	OR	A
	JP	NZ,J346A
	LD	DE,BUF+25
	LD	C,26H
	CALL	C3409			; random block write (FCB)
	AND	A
	RET	Z			; no error, quit
	LD	E,66
	JR	J33FA			; error, error 66

;	 Subroutine read from file
;	    Inputs  ________________________
;	    Outputs ________________________

C33E3:	LD	A,(BUF+75)
	OR	A
	JP	NZ,J3480
	LD	HL,(BUF+21)
	LD	DE,BUF+25
	LD	C,27H
	CALL	C3409			; random block read (FCB)
	LD	A,L
	OR	H
	RET	NZ			; have read something, quit
	LD	E,55
J33FA:	JP	J27DC			; have read nothing, error 55

;	 Subroutine close file
;	    Inputs  ________________________
;	    Outputs ________________________

C33FD:	LD	A,(BUF+75)
	OR	A
	JP	NZ,C3494
	LD	DE,BUF+25
	LD	C,10H			; close file (FCB)

;	 Subroutine BDOS with mainrom invoked
;	    Inputs  ________________________
;	    Outputs ________________________

C3409:	LD	IX,M.7FFD
	JP	C0262			; call mainrom

;	 Subroutine open file for FD (MSXDisk 2.x)
;	    Inputs  ________________________
;	    Outputs ________________________

J3410:	LD	A,E
	OR	A
	PUSH	AF
	LD	C,43H
	JR	Z,J341A			; read, open filehandle
	LD	BC,0044H		; write, create filehandle
J341A:	XOR	A
	LD	DE,(D$F33B)
	CALL	C3409			; BDOS
	OR	A
	LD	HL,BUF+76
	LD	(HL),B
	JP	Z,J339F
	POP	DE
J342B:	LD	E,51
	SUB	0B8H
	JP	C,J27DC			; error 51
	CP	28H
	JP	NC,J27DC		; error 51
	LD	C,A
	LD	B,00H
	LD	HL,I3442
	ADD	HL,BC
	LD	E,(HL)
	JP	J27DC			; error

; translation table for BDOS errors to basic errors

I3442:	DEFB	033H,033H,033H,033H,033H,033H,033H,033H
	DEFB	033H,033H,033H,033H,005H,033H,041H,037H
	DEFB	03CH,033H,036H,033H,005H,005H,038H,033H
	DEFB	033H,048H,033H,033H,042H,043H,04AH,035H
	DEFB	038H,035H,038H,03EH,033H,033H,033H,033H

J346A:	LD	A,(BUF+76)
	LD	B,A
	LD	DE,(BUF+19)
	LD	C,49H
	CALL	C3409			; write to filehandle
	OR	A
	RET	Z
J3479:	PUSH	AF
	CALL	C3494
	POP	AF
	JR	J342B
;

J3480:	LD	A,(BUF+76)
	LD	B,A
	LD	DE,(BUF+19)
	LD	HL,(BUF+21)
	LD	C,48H
	CALL	C3409			; read from filehandle
	OR	A
	JR	NZ,J3479
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3494:	LD	A,(BUF+76)
	LD	B,A
	LD	C,45H
	JP	C3409			; close filehandle



; ******************************************
; End Section Blit
; ******************************************



; ******************************************
; Begin Section Mouse/Trackball
; ******************************************



;	 Subroutine S.NEWPAD
;	    Inputs  ________________________
;	    Outputs ________________________

J349D:	CP	12
	JR	C,J34C3			; not for mouse/trackball (lightpen), not supported
	LD	E,0FH			; register 15
	LD	BC,00BFH
	LD	HL,10EFH		; port 1 pulse set and reset mask
	CP	0CH
	JR	Z,J34C5			; read mouse/trackball on port 1
	LD	BC,40FFH
	LD	HL,20DFH		; port 2 pulse set and reset mask
	CP	10H
	JR	Z,J34C5			; read mouse/trackball on port 2
	AND	03H
	SUB	02H
	LD	A,(XSAVE)
	RET	M			; read X-offset option, quit
	LD	A,(YSAVE)
	RET	Z			; read Y-offset option, quit
					; other codes have no function
J34C3:	XOR	A
	RET	

J34C5:	DI	
	CALL	C357A			; reset 250 kHz counter
	CALL	C354C			; reset puls bit
	CALL	C3561			; read 4 inputbits (used in case of a trackball ?)
	PUSH	AF
	CALL	C3552			; set puls bit
	LD	D,45
	CALL	C355E			; at 0.18 ms since counterreset and read 4 inputbits (DX7-DX4)
	PUSH	AF
	CALL	C354C			; reset puls bit
	LD	D,75
	CALL	C355E			; at 0.29 ms since counterreset and read 4 inputbits (DX3-DX0)
	PUSH	AF
	CALL	C3552			; set puls bit
	LD	D,105
	CALL	C355E			; at 0.41 ms since counterreset and read 4 inputbits (DY7-DY4)
	PUSH	AF
	CALL	C354C			; reset puls bit
	LD	D,135
	CALL	C355E			; at 0.53 ms since counterreset and read 4 inputbits (DY3-DY0)
	PUSH	AF
	CALL	C3552			; set puls bit
	LD	D,180
	CALL	C355E			; at 0.70 ms since counterreset and read 4 inputbits (second DX7-DX4)
	PUSH	AF
	CALL	C354C			; reset puls bit (second DX3-DX0 is send, but not read)
	LD	D,200
	CALL	C357D			; at 0.78 ms since counterreset
	CALL	C3552			; set puls bit (second DY7-DY4 is send, but not read)
	LD	D,220
	CALL	C357D			; at 0.86 ms since counterreset 
	CALL	C354C			; reset puls bit (second DY3-DY0 is send, but not read)
	EI	
	POP	AF
	POP	HL			; H=DY3-DY0
	POP	DE			; D=DY7-DY4
	POP	BC			; B=DX3-DX0
	XOR	08H			; "second" DX7-DX4 correct sign
	SUB	02H
	CP	0DH			; MSX-mouse protocol (Second DX7-DX4 not too big) ?
	JR	C,J352A			; yep, mouse
					; otherwise it is a trackball (not sure!)
	POP	AF			; state after puls = DY
	CALL	C3544			; convert trackballdata to offset
	LD	(YSAVE),A
	POP	AF			; state before puls = DX
	CALL	C3544			; convert trackballdata to offset
	JR	J353E

J352A:	LD	A,D
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	H			; DY
	NEG				; was send negative
	LD	(YSAVE),A
	POP	AF			; A=DX7-DX4
	POP	DE
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	OR	B			; DX
	NEG				; was send negative
J353E:	LD	(XSAVE),A
	LD	A,0FFH
	RET	

;	 Subroutine convert trackballdata to offset
;	    Inputs  ________________________
;	    Outputs ________________________

C3544:	XOR	08H			; complement sign
	BIT	3,A
	RET	Z
	OR	0F0H			; make negative
	RET	

;	 Subroutine reset puls bit
;	    Inputs  ________________________
;	    Outputs ________________________

C354C:	CALL	C3569			; read psg register with masks
	AND	L
	JR	J3556			; write psg register

;	 Subroutine set puls bit
;	    Inputs  ________________________
;	    Outputs ________________________

C3552:	CALL	C3569			; read psg register with masks
	OR	H
J3556:	PUSH	AF
	LD	A,E
	OUT	(0A0H),A
	POP	AF
	OUT	(0A1H),A		; write psg register
	RET	

;	 Subroutine wait until ticks has passed since counter reset and read 4 inputbits
;	    Inputs  ________________________
;	    Outputs ________________________

C355E:	CALL	C357D			; wait until ticks has passed

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3561:	LD	A,14
	CALL	C356A			; read psg register 14 with masks
	AND	0FH
	RET	

;	 Subroutine read psg register with masks
;	    Inputs  E = register, C=AND mask, B=OR mask
;	    Outputs ________________________

C3569:	LD	A,E

;	 Subroutine read psg register with masks
;	    Inputs  A = register, C=AND mask, B=OR mask
;	    Outputs ________________________

C356A:	OUT	(0A0H),A
	IN	A,(0A2H)
	AND	C
	OR	B
	RET

;	 Subroutine wait 1 ms
;	    Inputs  C = ticks
;	    Outputs ________________________

J3571:	OUT	(0E6H),A
J3573:	IN	A,(0E7H)
	CP	C
	JP	C,J3573
	RET

;	 Subroutine reset 255681 Hz counter
;	    Inputs  ________________________
;	    Outputs ________________________

C357A:	OUT	(0E6H),A
	RET	

;	 Subroutine wait until ticks passed since counter reset
;	    Inputs  D = ticks (0.004 ms)
;	    Outputs ________________________

C357D:	IN	A,(0E6H)
	CP	D
	JP	C,C357D
	RET	


;	 Subroutine wait util 0.027 ms passed
;	    Inputs  D = ticks
;	    Outputs ________________________
;	    Remark  UNUSED CODE

?.3584:	OUT	(0E6H),A
J3586:	IN	A,(0E6H)
	CP	7
	JP	C,J3586
	RET	



; ******************************************
; End Section Mouse/Trackball
; ******************************************



;	 Subroutine SET VIDEO statement
;	    Inputs  ________________________
;	    Outputs ________________________

C358E:	CP	","
	JR	Z,J35CE			; mode parameter not specified,
	RST	S.GETBYT
	CP	04H
	JR	NC,J3614		; mode must be 0-3, illegal function call
	AND	A
	JR	Z,J35A1			; mode = computer, internal sync
	CP	1
	JR	Z,J35A1			; mode = computer, external sync
	LD	E,00H
	DEC	A
J35A1:	PUSH	DE
	RRCA	
	RRCA	
	LD	D,A
	RRCA	
	RRCA	
	LD	E,A
	LD	A,(RG9SAV)
	AND	0CFH
	OR	E
	LD	C,9
	CALL	C3693			; write vdp register 9
	LD	A,D
	XOR	0C0H
	LD	E,A
	LD	A,3FH
	CALL	C3640			; change b7 and b6 digitizehardware settings
	POP	DE
	LD	A,E
	RRCA	
	RRCA	
	RRCA	
	LD	E,A
	LD	A,(RG8SAV)
	AND	0DFH
	OR	E
	CALL	C3691			; write vdp register 8
	DEC	HL
	RST	S.CHRGTR
	RET	Z
J35CE:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J35DF			; brightness parameter not specified,
	CALL	C364B			; evaluate brightness on/off parameter
	LD	A,0DFH
	CALL	C3640			; change b5 digitizehardware setting
	DEC	HL
	RST	S.CHRGTR
	RET	Z
J35DF:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","			; colorbus parameter not specified,
	JR	Z,J35F6
	CALL	C364B			; evaluate colorbus direction parameter
	RRC	E			; in b4
	LD	A,(RG8SAV)
	AND	0EFH
	OR	E
	CALL	C3691			; write vdp register 8
	DEC	HL
	RST	S.CHRGTR
	RET	Z
J35F6:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J360B			; sync parameter not specified,
	CALL	C364B			; evaluate sync on/off parameter
	RLCA
	RLCA
	RLCA
	LD	E,A			; in b3
	LD	A,0F7H
	CALL	C3640			; change b3 digitizehardware setting
	DEC	HL
	RST	S.CHRGTR
	RET	Z
J360B:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J3623			; mixing parameter not specified,
	RST	S.GETBYT
	CP	4			; must be 0-3
J3614:	JP	NC,J274A		; illegal function call
	CPL	
	AND	03H
	LD	E,A
	LD	A,0FCH
	CALL	C3640			; change b1 and b0 digitizehardware settings
	DEC	HL
	RST	S.CHRGTR
	RET	Z
J3623:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CP	","
	JR	Z,J3637			; video input parameter not specified,
	CALL	C364B			; evaluate on/off parameter
	RLCA
	RLCA
	LD	E,A			; in b2
	LD	A,0FBH
	CALL	C3640			; change b2 digitizehardware setting
	DEC	HL
	RST	S.CHRGTR
	RET	Z
J3637:	RST	S.SYNCHR
	DEFB	","			; check for ,
	CALL	C364B			; evaluate on/off parameter
	RRC	E			; in b3
	LD	A,0EFH			; change b4 digitizehardware setting

;	 Subroutine change digitizehardware setting
;	    Inputs  A=AND mask,E=OR mask
;	    Outputs ________________________

C3640:	PUSH	HL
	LD	HL,AVCSAV
	AND	(HL)
	OR	E
	LD	(HL),A
	OUT	(0F7H),A
	POP	HL
	RET	

;	 Subroutine evaluate on/off parameter
;	    Inputs  ________________________
;	    Outputs Zx set and A=0,E=0 when off, Zx reset and A=1,E=020H when on

C364B:	RST	S.GETBYT
	CP	2
	JR	NC,J3614		; must be 0 or 1, illegal function call
	AND	A
	RET	Z
	LD	E,20H
	RET

;	 Subroutine COPY SCREEN statement
;	    Inputs  ________________________
;	    Outputs ________________________

J3655:	RST	S.CHRGTR
	JR	Z,J3665
	CP	","
	JR	Z,J3665
	CALL	C364B			; evaluate on/off parameter
	DEC	A
	JR	NZ,J3665		; non interlace digitize, use start of any screen display
	LD	E,00H			; flag use start of odd screen display
	DEFB	001H			; skip next instruction
J3665:	LD	E,02H			; flag use start of any screen display
	DEC	HL
	RST	S.CHRGTR
	LD	A,0FFH
	JR	Z,J3672			; 2nd parameter not specified,
	PUSH	DE
	RST	S.SYNCHR
	DEFB	","			; check for ,
	RST	S.GETBYT
	POP	DE
J3672:	LD	D,A
	LD	A,(RG7SAV)
	PUSH	AF
	LD	A,D
	CALL	C368D			; write vdp register 7
	CALL	C3697			; wait for start of given screen display
	OR	40H			; DG=1
	CALL	C3693			; write vdp register 0
J3683:	CALL	C3697			; wait for start of given screen display
	EI	
	AND	0BFH			; DG=0
	CALL	C3693			; write vdp register 0
	POP	AF			; restore vdp register 7

;	 Subroutine write vdp register 7
;	    Inputs  A = data
;	    Outputs ________________________

C368D:	LD	C,7
	JR	C3693

;	 Subroutine write vdp register 8
;	    Inputs  A = data
;	    Outputs ________________________

C3691:	LD	C,8

;	 Subroutine write vdp register
;	    Inputs  C = vdp register, A = data
;	    Outputs ________________________

C3693:	LD	B,A
	JP	C0685			; write vdp register

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3697:	LD	A,2
	CALL	C2BEF			; read vdp statusregister 2
	AND	40H
	JR	Z,C3697			; wait for VR
J36A0:	LD	A,2
	CALL	C2BEF			; read vdp statusregister 2
	BIT	6,A
	JR	NZ,J36A0		; wait for VR to finish
	OR	E
	AND	02H
	JR	Z,C3697			; wait for odd screen
	LD	A,(RG0SAV)
	LD	C,0			; setup for write to vdp register 0
	RET	



; ******************************************
; Begin Section Ramdisk
; ******************************************



;
; Ramdisk uses 32Kb RAM at 00000H-7FFFH, which is normaly unusable in MSX-Basic
;
; 0000-0001	size used by ramdisk (also start of the unused area)
; 0002-007F	not used
; 0080-00FF	"FAT", 128 entries of 1 byte
; 0100-02FF	"DIR", 32 entries of 16 bytes
; 0300-		"DATA", clusters of 256 bytes





;	 Subroutine subrom device handler
;	    Inputs  ________________________
;	    Outputs ________________________

I36B4:	EI	
	INC	A
	JR	NZ,J36BE		; not the unknown devicecode, do device function
J36B8:	CALL	C38BD			; check if MEM or MEM0 devicename
	RET	Z			; yep, flag device recognized
	SCF	
	RET				; flag device not recognized
;

J36BE:	PUSH	HL
	LD	HL,I36CD-1
	ADD	A,L
	LD	L,A
	JR	NC,J36C7
	INC	H
J36C7:	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	EX	(SP),HL
	RET	
;

I36CD:	DEFW	C3904			; open
	DEFW	C398B			; close
	DEFW	C384A			; random, bad file mode
	DEFW	C39AF			; seq output
	DEFW	C3A0D			; seq input
	DEFW	C3829			; loc
	DEFW	C3834			; lof
	DEFW	C3847			; eof
	DEFW	C3868			; fpos
	DEFW	C3A59			; putback

;	 Subroutine CALL MEMINI statement
;	    Inputs  ________________________
;	    Outputs ________________________

C36E1:	DEC	HL
	RST	S.CHRGTR
	LD	DE,7FFFH
	JR	Z,J36F3			; use 32767 as default
	RST	S.SYNCHR
	DEFB	"("			; check for (
	CALL	C281E			; evaluate integer
	JP	M,J274A			; >32767, illegal function call
	RST	S.SYNCHR
	DEFB	")"			; check for )
	RET	NZ			; not end of statement, quit (which generates syntax error)
J36F3:	PUSH	HL
	PUSH	DE
	LD	A,(SLTWRK+0)
	AND	A			; ram memini searched ?
	JR	Z,J3701			; nope, ´search´ ram
	BIT	5,A			; ramdisk disabled ?
	JR	NZ,J3708		; yep, illegal function call
	JR	J370B

J3701:	LD	A,RAMSID
	LD	(SLTWRK+0),A		; slotid ram, ramdisk invalid, ramdisk enabled
	JR	J370B

J3708:	JP	J274A			; illegal function call

J370B:	BIT	6,A			; ramdisk valid ?
	JR	Z,J3726			; nope, skip file open detection
	LD	IX,0100H
	LD	B,32			; 32 files
J3715:	CALL	C3A69			; read fileentry ramdisk
	LD	A,(LINWRK+13)
	AND	A
	JP	NZ,J3B8A		; file open, file still open error
	LD	DE,0010H
	ADD	IX,DE
	DJNZ	J3715
J3726:	POP	HL
	XOR	A
	LD	DE,03FFH
	SBC	HL,DE
	JR	C,J3795			; ramdisk size <1023, no ramdisk
	INC	H
	PUSH	HL
	LD	B,80H
	LD	C,A			; C=0
	DEC	A			; A=FF
J3735:	INC	C
	CALL	C3A7D			; write fatentry ramdisk (mark as used)
	DJNZ	J3735
	LD	B,H			; number of clusters
	XOR	A
	LD	C,A			; C=0
J373E:	INC	C
	CALL	C3A7D			; write fatentry ramdisk (mark as unused)
	DJNZ	J373E
	LD	HL,LINWRK
	LD	DE,LINWRK+1
	LD	C,16-1
	LD	(HL),B
	LDIR	
	LD	IX,0100H
	LD	B,32
J3755:	CALL	C3A6A			; write fileentry ramdisk
	LD	DE,0010H
	ADD	IX,DE
	DJNZ	J3755
	LD	HL,SLTWRK+0
	SET	6,(HL)			; ramdisk valid
	POP	HL
	LD	L,B
	PUSH	HL
	CALL	C27E2			; print number
	CALL	C3820
	DEFM	' bytes allocated',13,10,0	; print text
	POP	HL
	INC	H
	INC	H
	INC	H
	LD	(LINWRK),HL
	LD	HL,LINWRK
	LD	DE,0000H
	LD	BC,2
	CALL	C3AFB			; copy to ramdisk
	POP	HL
	RET	

J3795:	XOR	A
	LD	(SLTWRK+0),A		; no ramdisk
	CALL	C3820
	DEFM	'No RAM disk',13,10,0	; print text
	POP	HL
	RET	

;	 Subroutine CALL MFILES statement
;	    Inputs  ________________________
;	    Outputs ________________________

C37AC:	CALL	C3B8E			; check for valid ramdisk
	CALL	C27C4			; CR/LF to OUTDO if not at start of line
	PUSH	HL
	LD	IX,0100H
	LD	BC,2000H
J37BA:	CALL	C3A69			; read fileentry ramdisk
	LD	HL,LINWRK
	LD	A,(HL)
	AND	A
	JR	Z,J37F2
	INC	C
	PUSH	IX
	PUSH	BC
	LD	B,8
	CALL	C381A			; print filename
	LD	A,(HL)
	CP	" "
	JR	Z,J37D4
	LD	A,"."			; has filenameextension, print "."
J37D4:	RST	S.OUTDO
	LD	B,3
	CALL	C381A
	LD	A,(LINLEN)
	LD	B,A
	LD	A,(TTYPOS)
	AND	A
	JR	Z,J37EF
	ADD	A,0CH
	CP	B
	JR	NC,J37EC
	LD	A," "
	RST	S.OUTDO
J37EC:	CALL	NC,C27C4		; CR/LF to OUTDO if not at start of line
J37EF:	POP	BC
	POP	IX
J37F2:	LD	DE,0010H
	ADD	IX,DE
	DJNZ	J37BA
	LD	A,C
	OR	A
	JP	Z,J2762			; file not found
	CALL	C27C4			; CR/LF to OUTDO if not at start of line
	CALL	C3868			; mem device fpos
	CALL	C27E2			; print number
	CALL	C3820
	DEFM	' bytes free',13,10,0	; print text
	POP	HL
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C381A:	LD	A,(HL)
	INC	HL
	RST	S.OUTDO
	DJNZ	C381A
	RET	

;	 Subroutine print text
;	    Inputs  ________________________
;	    Outputs ________________________

C3820:	EX	(SP),HL
	LD	A,(HL)
	INC	HL
	EX	(SP),HL
	AND	A
	RET	Z
	RST	S.OUTDO
	JR	C3820

;	 Subroutine mem device loc
;	    Inputs  ________________________
;	    Outputs ________________________

C3829:	PUSH	HL
	POP	IY
	LD	H,(IY+5)		; highbyte=sectorcount (=256 of size)
	LD	L,(IY+6)		; lowbyte=filebufferpos
	JR	J3877

;	 Subroutine mem device lof
;	    Inputs  ________________________
;	    Outputs ________________________

C3834:	CALL	C3A60			; read fileentry ramdisk of filecontrolblock
	PUSH	HL
	POP	IY
	LD	A,(HL)
	CP	01H
	LD	HL,(LINWRK+14)
	JR	Z,J3877			; input mode,
	LD	L,(IY+6)
	JR	J3877

;	 Subroutine mem device eof
;	    Inputs  ________________________
;	    Outputs ________________________

C3847:	LD	A,(HL)
	CP	01H
C384A:	LD	E,61
	JP	NZ,J3B96		; bad file mode error
	PUSH	HL
	POP	IY
	CALL	C3A60			; read fileentry ramdisk of filecontrolblock
	LD	L,(IY+6)
	LD	H,(IY+5)
	LD	DE,(LINWRK+14)
	RST	S.DCOMPR
	LD	HL,0FFFFH
	JR	NC,J3877
	INC	HL
	JR	J3877

;	 Subroutine mem device fpos
;	    Inputs  ________________________
;	    Outputs ________________________

C3868:	LD	BC,07D01H
	LD	HL,0
J386E:	CALL	C3A7C			; read fatentry ramdisk
	JR	NZ,J3874
	INC	H
J3874:	INC	C
	DJNZ	J386E
J3877:	LD	(DAC+2),HL
	LD	A,2
	LD	(VALTYP),A		; integer type
	RET

;	 Subroutine CALL MKILL statement
;	    Inputs  ________________________
;	    Outputs ________________________

C3880:	CALL	C38A2			; check for valid ramdisk and parse ramdiskfilespec
	RST	S.SYNCHR
	DEFB	")"			; check for )
	CALL	C3B82			; check for filename and not open

;	 Subroutine delete file from ramdisk
;	    Inputs  ________________________
;	    Outputs ________________________

C3888:	LD	(LINWRK),A
	CALL	C3A6A			; write fileentry ramdisk
	LD	A,(LINWRK+11)
	AND	A
	RET	Z
J3893:	LD	C,A
	CALL	C3A7C			; read fatentry ramdisk
	PUSH	AF
	XOR	A
	CALL	C3A7D			; write fatentry ramdisk
	POP	AF
	CP	0FFH
	JR	NZ,J3893
	RET

;	 Subroutine check for valid ramdisk and parse ramdiskfilespec
;	    Inputs  ________________________
;	    Outputs ________________________

C38A2:	RST	S.SYNCHR
	DEFB	"("			; check for (
	CALL	C3B8E			; check for valid ramdisk

;	 Subroutine parse ramdiskfilespec
;	    Inputs  ________________________
;	    Outputs ________________________

C38A7:	CALL	C27D0			; parse filespec
	RET	Z
	LD	A,D
	CP	0FCH
	JR	NC,J38BA		; standard devices,
	CP	09H
	JR	C,J38BA			; diskdrive,
	PUSH	HL
	CALL	C38BD			; check if MEM or MEM0 devicename
	POP	HL
	RET	Z			; yep, quit
J38BA:	JP	J2732			; bad filename

;	 Subroutine check if MEM or MEM0 devicename
;	    Inputs  ________________________
;	    Outputs ________________________

C38BD:	LD	HL,PROCNM
	LD	DE,I38D2
J38C3:	LD	A,(DE)
	CP	(HL)
	JR	NZ,J38CD
	INC	HL
	INC	DE
	OR	A
	JR	NZ,J38C3
	RET	
J38CD:	SUB	"0"
	RET	NZ
	OR	(HL)
	RET	

I38D2:	DEFB	"MEM0",0

;	 Subroutine CALL MNAME statement
;	    Inputs  ________________________
;	    Outputs ________________________

C38D7:	CALL	C38A2			; check for valid ramdisk and parse ramdiskfilespec
	CALL	C3B82			; check for filename and not open
	PUSH	IX
	RST	S.SYNCHR
	DEFB	"A"
	RST	S.SYNCHR
	DEFB	"S"			; check for AS
	CALL	C38A7			; parse ramdiskfilespec
	RST	S.SYNCHR
	DEFB	")"			; check for )
	CALL	C3A9E			; search for ´new´ filename
	LD	E,65
	JP	Z,J3B96			; found, file already exists error
	POP	IX
	CALL	C3A69			; read fileentry ramdisk
J38F5:	PUSH	HL
	LD	DE,LINWRK
	LD	HL,FILNAM
	LD	BC,11
	LDIR				; change to new name
	POP	HL
	JR	J3926			; write fileentry ramdisk

;	 Subroutine mem device open
;	    Inputs  ________________________
;	    Outputs ________________________

C3904:	CALL	C3B8E			; check for valid ramdisk
	CALL	C3A9E			; search for filename
	PUSH	AF
	LD	A,E
	CP	4
	JP	Z,J2738			; random mode, sequential io only error
	CP	2
	JR	Z,J3929			; output mode,
	CP	8
	JR	Z,J3962			; append mode,
	POP	AF
	JR	NZ,J3963		; input mode and not found, file not found error
	OR	A
	JR	NZ,J3967		; file open, file already open error
	CALL	C3B67			; initialize filecontrolblock

;	 Subroutine flag file open and write fileentry
;	    Inputs  ________________________
;	    Outputs ________________________

C3922:	DEC	A
	LD	(LINWRK+13),A		; file open flag
J3926:	JP	C3A6A			; write fileentry ramdisk

J3929:	POP	AF
	JR	NZ,J3932		; not found, ok
	OR	A
	JR	NZ,J3967		; found and open, file already open error
	CALL	C3888			; delete file from ramdisk
J3932:	LD	IX,0100H
	LD	B,32
J3938:	CALL	C3A69			; read fileentry ramdisk
	LD	A,(LINWRK)
	AND	A
	JR	Z,J394D			; fileentry unused,
	LD	DE,0010H
	ADD	IX,DE
	DJNZ	J3938
	LD	E,67			; no free fileentries
	JP	J3B96			; too many files error

J394D:	LD	E,2			; output mode
	CALL	C3B67			; initialize filecontrolblock
	LD	HL,LINWRK
	LD	B,16
J3957:	LD	(HL),A
	INC	HL
	DJNZ	J3957			; clear fileentry
	DEC	A
	LD	(LINWRK+13),A		; flag file open
	JP	J38F5			; setup fileentry and write

J3962:	POP	AF
J3963:	JP	NZ,J2762		; not found, file not found error
	OR	A
J3967:	JP	NZ,J273E		; file open, file already open error
	CALL	C3B67			; intialize filecontrolblock
	LD	HL,(LINWRK+14)		; filesize
	LD	(IY+5),H
	LD	(IY+6),L		; is current pos
	LD	L,A
	LD	(LINWRK+14),HL
	CALL	C3922			; flag file open and write fileentry
	LD	A,(LINWRK+11)
	AND	A
	RET	Z			; no startcluster, quit
	LD	A,(LINWRK+12)
	LD	(IY+7),A		; end cluster = current cluster
	JP	C3AE2			; read filecluster ramdisk

;	 Subroutine mem device close
;	    Inputs  ________________________
;	    Outputs ________________________

C398B:	CALL	C3A60			; read fileentry ramdisk of filecontrolblock
	XOR	A
	LD	(LINWRK+13),A		; flag file not open
	CALL	C3A6A			; write fileentry ramdisk
	LD	A,(HL)
	CP	01H
	RET	Z			; input mode, quit
	PUSH	HL
	POP	IY
	LD	A,(IY+6)
	AND	A
	RET	Z			; filebufferpos 0 (nothing to write), quit
	CALL	C3AE3			; write filecluster ramdisk
	LD	HL,(LINWRK+14)
	LD	L,(IY+6)
	LD	(LINWRK+14),HL
	JR	J3A0B

;	 Subroutine mem device sequential output
;	    Inputs  ________________________
;	    Outputs ________________________

C39AF:	PUSH	HL
	POP	IY
	LD	A,(IY+6)
	AND	A
	JR	NZ,J39EE		; buffer not full, fill buffer
	PUSH	HL
	PUSH	BC
	CALL	C3A60			; read fileentry ramdisk of filecontrolblock
	LD	BC,07D01H
J39C0:	CALL	C3A7C			; read fatentry ramdisk
	JR	Z,J39CD			; entry unused,
	INC	C
	DJNZ	J39C0
	LD	E,66			; no free fatentries
	JP	J3B96			; ramdisk full error

J39CD:	LD	A,(LINWRK+11)
	AND	A
	LD	A,C
	JR	NZ,J39D7		; file has already a startcluster
	LD	(LINWRK+11),A		; use current as startcluster
J39D7:	LD	C,(IY+7)		; current cluster
	CALL	NZ,C3A7D		; file had a startcluster, write fatentry ramdisk
	LD	(LINWRK+12),A		; update end cluster
	LD	(IY+7),A		; current cluster
	LD	C,A
	LD	A,0FFH			; endmarker
	CALL	C3A7D			; write fatentry ramdisk
	CALL	C3A6A			; write fileentry ramdisk
	POP	BC
	POP	HL
J39EE:	LD	DE,9
	ADD	HL,DE			; buffer
	LD	E,(IY+6)
	ADD	HL,DE			; pointer in buffer
	LD	(HL),C
	INC	(IY+6)			; update filebufferpos
	RET	NZ			; buffer not full, quit
	CALL	C3AE3			; write filecluster ramdisk
	INC	(IY+5)			; update sectorcount
	PUSH	IY
	POP	HL
	CALL	C3A60			; read fileentry ramdisk of filecontrolblock
	LD	HL,LINWRK+15
	INC	(HL)
J3A0B:	JR	C3A6A			; write fileentry ramdisk

;	 Subroutine mem device sequential input
;	    Inputs  ________________________
;	    Outputs ________________________

C3A0D:	PUSH	HL
	PUSH	HL
	POP	IY
	CALL	C3A60			; read fileentry ramdisk of filecontrolblock
	LD	L,(IY+6)
	LD	H,(IY+5)		; current pos
	LD	DE,(LINWRK+14)		; filesize
	RST	S.DCOMPR
	POP	HL
	CCF	
	RET	C			; at end of file, quit
	LD	A,(IY+3)
	AND	A			; putback used ?
	LD	(IY+3),0		; no putback
	RET	NZ			; yep, give back putback char
	LD	A,(IY+6)
	AND	A
	JR	Z,J3A40			; filebufferpos 0, fill buffer
	LD	BC,9
	ADD	HL,BC			; filebuffer
	LD	C,A
	ADD	HL,BC			; filebufferpointer
	LD	A,(HL)			; char
	INC	(IY+6)			; update filebufferpos
	RET	NZ
	INC	(IY+5)			; update sectorcount
	RET	

J3A40:	LD	A,(IY+7)		; current cluster
	AND	A
	LD	C,A
	LD	A,(LINWRK+11)		; start cluster
	CALL	NZ,C3A7C		; fatentry valid, read fatentry ramdisk
	LD	(IY+7),A		; current cluster
	CALL	C3AE2			; read filecluster ramdisk
	LD	A,(IY+9)		; char
	INC	(IY+6)			; update filebufferpos
	AND	A
	RET	

;	 Subroutine mem device putback
;	    Inputs  ________________________
;	    Outputs ________________________

C3A59:	PUSH	HL
	POP	IY
	LD	(IY+3),C
	RET	

;	 Subroutine read fileentry ramdisk of filecontrolblock
;	    Inputs  HL=filecontrolblock
;	    Outputs ________________________

C3A60:	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)			; fileentrypointer
	PUSH	BC
	POP	IX
	DEC	HL
	DEC	HL

; FILEENTRY FORMAT
;
; +0	filename (ascii)
; +11	start cluster
; +12	end cluster
; +13	file open flag
; +14	filesize

;	 Subroutine read fileentry ramdisk
;	    Inputs  IX=fileentrypointer
;	    Outputs ________________________

C3A69:	DEFB	0F6H			; OR xx, skip next instruction

;	 Subroutine write fileentry ramdisk
;	    Inputs  IX=fileentrypointer
;	    Outputs ________________________

C3A6A:	SCF
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	IX
	POP	HL
	LD	DE,LINWRK
	JR	NC,J3A77
	EX	DE,HL
J3A77:	LD	BC,16
	JR	J3A93

;	 Subroutine read fatentry ramdisk
;	    Inputs  C = fatentrynumber (1 based)
;	    Outputs ________________________

C3A7C:	DEFB	0F6H			; OR xx, skip next instruction

;	 Subroutine write fatentry ramdisk
;	    Inputs  C = fatentrynumber (1 based)
;	    Outputs ________________________

C3A7D:	SCF
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	HL,0080H-1
	LD	B,0
	ADD	HL,BC
	LD	DE,LINWRK+16
	POP	AF
	JR	NC,J3A90
	EX	DE,HL
	LD	(HL),A
J3A90:	LD	BC,1
J3A93:	CALL	C3AFB			; copy to/from ramdisk
	POP	BC
	POP	DE
	POP	HL
	LD	A,(LINWRK+16)
	AND	A
	RET	

;	 Subroutine search for filename
;	    Inputs  ________________________
;	    Outputs ________________________

C3A9E:	PUSH	HL
	PUSH	DE
	LD	DE,FILNAM
	LD	B,11
J3AA5:	LD	A,(DE)
	CP	"a"
	JR	C,J3AB1
	CP	"z"+1
	JR	NC,J3AB1
	AND	0DFH
	LD	(DE),A			; upcase
J3AB1:	INC	DE
	DJNZ	J3AA5
	LD	IX,0100H
	LD	C,32
J3ABA:	CALL	C3A69			; read fileentry ramdisk
	LD	HL,LINWRK
	LD	A,(HL)
	AND	A
	JR	NZ,J3ACF		; fileentry in use, check filename
J3AC4:	LD	DE,0010H
	ADD	IX,DE
	DEC	C
	JR	NZ,J3ABA
	INC	C
	JR	J3ADC

J3ACF:	LD	DE,FILNAM
	LD	B,11
J3AD4:	LD	A,(DE)
	CP	(HL)
	JR	NZ,J3AC4		; filename not equal, next entry
	INC	DE
	INC	HL
	DJNZ	J3AD4
J3ADC:	POP	DE
	POP	HL
	LD	A,(LINWRK+13)		; file open flag in Zx
	RET	

;	 Subroutine read filecluster ramdisk
;	    Inputs  HL=filecontrolblock
;	    Outputs ________________________

C3AE2:	DEFB	0F6H			; OR xx, skip next instruction

;	 Subroutine write filecluster ramdisk
;	    Inputs  HL=filecontrolblock
;	    Outputs ________________________

C3AE3:	SCF
	PUSH	AF
	PUSH	IY
	POP	HL
	LD	BC,9
	ADD	HL,BC			; buffer
	LD	E,0
	LD	A,(IY+7)		; current cluster
	ADD	A,2
	LD	D,A
	POP	AF
	JR	C,J3AF8
	EX	DE,HL
J3AF8:	LD	BC,256

;	 Subroutine copy to/from ramdisk
;	    Inputs  HL = source, DE = dest, BC = size
;	    Outputs ________________________

C3AFB:	LD	A,H
	AND	A
	JP	P,J3B01			; source is ramdisk,
	LD	A,D			; dest is ramdisk
J3B01:	CP	40H
	EXX	
	LD	HL,D.FFFF
	LD	A,(SLTWRK+0)
	LD	D,A			; slotid ram of ramdisk
	JR	C,J3B48			; page 0, special actions to avoid crash
	RRCA	
	RRCA	
	AND	0C0H
	LD	C,A
	RRCA	
	RRCA	
	RRCA	
	RRCA	
	OR	C
	LD	C,A
	IN	A,(0A8H)
	LD	B,A
	AND	33H
	OR	C
	LD	E,A
	DI	
	OUT	(0A8H),A		; page 1 and 3 to primary slot of ramdisk ram
	LD	A,D
	AND	0CH
	LD	D,A
	LD	A,(HL)
	CPL	
	LD	C,A
	AND	0F3H
	OR	D
	LD	(HL),A			; page 1 to secundairy slot of ramdisk ram
	LD	A,E
	AND	3FH
	LD	D,A
	LD	A,B
	AND	0C0H
	OR	D
	EI	
	OUT	(0A8H),A		; restore primary slot of page 3
	EXX	
	LDIR				; copy data
	EXX	
	LD	A,E
	DI	
	OUT	(0A8H),A		; page 1 and 3 to primary slot of ramdisk ram
	LD	A,C
	LD	(HL),A			; restore secundary slotreg
	LD	A,B
	EI	
	OUT	(0A8H),A		; restore primary slotreg
	EXX	
	RET	

J3B48:	RRCA	
	RRCA	
	AND	0C0H
	LD	C,A
	LD	A,D
	AND	03H
	OR	C
	LD	C,A
	IN	A,(0A8H)
	LD	B,A
	AND	3CH
	OR	C
	LD	E,A
	LD	A,D
	RRCA	
	RRCA	
	AND	03H
	LD	D,A
	LD	A,E
	DI	
	CALL	M.51D7			; helper routine in basic rom, to switch subrom away
	EI	
	EXX	
	RET	

;	 Subroutine initialize filecontrolblock
;	    Inputs  HL=pointer to Filecontrolblock,E=filemode,IX=fileentrypointer
;	    Outputs ________________________

C3B67:	PUSH	HL
	POP	IY
	PUSH	IX
	POP	BC
	LD	(IY+1),C
	LD	(IY+2),B		; fileentrypointer
	XOR	A
	LD	(IY+3),A		; no backup char
	LD	(IY+5),A		; sectorcount=0
	LD	(IY+6),A		; bufferpos=0
	LD	(PTRFIL),HL
	LD	(HL),E			; filemode
	RET	

;	 Subroutine check for filename and not open
;	    Inputs  ________________________
;	    Outputs ________________________

C3B82:	CALL	C3A9E			; search for filename
	JP	NZ,J2762		; not found, file not found error
	AND	A
	RET	Z			; not open, quit
J3B8A:	LD	E,64
	JR	J3B96			; file still open error

;	 Subroutine check for valid ramdisk
;	    Inputs  ________________________
;	    Outputs ________________________

C3B8E:	LD	A,(SLTWRK+0)
	BIT	6,A			; ramdisk valid ?
	RET	NZ			; yep, quit
	LD	E,70			; ramdisk offline error
J3B96:	XOR	A
	LD	(NLONLY),A
	PUSH	DE
	CALL	C27D6			; close io buffer 0
	POP	DE
	JP	J27DC			; error



; ******************************************
; End Section Ramdisk
; ******************************************



;	 Subroutine extended errorhandler
;	    Inputs  HL = errortext pointer, E=errorcode
;	    Outputs HL = errortext pointer, E=errorcode

I3BA2:	LD	BC,I3BC5
J3BA5:	LD	A,(BC)
	INC	BC
	OR	A
	RET	Z			; not a errorcode I know, quit
	SUB	E
	JR	Z,J3BB0
	INC	BC
	INC	BC
	JR	J3BA5			; try next

J3BB0:	LD	L,C
	LD	H,B
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	HL,BUF
	PUSH	HL
	LD	(HL),A
J3BBA:	INC	DE
	INC	HL
	LD	A,(DE)
	LD	(HL),A
	OR	A
	JR	NZ,J3BBA		; copy errortext in BUF
	POP	HL			; new errortext pointer is BUF
	LD	E,1			; first errortext
	RET

I3BC5:	DEFB	61
	DEFW	D3BD7-1
	DEFB	64
	DEFW	D3BE5-1
	DEFB	65
	DEFW	D3BF5-1
	DEFB	66
	DEFW	D3C09-1
	DEFB	67
	DEFW	D3C17-1
	DEFB	70
	DEFW	D3C26-1
	DEFB	0

D3BD7:	DEFM	'Bad file mode',00H
D3BE5:	DEFM	'File still open',00H
D3BF5:	DEFM	'File already exists',00H
D3C09:	DEFM	'RAM disk full',00H
D3C17:	DEFM	'Too many files',00H
D3C26:	DEFM	'RAM disk offline',00H



; *************************************
; PUTCHR and KYKLOK
; *************************************

	IF	KEYTYP EQ 0

; Japanese version

;
; routine to handle special keys (non letter) in SHIFT KANA mode
;

J3C38:	LD	HL,KANAMD
	INC	(HL)
	DEC	(HL)
	LD	B,8
	LD	DE,I3EDF
	LD	HL,I3ECF
	JR	Z,J3C4A			; ANSI layout
	LD	HL,I3ED7		; JIS layout
J3C4A:	CP	(HL)
	JR	Z,J3C57			; found, use replacement
	INC	HL
	INC	DE
	DJNZ	J3C4A
J3C51:	CALL	C3E62			; put in keyboardbuffer
	JP	J3D58			; reset sequence

J3C57:	LD	A,(DE)
	JR	J3C51

;	 Subroutine S.PUTCHR
;	    Inputs  ________________________
;	    Outputs ________________________

J3C5A:	PUSH	AF
	CALL	C3E78			; keyclick
	POP	AF
	JR	Z,J3C66			; functionkey, no conversion
	LD	HL,MODE
	BIT	0,(HL)			; in SHIFT KANA mode ?
J3C66:	JP	Z,C3E62			; nope, just put in keyboardbuffer
	CP	"A"
	JR	C,J3C38
	CP	"Z"+1
	JR	C,J3C7D			; uppercase letter
	CP	"a"
	JR	C,J3C38
	CP	"z"+1
	JR	NC,J3C38
	RES	7,(HL)			; lowercase letter
	JR	J3C7F

J3C7D:	SET	7,(HL)
J3C7F:	CP	"a"
	JR	C,J3C85
	SUB	20H			; make uppercase
J3C85:	LD	D,A
	CP	"X"
	JR	Z,J3CA6
	LD	A,(CHRCNT)
	OR	A			; busy in sequence ?
	JR	NZ,J3CAB		; yep,
	LD	A,D
	CALL	C3DC0			; vowel ?
	LD	A,D
	JP	NZ,C3E47		; yep,
	CALL	C3DB1
	CP	80H
	RET	NC			; does not do anything
	LD	A,D
	LD	(ROMA+0),A		; save for later
	LD	A,1
	JR	J3CE6			; charcount = 1 and quit

J3CA6:	LD	A,0B0H
	JP	J3C51			; put in keyboardbuffer

J3CAB:	DEC	A
	LD	A,D			; 2nd in sequence ?
	JR	NZ,J3CE8		; nope, 3rd in sequence
J3CAF:	LD	E,A
	CALL	C3DC0			; vowel ?
	LD	A,(ROMA+0)
	JR	Z,J3CBD			; nope,
	CALL	C3DCE
	JR	J3CC9

J3CBD:	CP	E
	JR	NZ,J3CD0
	CP	"N"
	JR	NZ,J3CCC
	LD	A,0FDH
	CALL	C3E4D			; put in keyboardbuffer with case
J3CC9:	JP	J3D58			; reset sequence

J3CCC:	LD	A,8FH
	JR	J3CDE

J3CD0:	CP	"N"
	LD	A,E
	JR	NZ,J3CE1
	CP	"Y"
	JR	Z,J3CE1
	LD	(ROMA+0),A
	LD	A,0FDH
J3CDE:	JP	C3E4D			; put in keyboardbuffer with case

J3CE1:	LD	(ROMA+1),A
	LD	A,2
J3CE6:	JR	J3D59

J3CE8:	LD	HL,ROMA
	LD	D,(HL)
	INC	HL
	LD	B,(HL)
	LD	C,A
	PUSH	BC
	CALL	C3DC0			; vowel ?
	POP	BC
	JR	NZ,J3D03		; yep,
	LD	A,B
	LD	(ROMA),A
	LD	A,01H	; 1 
	LD	(CHRCNT),A
	LD	A,C
	JP	J3CAF

J3D03:	LD	A,B
	CP	"Y"
	JR	NZ,J3D2E
	LD	A,D
	CP	"C"
	JR	Z,J3D21
	CP	"L"
	JR	Z,J3D52
	CP	"F"
	JR	Z,J3D2A
	CP	"W"
	JR	Z,J3D83
	LD	E,"I"
	PUSH	BC
	CALL	C3DCE
	JR	J3D27

J3D21:	LD	A,0E1H
J3D23:	PUSH	BC
	CALL	C3E4D			; put in keyboardbuffer with case
J3D27:	POP	BC
	JR	J3D52

J3D2A:	LD	A,0ECH
	JR	J3D23

J3D2E:	LD	A,B
	CP	"H"
	JR	NZ,J3D6D
	LD	A,D
	CP	"C"
	JR	Z,J3D48
	CP	"D"
	JR	Z,J3D5D
	CP	"T"
	JR	Z,J3D66
	CP	"S"
	JR	NZ,J3D83
	LD	A,9CH
	JR	J3D4A

J3D48:	LD	A,0E1H
J3D4A:	CALL	C3E4D			; put in keyboardbuffer with case
J3D4D:	LD	A,C
	CP	"I"
	JR	Z,J3D58			; reset sequence and quit
J3D52:	LD	A,"J"
	LD	E,C
	CALL	C3E4A
J3D58:	XOR	A
J3D59:	LD	(CHRCNT),A
	RET	

J3D5D:	LD	A,0E3H
	CALL	C3E4D			; put in keyboardbuffer with case
	LD	A,0DEH
	JR	J3D68

J3D66:	LD	A,0E3H
J3D68:	CALL	C3E4D			; put in keyboardbuffer with case
	JR	J3D52

J3D6D:	LD	A,D
	CP	"T"
	JR	NZ,J3D83
	LD	A,B
	CP	"S"
	JR	NZ,J3D83
	LD	A,C
	CP	"U"
	JR	NZ,J3D83
	LD	A,0E2H
	CALL	C3E4D			; put in keyboardbuffer with case
	JR	J3D58			; reset sequence and quit

J3D83:	LD	A,B
	LD	E,C
	CALL	C3DCE
	JR	J3D58			; reset sequence and quit

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3D8A:	CALL	C3DBA
	LD	B,A
	ADD	A,A
	ADD	A,A
	ADD	A,B			; * 5
	LD	D,A
	LD	A,E
	CALL	C3DC0
	ADD	A,D
	LD	L,A
	LD	A,D
	CP	0FH
	JR	NC,J3DA1
	LD	A,L
	SUB	70H
	RET	

J3DA1:	CP	23H
	JR	NC,J3DA9
	LD	A,L
	SUB	30H
	RET	

J3DA9:	LD	A,L
	SUB	23H
	LD	BC,I3F02
	JR	J3DB4

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3DB1:	LD	BC,D3EE7-040H
J3DB4:	LD	L,A
	LD	H,00H
	ADD	HL,BC
	LD	A,(HL)
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3DBA:	CALL	C3DB1
	AND	0FH
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3DC0:	CALL	C3DB1
	SUB	14H
	CP	01H
	JR	C,J3DCC
	CP	06H			; 15H - 19H
	RET	C
J3DCC:	XOR	A
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3DCE:	LD	D,A
	CALL	C3DB1
	CP	0BH
	JR	NC,J3DD9
	LD	A,D
	JR	J3E1B

J3DD9:	CP	21H	; "!"
	JR	C,J3DE9
	CP	26H	; "&"
	JR	NC,J3DE9
	LD	A,D
	CALL	C3E4A

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3DE5:	LD	A,0DEH
	JR	C3E4D			; put in keyboardbuffer with case

J3DE9:	LD	A,D
	CP	50H	; "P"
	JR	NZ,J3DF8
	LD	A,48H	; "H"
	CALL	C3E4A
	LD	A,0DFH
	JP	C3E4D			; put in keyboardbuffer with case

J3DF8:	CP	4AH	; "J"
	JR	NZ,J3E0A
	LD	A,9CH
	PUSH	DE
	CALL	C3E4D			; put in keyboardbuffer with case
	CALL	C3DE5
	POP	DE
	LD	C,E
	JP	J3D4D

J3E0A:	CP	46H	; "F"
	JR	NZ,J3E1D
	LD	A,0ECH
	PUSH	DE
	CALL	C3E4D			; put in keyboardbuffer with case
J3E14:	POP	DE
	LD	A,E
	CP	55H	; "U"
	RET	Z
J3E19:	LD	A,4CH	; "L"
J3E1B:	JR	C3E4A

J3E1D:	CP	59H	; "Y"
	JR	NZ,J3E27
	CALL	C3E4A
	LD	A,E
	JR	J3E33

J3E27:	CP	57H	; "W"
	JR	NZ,J3E38
	CALL	C3E4A
	LD	A,E
	CP	49H	; "I"
	JR	Z,J3E19
J3E33:	CP	45H	; "E"
	RET	NZ
	JR	J3E19

J3E38:	CP	56H	; "V"
	JR	NZ,J3E48
	LD	A,55H	; "U"
	PUSH	DE
	CALL	C3E47
	CALL	C3DE5
	JR	J3E14

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3E47:	LD	E,A
J3E48:	LD	A,"Q"

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3E4A:	CALL	C3D8A

;	 Subroutine put in keyboardbuffer with case
;	    Inputs  ________________________
;	    Outputs ________________________

C3E4D:	LD	HL,MODE
	BIT	7,(HL)			; lowercase entered ?
	JR	Z,C3E62			; yep, just put in keyboardbuffer
	CP	0E0H
	JR	C,J3E5C
	SUB	20H
	JR	C3E62

J3E5C:	CP	0A0H
	JR	NC,C3E62
	ADD	A,20H

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3E62:	LD	HL,(PUTPNT)
	LD	(HL),A
	INC	HL
	LD	A,L
	CP	(KEYBUF+40) AND 255
	JR	NZ,J3E6F
	LD	HL,KEYBUF
J3E6F:	LD	A,(GETPNT)
	CP	L
	RET	Z
	LD	(PUTPNT),HL
	RET	

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3E78:	LD	A,(CLIKSW)
	AND	A
	RET	Z
	LD	A,(CLIKFL)
	AND	A
	RET	NZ
	LD	A,0FH
	LD	(CLIKFL),A
	DI	
	OUT	(0ABH),A
	LD	A,0AH
J3E8C:	DEC	A
	JR	NZ,J3E8C		; wait 0.05 ms (in Z80 mode!)
	LD	A,0EH
	OUT	(0ABH),A
	EI	
	RET	

;	 Subroutine S.KYKLOK
;	    Inputs  ________________________
;	    Outputs ________________________

J3E95:	LD	HL,MODE
	BIT	0,(HL)			; SHIFT KANA mode ?
	JR	Z,J3EA1			; nope,
	RES	0,(HL)			; leave SHIFT KANA mode
	XOR	A
	JR	J3EBA

J3EA1:	LD	A,(KANAST)
	INC	A
	JR	Z,J3EB7			; KANA currently on, KANA off
I3EA7:	LD	A,(NEWKEY+6)
	RRCA	
	JR	C,J3EB5			; no KANA + SHIFT, KANA on
	XOR	A
	LD	(CHRCNT),A
	SET	0,(HL)			; SHIFT KANA mode
	JR	J3EBA			; kana led off

J3EB5:	LD	A,0FFH
J3EB7:	LD	(KANAST),A
					; setup kana led
J3EBA:	PUSH	AF
	LD	A,15
	OUT	(0A0H),A
	IN	A,(0A2H)
	AND	7FH
	LD	B,A
	POP	AF
	OR	A
	LD	A,80H
	JR	Z,J3ECB
	XOR	A
J3ECB:	OR	B
	OUT	(0A1H),A
	RET	
;
; ANSI layout
;
I3ECF:	DEFB	"*:]_?>{}"
;
; JIS layout
;
I3ED7:	DEFB	"\@>?[<{}"
;
; replacement table
;
I3EDF:	DEFB	0B0H,0DEH,0A1H,0A5H,0DFH,0A4H,0A2H,0A3H


D3EE7:	DEFB	00AH,015H,025H,028H,023H,018H,040H,021H
	DEFB	005H,016H,04BH,001H,00AH,006H,004H,019H
	DEFB	028H,080H,008H,002H,003H,017H,040H,049H
	DEFB	08CH,047H,022H

I3F02:	DEFB	0FDH,0F4H,092H,0F5H,092H,0F6H,0F7H,0F8H
	DEFB	0F9H,0FAH,0FBH,0FCH,093H,093H,093H,086H
	DEFB	087H,088H,089H,08AH,08BH,08CH,088H,08DH
	DEFB	08AH,08EH

	ENDIF

	IF	KEYTYP NE 0

; International version, officially not needed

;	 Subroutine PUTCHR
;	    Inputs  ________________________
;	    Outputs ________________________

J3C5A:	PUSH	AF
	CALL	C3E78			; keyclick
	POP	AF

;	 Subroutine __________________________
;	    Inputs  ________________________
;	    Outputs ________________________

C3E62:	LD	HL,(PUTPNT)
	LD	(HL),A
	INC	HL
	LD	A,L
	CP	(KEYBUF+40) AND 255
	JR	NZ,J3E6F
	LD	HL,KEYBUF
J3E6F:	LD	A,(GETPNT)
	CP	L
	RET	Z
	LD	(PUTPNT),HL
	RET	

;	 Subroutine KYKLOK
;	    Inputs  ________________________
;	    Outputs ________________________

J3E95:	LD	A,(NEWKEY+6)
	LD	E,A
	OR	0FEH			; only SHIFT status remains
	BIT	4,E
	JR	NZ,J3E96		; CODE not pressed,
	AND	0FDH
J3E96:	CPL	
	INC	A
	LD	(KANAST),A		; dead status



;	 Subroutine keyclick
;	    Inputs  ________________________
;	    Outputs ________________________

C3E78:	LD	A,(CLIKSW)
	AND	A
	RET	Z
	LD	A,(CLIKFL)
	AND	A
	RET	NZ
	LD	A,0FH
	LD	(CLIKFL),A
	DI	
	OUT	(0ABH),A
	LD	A,0AH
J3E8C:	DEC	A
	JR	NZ,J3E8C		; wait 0.05 ms (in Z80 mode!)
	LD	A,0EH
	OUT	(0ABH),A
	EI	
	RET

	ENDIF

; *************************************
; End of PUTCHR and KYKLOK
; *************************************
;



;	 Subroutine copies kanji and subrom to ´shadow´ ram
;	    Inputs  ________________________
;	    Outputs ________________________

C3F1C:	LD	A,0FEH
	OUT	(0FEH),A		; switch last-1 mapperpage in page 2
	LD	HL,0000H
	LD	DE,8000H
	LD	BC,4000H
	LDIR				; copy subrom
	IN	A,(0A8H)
	LD	B,A
	OR	044H*(KANSID AND 3)
	OUT	(0A8H),A		; slot 3 in page 1 and page 3 (page 3 needed for sec. slot)
	LD	A,(D.FFFF)
	CPL	
	LD	C,A
	AND	0F3H
	OR	(KANSID AND 12)
	LD	(D.FFFF),A		; sec. slot 1 in page 1 (so page 1 has slot 3-1)
	EXX	
	LD	A,0FFH
	OUT	(0FEH),A		; switch last mapperpage in page 2
	LD	HL,4000H
	LD	DE,8000H
	LD	BC,4000H
	LDIR				; copy kanji-rom
	LD	A,1
	OUT	(0FEH),A		; restore mapperpage in page 2
	EXX	
	LD	A,C
	LD	(D.FFFF),A		; restore sec. slot page 1
	LD	A,B
	OUT	(0A8H),A		; restore prm. slot page 1
	RET	


	IF	MSXMID EQ 1

;	 Subroutine initialize PCM sampler
;	    Inputs  ________________________
;	    Outputs ________________________

C3F5B:	LD	A,80H
	OUT	(0A4H),A
	LD	A,03H
	OUT	(0A5H),A
	RET

	ENDIF

	DEFS	04000H-$,0
	
	END
