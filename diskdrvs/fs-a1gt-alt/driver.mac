; Diskdriver Panasonic FS-A1GT
; Alternate version without SROM/SRAM drive support
;
; FDC	TC8566AF
; extra	S1990 hardware for Disk Change

; Source re-created by Z80DIS 2.2
; Z80DIS was written by Kenneth Gielow, Palo Alto, CA

; Code Copyrighted by Panasonic and maybe others
; Source comments by Arjen Zeilemaker

; Sourcecode supplied for STUDY ONLY
; Recreation NOT permitted without authorisation of the copyrightholders


MYSIZE	EQU	31		; size of environment
SECLEN	EQU	512		; size of biggest supported sector

L73C9:	DB	0F8h
	DW	512
	DB	00Fh
	DB	004h
	DB	001h
	DB	002h
	DW	1
	DB	2
	DB	112
	DW	12
	DW	355
	DB	2
	DW	5

L73DB:	DB	0F9h
	DW	512
	DB	00Fh
	DB	004h
	DB	001h
	DB	002h
	DW	1
	DB	2
	DB	112
	DW	14
	DW	714
	DB	3
	DW	7

	DB	0FAh
	DW	512
	DB	00Fh
	DB	004h
	DB	001h
	DB	002h
	DW	1
	DB	2
	DB	112
	DW	10
	DW	316
	DB	1
	DW	3

	DB	0FBh
	DW	512
	DB	00Fh
	DB	004h
	DB	001h
	DB	002h
	DW	1
	DB	2
	DB	112
	DW	10
	DW	635
	DB	2
	DW	5

	DB	0FCh
	DW	512
	DB	00Fh
	DB	004h
	DB	000h
	DB	001h
	DW	1
	DB	2
	DB	64
	DW	9
	DW	352
	DB	2
	DW	5

	DB	0FDh
	DW	512
	DB	00Fh
	DB	004h
	DB	001h
	DB	002h
	DW	1
	DB	2
	DB	112
	DW	12
	DW	355
	DB	2
	DW	5

	DB	0FEh
	DW	512
	DB	00Fh
	DB	004h
	DB	000h
	DB	001h
	DW	1
	DB	2
	DB	64
	DW	7
	DW	314
	DB	1
	DW	3

	DB	0FFh
	DW	512
	DB	00Fh
	DB	004h
	DB	001h
	DB	002h
	DW	1
	DB	2
	DB	112
	DW	10
	DW	318
	DB	1
	DW	3

DEFDPB	EQU	L73DB-1		; default DPB is 720 Kb 3.5"



; DSKIO
;
; Reads or writes sectors

DSKIO:	EI
	PUSH	AF
	JP	NC,L7550	; read sectors
	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	CALL	L749B		; do the write operation
	POP	HL
	POP	DE
	POP	BC
	JR	C,L7480		; error, finish dskio
	LD	(IX+5),02H	; only verify
	POP	AF
	AND	A		; read/verify operation
	CALL	L7556		; execute operation
	RES	1,(IX+5)	; reset verify
	PUSH	DE
L7480:	POP	DE
L7481:	EI
	POP	DE
	PUSH	AF
	LD	C,60		; 1 sec
	JR	NC,L748A
	LD	C,0		; 0 sec
L748A:	LD	A,D
	AND	A
	CALL	L7867		; motor off
	JR	NZ,L7496	; drive 1
	LD	(IX+1),C
	POP	AF
	RET
L7496:	LD	(IX+2),C
	POP	AF
	RET

L749B:	CALL	L75EB		; init dskio
	RET	C		; error, quit
	CALL	DISINT
	DI			; disable ints
	PUSH	HL
	LD	HL,ENAINT
	EX	(SP),HL		; after this, enable ints
	LD	A,H
	AND	A		; 8000-FFFF ?
	JP	M,L74DA		; direct transport
	SCF			; write operation
	CALL	L79FC		; copy routine in SECBUF and execute this
	RET	C		; error, quit
	INC	B
	DEC	B
	RET	Z		; 0 sectors, all done, quit
	LD	A,H
	AND	A
	JP	M,L74DA		; now in the page 2 area, direct transport
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	DE,($SECBUF)
	PUSH	DE
	LD	BC,512
	CALL	XFER		; transport sector data to SECBUF
	POP	HL
	POP	BC
	POP	DE
	CALL	L74D1		; write sector (with ready signal)
	POP	HL
	JR	L74DD

L74D1:	CALL	L785F		; normal ready
	CALL	L74E5		; write sector
	JP	L75AA		; force ready

L74DA:	CALL	L74D1		; write sector (with ready signal)
L74DD:	RET	C		; error, quit
	DEC	B
	RET	Z		; all done, quit
	CALL	L78AE		; init for next sector
	JR	L74DA		; again

L74E5:	LD	E,11
L74E7:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	DE,L751E	; cont routine
	PUSH	DE
	LD	DE,L7993	; wait 16.5 ms routine
	PUSH	DE
	LD	(IX+10),045H	; WRITE DATA
	LD	B,9
	CALL	L7921		; write bytes to controller
	LD	DE,L7FF4
	LD	B,0		; 256 bytes
L7500:	LD	A,(DE)
	ADD	A,A
	JP	NC,L7500	; wait for Request
	ADD	A,A
	RET	P		; end of Execution
	LD	A,(HL)
	LD	(L7FF5),A
	INC	HL
	DJNZ	L7500
L750E:	LD	A,(DE)
	ADD	A,A
	JP	NC,L750E
	ADD	A,A
	RET	P
	LD	A,(HL)
	LD	(L7FF5),A
	INC	HL
	DJNZ	L750E
	POP	BC
	POP	BC
L751E:	CALL	L799C		; Terminal Count
	CALL	L797B		; read bytes from controller
	POP	BC
	POP	DE
	POP	HL
	LD	A,(IX+19)	; ST0
	AND	0C8H
	RET	Z		; No error AND ready, quit
	AND	008H
	JP	NZ,L754C	; Not ready, quit
	BIT	1,(IX+20)
	JR	NZ,L7549	; Write protect, quit
	CALL	L78DF		; Reposition
	DEC	E
	JR	NZ,L74E7	; next try
	SCF
	BIT	4,(IX+19)
	LD	A,00AH
	RET	NZ		; Equipment Check, quit with Other error
	JP	L79AB		; error from ST1

L7549:	XOR	A
	SCF
	RET

L754C:	LD	A,2
	SCF
	RET

L7550:	CALL	L7556		; execute operation
	JP	L7481		; finish dskio

L7556:	CALL	L75EB		; init dskio
	RET	C
	CALL	DISINT
	DI			; disable ints
	PUSH	HL
	LD	HL,ENAINT
	EX	(SP),HL		; ret to enable ints
	LD	A,H
	AND	A
	JP	M,L75B0		; direct access
	CALL	L79FC		; copy routine in SECBUF and execute this
	RET	C		; error, quit
	INC	B
	DEC	B
	RET	Z		; 0 sectors, all done, quit
	LD	A,H
	AND	A
	JP	M,L75B0		; now in the page 2 area, direct transport
	BIT	1,(IX+5)
	JR	NZ,L7596	; it's a verify,
	PUSH	HL
	LD	HL,($SECBUF)
	CALL	L75A4		; read sector (with ready) in SECBUF
	POP	HL
	RET	C		; error, quit
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	DE,($SECBUF)
	EX	DE,HL
	LD	BC,512
	CALL	XFER		; transfer SECBUF to transfer adres
	POP	BC
	POP	DE
	POP	HL
	JR	L75BF		; next ?
L7596:	CALL	L759C		; verify sector (with ready)
	RET	C		; error, quit
	JR	L75BF		; next

L759C:	CALL	L785F		; normal ready
	CALL	L75C6		; read/verify sector
	JR	L75AA		; normal ready

L75A4:	CALL	L785F		; normal ready
	CALL	L75C6		; read/verify sector
L75AA:	PUSH	AF
	CALL	L7863		; forced ready
	POP	AF
	RET

L75B0:	BIT	1,(IX+5)
	JR	Z,L75BB		; no verify
	CALL	L759C		; verify sector (with ready)
	JR	L75BE		; next ?

L75BB:	CALL	L75A4		; read sector (with ready)
L75BE:	RET	C		; error, quit
L75BF:	DEC	B
	RET	Z		; all done, quit
	CALL	L78AE		; init for next sector
	JR	L75B0		; again

L75C6:	LD	E,11
L75C8:	BIT	1,(IX+5)
	JR	Z,L75D3		; no verify, do read
	CALL	L7871		; verify data
	JR	L75D6

L75D3:	CALL	L79BB		; read data
L75D6:	LD	A,(IX+19)
	AND	0C8H
	RET	Z		; no error and ready, quit
	AND	008H
	JP	NZ,L754C
	CALL	L78DF		; Reposition
	DEC	E
	JR	NZ,L75C8	; next try
	SCF
	JP	L79AB		; error from ST1

L75EB:	PUSH	AF
	PUSH	BC
	PUSH	HL
	CALL	GETWRK		; GETWRK
	POP	HL
	POP	BC
	POP	AF
	RES	0,(IX+5)
	JR	NC,L75FE
	SET	0,(IX+5)	; write operation
L75FE:	CP	2		; Check driveid
	JR	C,L7606		; valid, continue
L7602:	LD	A,12
	SCF
	RET
L7606:	PUSH	AF
	LD	A,C
	CP	0F8H		; Check mediabyte
	JR	NC,L760F	; valid, continue
	POP	AF
	JR	L7602		; other error

L760F:	POP	AF
	PUSH	IX
	PUSH	BC
	PUSH	DE
	PUSH	AF
	LD	A,(IX+7)
	DEC	A
	JR	NZ,L762F	; double drive system
	POP	AF
	LD	B,0
	PUSH	BC
	CP	(IX+3)		; same logical drive
	JR	Z,L762F		; yes,
	LD	(IX+3),A
	CALL	L7867		; motor off
	PUSH	HL
	CALL	PROMPT		; PROMPT
	POP	HL
L762F:	POP	AF
	POP	DE
	POP	BC
	POP	IX
	LD	(IX+15),002H	; Sectorsize = 512
	LD	(IX+16),009H	; lastsector = 9
	LD	(IX+17),050H	; Gapsize = 80 bytes
	LD	(IX+18),0FFH	; Datalength
	PUSH	HL
	PUSH	AF
	PUSH	BC
	BIT	1,C		; 8 sectors/track ?
	LD	C,E
	LD	B,D
	LD	DE,8
	JR	NZ,L7651	; yeah
	INC	DE		; 9 sectors/track
L7651:	CALL	DIV16		; DIV16
	INC	L
	LD	(IX+14),L	; Record
	LD	L,C
	POP	BC
	POP	AF
	LD	(IX+11),A	; Unit
	AND	A
	LD	A,014H		; motor enable #0, normal operation, select drv 0
	JR	Z,L7665
	LD	A,025H		; motor enable #1, normal operation, select drv 1
L7665:	LD	H,A
	LD	D,A
	BIT	0,C		; double sided ?
	JR	Z,L7679
	SRL	L		; track on side
	JR	NC,L7679
	SET	2,(IX+11)	; Head 1
	LD	(IX+13),1	; side 1
	JR	L7681
L7679:	RES	2,(IX+11)	; Head 0
	LD	(IX+13),0	; side 0
L7681:	LD	A,C
	RRCA
	RRCA
	AND	0C0H		; double/8-9 sect
	OR	D
	LD	D,A
	DI
	LD	A,H
	LD	(L7FF2),A	; motor on
	EI
	LD	C,L		; track on side
	CALL	L785F		; normal ready
	CALL	L76CF		; Wait FDD ready
	PUSH	AF
	CALL	L7863		; force ready
	POP	AF
	JR	C,L76BD		; timeout, Not ready error
	BIT	6,A
	JR	Z,L76AA		; not write protect, select track and quit
	BIT	0,(IX+5)
	JR	Z,L76AA		; it is a read/verify operation, select track and quit
	POP	HL		; write protect + write operation!
	XOR	A
	SCF
	RET			; quit with write protect error

L76AA:	INC	C
	DEC	C
	JR	NZ,L76B8	; not track 0
	PUSH	BC
	LD	C,6
	CALL	L7900		; Select Track 6
	CALL	L773B		; Recalibrate
	POP	BC
L76B8:	CALL	L7900		; Select Track
	POP	HL
	RET

L76BD:	POP	HL
	LD	A,2
	RET

L76C1:	PUSH	BC
	LD	BC,52709
L76C5:	EX	(SP),HL
	EX	(SP),HL
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,L76C5
	POP	BC
	RET

L76CF:	LD	(IX+10),004H	; SENSE DRIVE STATUS
	PUSH	BC
	LD	HL,5000
L76D7:	DEC	HL
	LD	A,L
	OR	H
	JR	Z,L76EE
	LD	B,2
	CALL	L7921		; write 2 bytes to controller
	CALL	L797B		; read bytes from controller
	LD	A,(IX+19)
	BIT	5,A
	JR	Z,L76D7		; FDD is not ready
	POP	BC
	AND	A
	RET
L76EE:	POP	BC
	SCF
	RET


; INIHRD
;
; Initializes diskhardware

INIHRD:	LD	HL,0
	ADD	HL,SP
	PUSH	HL
	POP	IY
	LD	DE,16
	XOR	A
	SBC	HL,DE
	LD	SP,HL		; Make workarea (16 bytes) on stack
	INC	HL
	LD	DE,10
	XOR	A
	SBC	HL,DE
	PUSH	HL
	POP	IX
	CALL	L7716		; init FDC
	LD	A,14H		; motor enable drv 0, normal operation, select drv 0
	CALL	L7732		; init drive
	LD	SP,IY		; Restore stack


; DSKSTP
;
; Motor off

DSKSTP:	JP	L7867

L7716:	LD	(L7FF2),A	; reset FDC
	LD	A,0FAH		; 11111010 (enable C6, C6=1, enable C4, C4=1 (force ready), enable C2, no standby, enable C0, no TC)
	LD	(L7FF3),A
	CALL	L7867		; motor off
	LD	(IX+10),003H	; SPECIFY
	LD	(IX+11),0DFH	; HUT 240 ms, SRT 3 ms
	LD	(IX+12),003H	; Non-DMA, HLT 2 ms
	LD	B,3
	JP	L7921		; write 3 bytes to controller

L7732:	LD	(L7FF2),A	; motor on
	LD	(IX+11),A
	CALL	L76C1		; wait 1 second (motor spin up ?)
L773B:	LD	(IX+10),007H	; RECALIBRATE
	LD	B,2
	CALL	L7921		; write 2 bytes to controller
	JP	L7955		; wait for end of seek


; DRIVES
;
; Count the drives connected

DRIVES:	PUSH	BC
	PUSH	AF
	CALL	GETWRK		; GETWRK
	LD	A,025H		; motor enable drv 1, normal operation, select drv 1
	CALL	L7732		; init drive
	LD	L,1
	JR	NC,L7764	; 2 drives connected
	LD	(IX+7),L	; set 1 physical drive
	CALL	L7867		; motor off
	POP	AF
	JR	Z,L775F
	INC	L		; 1 physical must act as 2 logical drives
L775F:	POP	BC
	RET
L7764:	INC	L
	LD	(IX+7),L	; set 2 physical drives
	CALL	L7867		; motor off
	POP	AF
	JR	NZ,L775F
	DEC	L		; only 1 allowed
	JR	L775F


; INIENV
;
; Initializes workarea

; +0
; +1	interrupt down counter drive 0
; +2	interrupt down counter drive 1
; +3	last (logical) floppy drive
; +7	physical floppy drives
; +10	FDC command string
; +19	FDC result string
; +26	b7 option rom, b6 patch rom, b5-b0 patch rom page
; +27	firmware mapper control byte
; +28	firmware mapper bank 4 select
; +29	firmware mapper bank ext select
; +30	

INIENV:	LD	A,1
	LD	(RAWFLG),A	; Verify on
	CALL	GETWRK		; GETWRK
	XOR	A
	LD	B,7
L777C:	LD	(HL),A
	INC	HL
	DJNZ	L777C		; Clear environment area
	LD	HL,L7789
	JP	SETINT		; SETINT


; DSKCHG
;
; Checks if disk was changed

DSKCHG:	EI
	PUSH	HL
	PUSH	BC
	PUSH	AF
	CALL	GETWRK		; GETWRK
	POP	AF
	POP	BC
	POP	HL
	LD	B,(IX+7)
	DEC	B
	JR	NZ,L77BD	; double drive system
	CP	(IX+3)		; logical drive same as last ?
	JR	Z,L77BC		; yep,
	LD	B,0		; disk change unknown
	AND	A
	RET
L77BC:	XOR	A		; physical drive 0
L77BD:	AND	A
	LD	B,010H		; use -DC0
	JR	Z,L77C4		; drive 0
	LD	B,020H		; use -DC1
L77C4:	LD	(IX+11),A
	LD	(IX+10),004H	; SENSE DRIVE STATUS
	CALL	L785F		; normal ready
	PUSH	BC
	LD	B,2
	CALL	L7921		; write 2 bytes to controller
	POP	BC
	JR	C,L77F0		; time out, disk change unknown
L77D7:	LD	A,(L7FF4)
	ADD	A,A
	JR	NC,L77D7	; wait until Request
	LD	A,(L7FF1)
	AND	B		; mask off -DC
	LD	B,A
	CALL	L797B		; read bytes from controller
	LD	A,B
	AND	A
	LD	B,0FFH
	JR	Z,L77ED		; bit was reset, disk changed
	LD	B,1		; disk unchanged
L77ED:	XOR	A
	JR	L77F3		; normal ready
L77F0:	LD	B,0
	AND	A
L77F3:	PUSH	AF
	CALL	L7863		; force ready
	POP	AF
	RET


; GETDPB
;
; Fills in a Drive Parameter Block

GETDPB:	EI
	EX	DE,HL
	INC	DE
	LD	A,B
	SUB	0F8H
	RET	C
	LD	L,A
	LD	H,0
	ADD	HL,HL
	LD	C,L
	LD	B,H
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,L73C9
	ADD	HL,BC
	LD	BC,18
	LDIR
	RET


; CHOICE
;
; Returns pointer to formatoption string

CHOICE:	LD	HL,L7824
	RET

L7824:	DEFB	13,10
	DEFB	"1 - 1 side, double track"
	DEFB	13,10
	DEFB	"2 - 2 sides,double track"
	DEFB	13,10
	DEFB	13,10
	DEFB	0

OEMSTA:	SCF
	RET

L785F:	LD	A,020H
	JR	L786D

L7863:	LD	A,030H
	JR	L786D

L7867:	LD	A,004H
	LD	(L7FF2),A	; all motors off, normal operation, drv 0
	RET

L786D:	LD	(L7FF3),A
	RET

L7871:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	DE,L78A4
L7877:	PUSH	DE
	LD	DE,L7993	; wait 16.5 ms routine
	PUSH	DE
	LD	(IX+10),046H	; READ DATA, 1 track, MFM, no skip
	LD	B,9
	CALL	L7921		; write 9 bytes to controller
	LD	DE,L7FF4
	LD	B,0
L788A:	LD	A,(DE)
	ADD	A,A
	JP	NC,L788A
	ADD	A,A
	RET	P
	LD	A,(L7FF5)
	DJNZ	L788A
L7896:	LD	A,(DE)
L7897:	ADD	A,A
	JP	NC,L7896
	ADD	A,A
	RET	P
	LD	A,(L7FF5)
L78A0:	DJNZ	L7896
	POP	BC
	POP	BC
L78A4:	CALL	L799C		; Terminal Count
	CALL	L797B		; read bytes from controller
	POP	BC
	POP	DE
	POP	HL
	RET

L78AE:	INC	H
	INC	H		; +512
	LD	A,(IX+14)
	INC	A
	LD	(IX+14),A	; R+1
	BIT	7,D
	JR	NZ,L78BE
	CP	9+1
	RET	C
L78BE:	CP	8+1
	RET	C		; still on this cylinder, quit
	LD	(IX+14),1	; R=1
	BIT	6,D
	JR	Z,L78DC		; SS, next track
	LD	A,(IX+13)
	XOR	001H
	LD	(IX+13),A	; other head
	JR	Z,L78D8		; now head 0, next track
	SET	2,(IX+11)
	RET
L78D8:	RES	2,(IX+11)
L78DC:	INC	C
	JR	L7900

L78DF:	BIT	0,E
	RET	NZ
	PUSH	BC
	LD	(IX+10),00FH	; SEEK
	LD	(IX+12),6	; Track 6
	LD	B,3
	CALL	L7921		; write 3 bytes to controller
	CALL	L7955		; wait for end of seek
	LD	(IX+10),007H	; RECALIBRATE
	LD	B,2
	CALL	L7921		; write 2 bytes to controller
	CALL	L7955		; wait for end of seek
	POP	BC

L7900:	PUSH	BC
	LD	B,119
L7903:	EX	(SP),HL
	EX	(SP),HL
	DJNZ	L7903		; wait 1.8 ms
	LD 	(IX+10),00FH	; SEEK
	LD	(IX+12),C	; track
	LD	B,3
	CALL	L7921		; write 3 bytes to controller
	CALL	L7955		; wait on end of seek
	LD	BC,1907
L7919:	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,L7919	; wait 16 ms
	POP	BC
	XOR	A
	RET

L7921:	PUSH	HL
	LD	HL,2000
L7925:	LD	A,(L7FF4)
	AND	010H
	JR	Z,L7934		; FDC ready,
	DEC	HL
	LD	A,H
	OR	L
	JR	NZ,L7925	; wait until FDC ready
	POP	HL
	SCF			; error flag (takes to much time)
	RET

L7934:	PUSH	DE
	PUSH	IX
	LD	DE,10
	ADD	IX,DE
	PUSH	IX
	POP	HL
	POP	IX
	POP	DE
L7942:	LD	A,(L7FF4)
	AND	0C0H
	CP	080H
	JR	NZ,L7942	; wait until Output Request
	LD	A,(HL)
	LD	(L7FF5),A
	INC	HL
	DJNZ	L7942
	POP	HL
	XOR	A
	RET

L7955:	LD	A,(L7FF4)
	AND	010H
	JR	NZ,L7955	; FDC is busy, wait
L795C:	CALL	L796B		; get status
	LD	A,(IX+19)
	BIT	5,A
	JR	Z,L795C		; Seek not completed, wait
	AND	0C0H
	RET	Z
	SCF			; Seek error
	RET

L796B:	PUSH	BC
	LD	(IX+10),008H	; SENSE INTERRUPT STATUS
	LD	B,1
	CALL	L7921		; write bytes to controller
	CALL	L797B		; read bytes from controller
	XOR	A
	POP	BC
	RET

L797B:	PUSH	IX
L797D:	LD	A,(L7FF4)
	ADD	A,A
	JR	NC,L797D	; wait on Request
	JP	P,L7990		; Output Request, quit
	LD	A,(L7FF5)
	LD	(IX+19),A
	INC	IX
	JR	L797D
L7990:	POP	IX
	RET

L7993:	LD	BC,1960
L7996:	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,L7996
	RET

L799C:	LD	A,002H
	LD	(L7FF3),A	; enable C0, TC=0
	INC	A
	LD	(L7FF3),A	; enable C0, TC=1
	NOP
	DEC	A
	LD	(L7FF3),A	; enable C0, TC=0
	RET

L79AB:	LD	E,(IX+20)	; ST1
	BIT	2,E
	LD	A,8
	RET	NZ		; No Data, quit with Record not found
	BIT	5,E
	LD	A,4
	RET	NZ		; Data error, quit with Data error
	LD	A,12
	RET			; quit with other error

L79BB:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	DE,L79F2
	PUSH	DE
	LD	DE,L7993	; wait 16.5 ms routine
	PUSH	DE
	LD	(IX+10),046H	; READ DATA, 1 Track, MFM, No skip
	LD	B,9
	CALL	L7921		; write bytes to controller
	LD	DE,L7FF4
	LD	B,0
L79D4:	LD	A,(DE)
	ADD	A,A
	JP	NC,L79D4	; wait on Request
	ADD	A,A
	RET	P		; Output Request, quit
	LD	A,(L7FF5)
	LD	(HL),A
	INC	HL
	DJNZ	L79D4
L79E2:	LD	A,(DE)
	ADD	A,A
	JP	NC,L79E2
	ADD	A,A
	RET	P
	LD	A,(L7FF5)
	LD	(HL),A
	INC	HL
	DJNZ	L79E2
	POP	BC
	POP	BC		; remove unused error handler
L79F2:	CALL	L799C		; Terminal Count
	CALL	L797B		; read bytes from controller
	POP	BC
	POP	DE
	POP	HL
	RET

L79FC:	PUSH	HL
	PUSH	IY
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	DE,L7AC0	; relocation offsets head loop read operation
	LD	HL,L7B2C	; head loop read operation
	LD	BC,006CH	; size
	JR	NC,L7A16
	LD	DE,L7ACE	; relocation offsets head loop write operation
	LD	HL,L7B98	; head loop write operation
	LD	BC,00BAH	; size
L7A16:	PUSH	DE
	LD	DE,($SECBUF)
	LDIR			; copy routine to secbuf
	POP	HL
	PUSH	DE
L7A1F:	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	A,D
	OR	E
	JR	Z,L7A3C
	PUSH	HL
	LD	HL,($SECBUF)
	ADD	HL,DE
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	EX	DE,HL
	LD	HL,($SECBUF)
	ADD	HL,BC
	EX	DE,HL
	LD	(HL),D
	DEC	HL
	LD	(HL),E
	POP	HL
	JR	L7A1F		; relocate code
L7A3C:	POP	DE
	POP	AF
	PUSH	AF
	PUSH	DE
	LD	HL,L78AE	; support routines
	LD	BC,014EH
	JR	NC,L7A4B	; read and write routines
	LD	BC,010DH	; only write routines
L7A4B:	LDIR
	POP	IY
	PUSH	AF
	POP	AF
	LD	HL,L7AE8	; relocation offsets support routines
	LD	B,17
	JR	NC,L7A5A
	LD	B,10
L7A5A:	PUSH	BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	PUSH	HL
	PUSH	IY
	POP	HL
	ADD	HL,DE
	INC	HL
	LD	C,(HL)
	INC	HL
	LD	B,(HL)
	PUSH	HL
	PUSH	IY
	POP	HL
	LD	DE,L78AE
	XOR	A
	SBC	HL,DE
	POP	DE
	ADD	HL,BC
	EX	DE,HL
	LD	(HL),D
	DEC	HL
	LD	(HL),E
	POP	HL
	POP	BC
	DJNZ	L7A5A
	POP	AF
	PUSH	AF
	LD	HL,L7B0A	; offsets for diskcontroller adres
	LD	B,12
	JR	NC,L7A87
	LD	B,9
L7A87:	PUSH	BC
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	PUSH	HL
	PUSH	IY
	POP	HL
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	(HL),0BFH
	POP	HL
	POP	BC
	DJNZ	L7A87
	POP	AF
	JR	C,L7AB7
	BIT	1,(IX+5)
	JR	Z,L7AB7			; no verify
	LD	HL,L7B22		; offsets for verify
L7AA5:	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	INC	HL
	LD	A,D
	OR	E
	JR	Z,L7AB7
	PUSH	HL
	PUSH	IY
	POP	HL
	ADD	HL,DE
	LD	(HL),0
	POP	HL
	JR	L7AA5
L7AB7:	POP	BC
	POP	DE
	POP	IY
	LD	HL,($SECBUF)
	EX	(SP),HL
	RET


L7AC0:	DEFW	0006H
	DEFW	001EH
	DEFW	0028H
	DEFW	003AH
	DEFW	0043H
	DEFW	0049H
	DEFW	0000H

L7ACE:	DEFW	0006H
	DEFW	001EH
	DEFW	002BH
	DEFW	0043H
	DEFW	0051H
	DEFW	002FH
	DEFW	0039H
	DEFW	005FH
	DEFW	0067H
	DEFW	0077H
	DEFW	0086H
	DEFW	0094H
	DEFW	0000H

L7AE8:	DEFW	003FH
	DEFW	0042H
	DEFW	004BH
	DEFW	004EH
	DEFW	0062H
	DEFW	0065H
	DEFW	00AEH
	DEFW	00C4H
	DEFW	00C7H
	DEFW	00D5H
	DEFW	0110H
	DEFW	0114H
	DEFW	011EH
	DEFW	0128H
	DEFW	0136H
	DEFW	0144H
	DEFW	0147H

L7B0A:	DEFW	0077H
	DEFW	0094H
	DEFW	009EH
	DEFW	00A7H
	DEFW	00CFH
	DEFW	00D8H
	DEFW	00F0H
	DEFW	00F4H
	DEFW	00F9H
	DEFW	0121H
	DEFW	012DH
	DEFW	013BH

L7B22:	DEFW	0130H
	DEFW	0131H
	DEFW	013EH
	DEFW	013FH
	DEFW	0000H


L7B2C:
	.PHASE	0

	PUSH	HL
	PUSH	DE
	PUSH	BC
	CALL	GETSLT
	LD	(L0060+1),A
	LD	H,080H
	CALL	ENASLT
	LD	A,(RAMAD1)
	LD	H,040H
	CALL	ENASLT
	POP	BC
	POP	DE
	POP	HL
L7B45:	DEC	HL
	LD	A,H
	ADD	A,2
	INC	HL
	JP	M,L7B7D
	LD	E,00BH
L7B4F:	LD	A,020H
	LD	(L7FF3+04000H),A
	CALL	00179H
	LD	A,030H
	LD	(L7FF3+04000H),A
	LD	A,(IX+19)
	AND	0C8H
	JR	NZ,L7B6B
	DEC	B
	JR	Z,L7B7D
	CALL	0006CH
	JR	L7B45
L7B6B:	AND	008H
	JR	NZ,L7B7A
	CALL	0009DH
	DEC	E
	JR	NZ,L7B4F
	CALL	00169H
	JR	L7B7C
L7B7A:	LD	A,002H
L7B7C:	SCF
L7B7D:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	A,(RAMAD2)
	LD	H,080H
	CALL	ENASLT
	CALL	XF368
L0060:	LD	A,0
	LD	H,040H
	CALL	ENASLT
	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET

	.DEPHASE

SZ7B2C	equ	$-L7B2C


L7B98:
	.PHASE	0

	PUSH	HL
	PUSH	DE
	PUSH	BC
	CALL	GETSLT
	LD	(L00AE+1),A
	LD	H,080H
	CALL	ENASLT
	LD	A,(RAMAD1)
	LD	H,040H
	CALL	ENASLT
	POP	BC
	POP	DE
	POP	HL
L7BB1:	DEC	HL
	LD	A,H
	ADD	A,2
	INC	HL
	JP	M,L7C37
	LD	E,00BH
L7BBB:	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	A,020H
	LD	(L7FF3+04000H),A
	LD	DE,L7BF7
	PUSH	DE
	LD	DE,0019FH
	PUSH	DE
	LD	(IX+10),045H		; WRITE DATA
	LD	B,009H
	CALL	0012DH
	LD	DE,L7FF4+04000H
	LD	B,0
L7BD9:	LD	A,(DE)
	ADD	A,A
	JP	NC,L7BD9
	ADD	A,A
	RET	P
	LD	A,(HL)
	LD	(L7FF5+04000H),A
	INC	HL
	DJNZ	L7BD9
L7BE7:	LD	A,(DE)
	ADD	A,A
	JP	NC,L7BE7
	ADD	A,A
	RET	P
	LD	A,(HL)
	LD	(L7FF5+04000H),A
 	INC	HL
	DJNZ	L7BE7
	POP	BC
	POP	BC
L7BF7:	CALL	001A8H
	LD	A,030H
	LD	(L7FF3+04000H),A
	CALL	00187H
	POP	BC
	POP	DE
	POP	HL
	LD	A,(IX+19)
	AND	0C8H
	JR	NZ,L7C14
	DEC	B
	JR	Z,L7C37
	CALL	000BAH
	JR	L7BB1
L7C14:	AND	008H
	JR	NZ,L7C34
	BIT	1,(IX+20)
	JR	NZ,L7C31
	CALL	000EBH
	DEC	E
	JR	NZ,L7BBB
	BIT	4,(IX+19)
	LD	A,00AH
	JR	NZ,L7C36
	CALL	001B7H
	JR	L7C36
L7C31:	XOR	A
	JR	L7C36
L7C34:	LD	A,002H
L7C36:	SCF
L7C37:	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	A,(RAMAD2)
	LD	H,080H
	CALL	ENASLT
	CALL	XF368
L00AE:	LD	A,0
	LD	H,040H
	CALL	ENASLT
	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET

	.DEPHASE

SZ7B98	equ	$-L7B98

; DSKFMT
;
; Formats a disk

DSKFMT:	PUSH	HL
	POP	IY		; IY= ptr to workarea
	DEC	A
	LD	(IY+9),A	; choice (0=single, 1=double)
	LD	E,A
	LD	A,1
	CP	E
	LD	A,12
	RET	C		; choice <1 or >2, bad parameter
	LD	A,B
	CP	014H
	LD	A,14
	RET	C		; less then 5120 bytes, insufficient memory
	LD	A,D
	AND	001H
	LD	(IY+8),A	; driveid
	LD	D,A
	PUSH	HL
	PUSH	DE
	CALL	GETWRK		; GETWRK
	POP	DE
	LD	A,(IX+7)
	DEC	A
	JR	NZ,L7C96	; double drive system
	LD	A,D
	CP	(IX+3)
	JR	Z,L7C94		; same logical drive,
	LD	(IX+3),A
	PUSH	DE
	PUSH	IY
	CALL	PROMPT		; PROMPT
	POP	IY
	POP	DE
L7C94:	LD	D,0
L7C96:	POP	HL
	LD	(IY+7),D	; physical driveid
	PUSH	HL
	LD	BC,10
	ADD	HL,BC
	LD	(IY+5),L
	LD	(IY+6),H	; start of ?? area in workarea
	LD	D,0
	LD	B,5
	LD	HL,L7E13
L7CAC:	ADD	HL,DE
	DJNZ	L7CAC
	POP	DE		; start of workarea
	LD	C,5
	LDIR			; copy diskformat info
	BIT	0,(IY+7)
	LD	A,014H
	JR	Z,L7CBE		; physical drive 0
	LD	A,025H
L7CBE:	LD	(L7FF2),A	; motor on
	CALL	L76C1		; wait 1 second (motor spin up ?)
	PUSH	IY
	POP	HL
	LD	DE,10
	ADD	HL,DE
	LD	(HL),0
	INC	HL
	LD	D,1		; begin with sector 1
	LD	BC,00902H	; 9 sectors
L7CD3:	XOR	A
	LD	(HL),A		; C
	INC	HL
	LD	(HL),A		; H
	INC	HL
	LD	(HL),D		; R
	INC	D
	INC	HL
	LD	(HL),C		; N
	INC	HL
	DJNZ	L7CD3
	PUSH	IY
	POP	HL
	LD	DE,0002FH
	ADD	HL,DE
	PUSH	HL
	POP	IX
	LD	A,(IY+7)	; physical drive
	LD	(IX+11),A
	LD	C,6
	CALL	L7900		; select track 6
	CALL	L773B		; recalibrate
	LD	A,006H
	JP	C,L7D4B		; seek error
	CALL	DISINT
	DI			; disable interrupts
L7D00:	LD	C,(IY+10)
	LD	A,(IY+7)	; physical drive
	LD	(IX+11),A
	CALL	L7900		; select track
	LD	A,006H
	JR	C,L7D4B		; seek error
	LD	B,0		; side 0
	CALL	L7E68		; format track
	JR	C,L7D4B		; error, finish dskfmt
	BIT	0,(IY+2)	; single ?
	JR	Z,L7D2A		; yep, skip side 1
	CALL	L7993		; wait 16.5 ms
	CALL	L7F1B		; change side in track data
	LD	B,004H		; side 1
	CALL	L7E68		; format track
	JR	C,L7D4B		; error, finish dskfmt
L7D2A:	LD	A,(IY+10)
	INC	A
	CP	80
	JR	NC,L7D57	; track 80, done
	LD	(IY+10),A
	PUSH	IY
	POP	HL
	LD	BC,11
	ADD	HL,BC
	LD	B,9
L7D3E:	LD	(HL),A		; update track
	INC	HL
	LD	(HL),0		; side 0
	INC	HL
	INC	HL
	INC	HL
	DJNZ	L7D3E
	JR	L7D00		; next track
L7D49:	POP	BC
	POP	HL
L7D4B:	PUSH	AF
	EI
	CALL	ENAINT		; enable interrupts
	CALL	L7867		; motor off
	POP	AF
	JP	L7DFD		; adjust to dskfmt errorcodes

L7D57:	PUSH	IY
	POP	HL
	INC	H
	INC	H
	LD	DE,0		; sector 0
	LD	BC,050F8H	; 80 tracks, 0F8H media
	BIT	0,(IY+9)
	JR	Z,L7D6B
	LD	B,0A0H
	INC	C		; 160 tracks, 0F9H media
L7D6B:	PUSH	HL
	PUSH	BC
	PUSH	DE
	LD	B,9		; hole track
	LD	A,(IY+8)
	AND	A		; read
	CALL	DSKIO		; DSKIO
	POP	DE
	JR	C,L7D49		; error, finish dskfmt
	LD	HL,9
	ADD	HL,DE
	EX	DE,HL
	POP	BC
	POP	HL
	DJNZ	L7D6B		; next track
	CALL	L7E05		; clear trackbuffer
	PUSH	HL
	EX	DE,HL
	LD	L,(IY+0)
	LD	H,(IY+1)
	LD	BC,0001EH
	LDIR			; DPB
	LD	HL,L7F2D
	LD	BC,bootlength
	LDIR			; Boottrap loader
	POP	HL
	PUSH	HL
	INC	H
	INC	H
	LD	A,(IY+2)
	LD	(HL),A		; mediabyte
	INC	HL
	DEC	(HL)		; #FF
	INC	HL
	DEC	(HL)		; #FF
	INC	H
	INC	H
	INC	H
	INC	H
	CP	0F9H
	JR	NZ,L7DB1
	INC	H
	INC	H		; media 0F9H has 3 sectors per FAT
L7DB1:	DEC	(HL)		; #FF
	DEC	HL
	DEC	(HL)		; #FF
	DEC	HL
	LD	(HL),A		; mediabyte
	POP	HL
	LD	C,A
	LD	B,9		; 9 sectors
	LD	DE,0		; sector 0
	LD	A,(IY+8)
	PUSH	DE
	PUSH	AF
	PUSH	BC
	PUSH	HL
	SCF			; write
	CALL	DSKIO		; DSKIO
	JR	C,L7DF9		; error, adjust to dskfmt errorcodes and quit
	POP	HL
	POP	BC
	POP	AF
	POP	DE
	PUSH	DE
	PUSH	AF
	PUSH	BC
	PUSH	HL
	AND	A		; read
	CALL	DSKIO		; DSKIO
	JR	C,L7DF9		; error, adjust to dskfmt errorcodes and quit
	POP	HL
	CALL	L7E05		; clear trackbuffer
	POP	BC
	POP	AF
	POP	DE
	LD	B,5		; 5 sectors
	LD	DE,9		; sector 9
	PUSH	DE
	PUSH	AF
	PUSH	BC
	PUSH	HL
	SCF			; write
	CALL	DSKIO		; DSKIO
	JR	C,L7DF9		; error, adjust to dskfmt errorcodes and quit
	POP	HL
	POP	BC
	POP	AF
	POP	DE
	AND	A		; read
	CALL	DSKIO		; DSKIO
	JR	C,L7DFD		; error, adjust to dskfmt errorcodes and quit
	RET
L7DF9:	POP	HL
	POP	BC
	POP	DE
	POP	DE
L7DFD:	CP	12
	JR	NZ,L7E03
	LD	A,16
L7E03:	SCF
	RET

L7E05:	PUSH	HL
	LD	BC,9*512
L7E09:	LD	(HL),0
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,L7E09
	POP	HL
	RET

L7E13:	DW	L7E1D
	DB	0F8h
	DW	720

	DW	L7E3B
	DB	0F9h
	DW	1440

L7E1D:	DB	0EBh,0FEh,090h
	DB	"MSX_03  "
	DW	512
	DB	2
	DW	1
	DB	2
	DW	112
	DW	720
	DB	0F8h
	DW	2
	DW	9
	DW	1
	DW	0

L7E3B:	DB	0EBh,0FEh,090h
	DB	"MSX_04  "
	DW	512
	DB	2
	DW	1
	DB	2
	DW	112
	DW	1440
	DB	0F9h
	DW	3
	DW	9
	DW	2
	DW	0

L7E59:	DEFB 	04DH		; FORMAT A TRACK
	DEFB	000H		; Unit, Head
	DEFB	2		; 512 bytes sector
	DEFB	9		; 9 sectors on a track
	DEFB	80		; GAP3= 80 bytes
	DEFB	040H		; Filler byte

; This table is NOT USED!

	DEFB	046H		; READ DATA, 1 track, MFM, no skip
	DEFB	0		; Unit, Head
	DEFB	0		; Cylinder
	DEFB	0		; Head
	DEFB	1		; Start Record
	DEFB	2		; 512 byte sector
	DEFB	9		; End Record
	DEFB	80		; GAP3= 80 bytes
	DEFB	0FFH		; Datalength

L7E68:	CALL	L785F		; normal ready
	LD	A,(IY+7)	; physical drive
	LD	(IX+11),A
	CALL	L76CF		; wait FDD ready
	JP	C,L7F0F		; timeout, 30h to 7FF3 (force ready) and quit with not ready error
	BIT	6,A
	JP	NZ,L7F15	; 30h to 7FF3 (force ready), quit with write protect error
	PUSH	BC
	PUSH	IX
	POP	HL
	LD	DE,10
	ADD	HL,DE
	EX	DE,HL
	LD	HL,L7E59
	LD	BC,6
	LDIR
	POP	BC
	LD	A,(IY+7)
	OR	B
	LD	(IX+11),A	; Unit
	LD	B,6
	CALL	L7921		; write bytes to controller
	PUSH	IY
	POP	HL
	LD	BC,11
	ADD	HL,BC
	LD	C,9		; 9 sectors
	LD	DE,L7FF4
L7EA6:	PUSH	BC
	LD	BC,0
L7EAA:	DEC	BC
	LD	A,B
	OR	C
	JR	Z,L7EFF		; takes too long
	LD	A,(DE)
	ADD	A,A
	JP	NC,L7EAA	; wait until b7 set
	LD	A,(HL)
	LD	(L7FF5),A
	INC	HL
	POP	BC
	LD	B,3
L7EBC:	LD	A,(DE)
	ADD	A,A
	JP	NC,L7EBC	; wait until b7 set
	LD	A,(HL)
	LD	(L7FF5),A
	INC	HL
	DJNZ	L7EBC
	DEC	C
	JR	NZ,L7EA6	; next sector
	CALL	L799C		; Terminal Count
	LD	BC,0
L7ED1:	DEC	BC
	LD	A,B
	OR	C
	JR	Z,L7F00		; takes too long
	LD	A,(DE)
	AND	0C0H
	CP	0C0H
	JR	NZ,L7ED1	; wait until command ends
	CALL	L797B		; read bytes from controller
L7EE0:	CALL	L7863		; force ready
	LD	A,(IX+19)
	LD	B,A
	AND	0C0H
	RET	Z
	SCF
	BIT	3,B
	LD	A,2
	RET	NZ		; not ready
	BIT	4,B
	LD	A,10
	RET	NZ		; write fault
	BIT	1,(IX+20)
	LD	A,0
	RET	NZ		; write protect
	LD	A,16
	RET
L7EFF:	POP	BC
L7F00:	XOR	A
	CALL	L7716		; init FDC
	LD	A,004H		; motor off, normal operation, select drv 0
	CALL	L7732		; init drive
	LD	(IX+19),0C8H
	JR	L7EE0

L7F0F:	CALL	L7863		; force ready
	LD	A,2
	RET

L7F15:	CALL	L7863		; force ready
	XOR	A
	SCF
	RET

L7F1B:	PUSH	IY
	POP	HL
	LD	DE,12
	ADD	HL,DE
	LD	B,9
L7F24:	LD	(HL),1
	INC	HL
	INC	HL
	INC	HL
	INC	HL
	DJNZ	L7F24
	RET

L7F2D:
		.PHASE 0C01Eh

BootTrap:	ret	nc
		ld	(SetRomPage+1),de
		ld	(StartFlag),a
		ld	(hl),LOW ErrorHand
		inc	hl
		ld	(hl),HIGH ErrorHand
BootAgain:	ld	sp,0F51Fh
		ld	de,MsxDosFcb
		ld	c,0Fh
		call	0F37Dh
		inc	a
		jp	z,OpenDosError
		ld	de,0100h
		ld	c,01Ah
		call	0F37Dh
		ld	hl,1
		ld	(MsxDosFcb+0Eh),hl
		ld	hl,04000h-0100h
		ld	de,MsxDosFcb
		ld	c,027h
		call	0F37Dh
		jp	0100h

ErrorHand:	dw	SetRomPage

SetRomPage:	call	0
		ld	a,c
		and	0FEh
		cp	02h
		jp	nz,DiskBootError
OpenDosError:	ld	a,(StartFlag)
		and	a			; Startup ?
		jr	z,JmpDiskBasic		; yep, jump direct
DiskBootError:	ld	de,BootErrorTxt
		ld	c,09h
		call	0F37Dh
		ld	c,07h
		call	0F37Dh
		cp	3			; Ctrl-C ?
		jr	nz,BootAgain		; nop, boot again
JmpDiskBasic:	jp	04022h			; (re)start DiskBasic

BootErrorTxt:	db	"Boot error",13,10
		db	"Press any key for retry",13,10
		db	"$"

MsxDosFcb:	db	0
		db	"MSXDOS  SYS"
		dw 	0
		dw	0
		db	0,0,0,0
		dw	0
		dw	0
		db	0
		db	0
		dw	0
		dw	0
		dw	0
		db	0
		db	0,0,0,0

StartFlag:	db	0

		.DEPHASE

BootLength	equ	$-L7F2D


		defs	07FD8H-$,0

; diskdrive interrupt handler
;
; this is kept hard on adres 03FD8 for dos1/dos2 combined diskroms

L7789:	PUSH	AF
	CALL	GETWRK		; GETWRK
	INC	HL
	LD	A,(HL)
	AND	A		; drive 0 counter 0 ?
	JR	Z,L7793
	DEC	(HL)		; nope, decrease
L7793:	INC	HL
	LD	A,(HL)
	AND	A		; drive 1 counter 0 ?
	JR	Z,L7799
	DEC	(HL)		; nope, decrease
L7799:	POP	AF
	JP	PRVINT		; PRVINT


; S1990 FDD registers

L7FF0	EQU	07FF0H		; Diskrom 'segment' select
L7FF1	EQU	07FF1H		; ???, b4 = -DC0, b5 = -DC1, b1 = -HD1, b0 = -HD0

; TC8566 FDC registers

L7FF2	EQU	07FF2H		; DOR, b0 = 0 drive 0, 1 drive 1
				;      b2 = 0 reset FDC, 1 enable FDC
				;      b3 = 0 disable DMA, 1 enable DMA
				;      b4 = 1 motor select drive 0
				;      b5 = 1 motor select drive 1
L7FF3	EQU	07FF3H		; TDR, b0 = TC
				;      b1 = enable writing to TC bit
				;      b2 = STANDBY
				;      b3 = enable writing to STANDBY bit
				;      b4 = C4 = FORCE READY
				;      b5 = enable writing to C4
                   		;      b6 = C6 = not used
				;      b7 = enable writing to C6
L7FF4	EQU	07FF4H		; MSR, Statusport FDC
L7FF5	EQU	07FF5H		; DAT, Dataport FDC

